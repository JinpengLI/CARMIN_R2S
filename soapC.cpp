/* soapC.cpp
   Generated by gSOAP 2.7.17 from api.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.17 2016-01-13 17:01:41 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__Module:
		return soap_in_ns1__Module(soap, NULL, NULL, "ns1:Module");
	case SOAP_TYPE_ns1__ExecutionStatus:
		return soap_in_ns1__ExecutionStatus(soap, NULL, NULL, "ns1:ExecutionStatus");
	case SOAP_TYPE_ns1__ParameterType:
		return soap_in_ns1__ParameterType(soap, NULL, NULL, "ns1:ParameterType");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__listExecutionsResponse:
		return soap_in_ns1__listExecutionsResponse(soap, NULL, NULL, "ns1:listExecutionsResponse");
	case SOAP_TYPE_ns1__listExecutions:
		return soap_in_ns1__listExecutions(soap, NULL, NULL, "ns1:listExecutions");
	case SOAP_TYPE_ns1__listPipelinesResponse:
		return soap_in_ns1__listPipelinesResponse(soap, NULL, NULL, "ns1:listPipelinesResponse");
	case SOAP_TYPE_ns1__listPipelines:
		return soap_in_ns1__listPipelines(soap, NULL, NULL, "ns1:listPipelines");
	case SOAP_TYPE_ns1__playExecutionResponse:
		return soap_in_ns1__playExecutionResponse(soap, NULL, NULL, "ns1:playExecutionResponse");
	case SOAP_TYPE_ns1__playExecution:
		return soap_in_ns1__playExecution(soap, NULL, NULL, "ns1:playExecution");
	case SOAP_TYPE_ns1__getExecutionResponse:
		return soap_in_ns1__getExecutionResponse(soap, NULL, NULL, "ns1:getExecutionResponse");
	case SOAP_TYPE_ns1__getExecution:
		return soap_in_ns1__getExecution(soap, NULL, NULL, "ns1:getExecution");
	case SOAP_TYPE_ns1__killExecutionResponse:
		return soap_in_ns1__killExecutionResponse(soap, NULL, NULL, "ns1:killExecutionResponse");
	case SOAP_TYPE_ns1__getStdErrResponse:
		return soap_in_ns1__getStdErrResponse(soap, NULL, NULL, "ns1:getStdErrResponse");
	case SOAP_TYPE_ns1__getStdErr:
		return soap_in_ns1__getStdErr(soap, NULL, NULL, "ns1:getStdErr");
	case SOAP_TYPE_ns1__getStdOutResponse:
		return soap_in_ns1__getStdOutResponse(soap, NULL, NULL, "ns1:getStdOutResponse");
	case SOAP_TYPE_ns1__getStdOut:
		return soap_in_ns1__getStdOut(soap, NULL, NULL, "ns1:getStdOut");
	case SOAP_TYPE_ns1__killExecution:
		return soap_in_ns1__killExecution(soap, NULL, NULL, "ns1:killExecution");
	case SOAP_TYPE_ns1__getExecutionResultsResponse:
		return soap_in_ns1__getExecutionResultsResponse(soap, NULL, NULL, "ns1:getExecutionResultsResponse");
	case SOAP_TYPE_ns1__getExecutionResults:
		return soap_in_ns1__getExecutionResults(soap, NULL, NULL, "ns1:getExecutionResults");
	case SOAP_TYPE_ns1__initExecutionResponse:
		return soap_in_ns1__initExecutionResponse(soap, NULL, NULL, "ns1:initExecutionResponse");
	case SOAP_TYPE_ns1__initExecution:
		return soap_in_ns1__initExecution(soap, NULL, NULL, "ns1:initExecution");
	case SOAP_TYPE_ns1__getGlobalPropertiesResponse:
		return soap_in_ns1__getGlobalPropertiesResponse(soap, NULL, NULL, "ns1:getGlobalPropertiesResponse");
	case SOAP_TYPE_ns1__getGlobalProperties:
		return soap_in_ns1__getGlobalProperties(soap, NULL, NULL, "ns1:getGlobalProperties");
	case SOAP_TYPE_ns1__updateExecutionResponse:
		return soap_in_ns1__updateExecutionResponse(soap, NULL, NULL, "ns1:updateExecutionResponse");
	case SOAP_TYPE_ns1__StringKeyValuePair:
		return soap_in_ns1__StringKeyValuePair(soap, NULL, NULL, "ns1:StringKeyValuePair");
	case SOAP_TYPE_ns1__updateExecution:
		return soap_in_ns1__updateExecution(soap, NULL, NULL, "ns1:updateExecution");
	case SOAP_TYPE_ns1__logoutResponse:
		return soap_in_ns1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_ns1__logout:
		return soap_in_ns1__logout(soap, NULL, NULL, "ns1:logout");
	case SOAP_TYPE_ns1__authenticateHTTPResponse:
		return soap_in_ns1__authenticateHTTPResponse(soap, NULL, NULL, "ns1:authenticateHTTPResponse");
	case SOAP_TYPE_ns1__authenticateHTTP:
		return soap_in_ns1__authenticateHTTP(soap, NULL, NULL, "ns1:authenticateHTTP");
	case SOAP_TYPE_ns1__getPipelineResponse:
		return soap_in_ns1__getPipelineResponse(soap, NULL, NULL, "ns1:getPipelineResponse");
	case SOAP_TYPE_ns1__getPipeline:
		return soap_in_ns1__getPipeline(soap, NULL, NULL, "ns1:getPipeline");
	case SOAP_TYPE_ns1__deleteExecutionResponse:
		return soap_in_ns1__deleteExecutionResponse(soap, NULL, NULL, "ns1:deleteExecutionResponse");
	case SOAP_TYPE_ns1__deleteExecution:
		return soap_in_ns1__deleteExecution(soap, NULL, NULL, "ns1:deleteExecution");
	case SOAP_TYPE_ns1__PipelineKeyBooleanValuePair:
		return soap_in_ns1__PipelineKeyBooleanValuePair(soap, NULL, NULL, "ns1:PipelineKeyBooleanValuePair");
	case SOAP_TYPE_ns1__GlobalProperties:
		return soap_in_ns1__GlobalProperties(soap, NULL, NULL, "ns1:GlobalProperties");
	case SOAP_TYPE_ns1__StringKeyParameterValuePair:
		return soap_in_ns1__StringKeyParameterValuePair(soap, NULL, NULL, "ns1:StringKeyParameterValuePair");
	case SOAP_TYPE_ns1__Execution:
		return soap_in_ns1__Execution(soap, NULL, NULL, "ns1:Execution");
	case SOAP_TYPE_ns1__IntKeyStringValuePair:
		return soap_in_ns1__IntKeyStringValuePair(soap, NULL, NULL, "ns1:IntKeyStringValuePair");
	case SOAP_TYPE_ns1__ParameterTypedValue:
		return soap_in_ns1__ParameterTypedValue(soap, NULL, NULL, "ns1:ParameterTypedValue");
	case SOAP_TYPE_ns1__PipelineParameter:
		return soap_in_ns1__PipelineParameter(soap, NULL, NULL, "ns1:PipelineParameter");
	case SOAP_TYPE_ns1__ArrayOfExecutions:
		return soap_in_ns1__ArrayOfExecutions(soap, NULL, NULL, "ns1:ArrayOfExecutions");
	case SOAP_TYPE_ns1__ArrayOfPipelines:
		return soap_in_ns1__ArrayOfPipelines(soap, NULL, NULL, "ns1:ArrayOfPipelines");
	case SOAP_TYPE_ns1__ArrayOfStrings:
		return soap_in_ns1__ArrayOfStrings(soap, NULL, NULL, "ns1:ArrayOfStrings");
	case SOAP_TYPE_ns1__Object:
		return soap_in_ns1__Object(soap, NULL, NULL, "ns1:Object");
	case SOAP_TYPE_ns1__Pipeline:
		return soap_in_ns1__Pipeline(soap, NULL, NULL, "ns1:Pipeline");
	case SOAP_TYPE_ns1__Response:
		return soap_in_ns1__Response(soap, NULL, NULL, "ns1:Response");
	case SOAP_TYPE_ns1__authenticateSessionResponse:
		return soap_in_ns1__authenticateSessionResponse(soap, NULL, NULL, "ns1:authenticateSessionResponse");
	case SOAP_TYPE_ns1__authenticateSession:
		return soap_in_ns1__authenticateSession(soap, NULL, NULL, "ns1:authenticateSession");
	case SOAP_TYPE_PointerTons1__listExecutionsResponse:
		return soap_in_PointerTons1__listExecutionsResponse(soap, NULL, NULL, "ns1:listExecutionsResponse");
	case SOAP_TYPE_PointerTons1__listExecutions:
		return soap_in_PointerTons1__listExecutions(soap, NULL, NULL, "ns1:listExecutions");
	case SOAP_TYPE_PointerTons1__listPipelinesResponse:
		return soap_in_PointerTons1__listPipelinesResponse(soap, NULL, NULL, "ns1:listPipelinesResponse");
	case SOAP_TYPE_PointerTons1__listPipelines:
		return soap_in_PointerTons1__listPipelines(soap, NULL, NULL, "ns1:listPipelines");
	case SOAP_TYPE_PointerTons1__playExecutionResponse:
		return soap_in_PointerTons1__playExecutionResponse(soap, NULL, NULL, "ns1:playExecutionResponse");
	case SOAP_TYPE_PointerTons1__playExecution:
		return soap_in_PointerTons1__playExecution(soap, NULL, NULL, "ns1:playExecution");
	case SOAP_TYPE_PointerTons1__getExecutionResponse:
		return soap_in_PointerTons1__getExecutionResponse(soap, NULL, NULL, "ns1:getExecutionResponse");
	case SOAP_TYPE_PointerTons1__getExecution:
		return soap_in_PointerTons1__getExecution(soap, NULL, NULL, "ns1:getExecution");
	case SOAP_TYPE_PointerTons1__killExecutionResponse:
		return soap_in_PointerTons1__killExecutionResponse(soap, NULL, NULL, "ns1:killExecutionResponse");
	case SOAP_TYPE_PointerTons1__killExecution:
		return soap_in_PointerTons1__killExecution(soap, NULL, NULL, "ns1:killExecution");
	case SOAP_TYPE_PointerTons1__getExecutionResultsResponse:
		return soap_in_PointerTons1__getExecutionResultsResponse(soap, NULL, NULL, "ns1:getExecutionResultsResponse");
	case SOAP_TYPE_PointerTons1__getExecutionResults:
		return soap_in_PointerTons1__getExecutionResults(soap, NULL, NULL, "ns1:getExecutionResults");
	case SOAP_TYPE_PointerTons1__getStdErrResponse:
		return soap_in_PointerTons1__getStdErrResponse(soap, NULL, NULL, "ns1:getStdErrResponse");
	case SOAP_TYPE_PointerTons1__getStdErr:
		return soap_in_PointerTons1__getStdErr(soap, NULL, NULL, "ns1:getStdErr");
	case SOAP_TYPE_PointerTons1__getStdOutResponse:
		return soap_in_PointerTons1__getStdOutResponse(soap, NULL, NULL, "ns1:getStdOutResponse");
	case SOAP_TYPE_PointerTons1__getStdOut:
		return soap_in_PointerTons1__getStdOut(soap, NULL, NULL, "ns1:getStdOut");
	case SOAP_TYPE_PointerTons1__initExecutionResponse:
		return soap_in_PointerTons1__initExecutionResponse(soap, NULL, NULL, "ns1:initExecutionResponse");
	case SOAP_TYPE_PointerTons1__initExecution:
		return soap_in_PointerTons1__initExecution(soap, NULL, NULL, "ns1:initExecution");
	case SOAP_TYPE_PointerTons1__getGlobalPropertiesResponse:
		return soap_in_PointerTons1__getGlobalPropertiesResponse(soap, NULL, NULL, "ns1:getGlobalPropertiesResponse");
	case SOAP_TYPE_PointerTons1__getGlobalProperties:
		return soap_in_PointerTons1__getGlobalProperties(soap, NULL, NULL, "ns1:getGlobalProperties");
	case SOAP_TYPE_PointerTons1__updateExecutionResponse:
		return soap_in_PointerTons1__updateExecutionResponse(soap, NULL, NULL, "ns1:updateExecutionResponse");
	case SOAP_TYPE_PointerTons1__updateExecution:
		return soap_in_PointerTons1__updateExecution(soap, NULL, NULL, "ns1:updateExecution");
	case SOAP_TYPE_PointerTons1__logoutResponse:
		return soap_in_PointerTons1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTons1__logout:
		return soap_in_PointerTons1__logout(soap, NULL, NULL, "ns1:logout");
	case SOAP_TYPE_PointerTons1__authenticateHTTPResponse:
		return soap_in_PointerTons1__authenticateHTTPResponse(soap, NULL, NULL, "ns1:authenticateHTTPResponse");
	case SOAP_TYPE_PointerTons1__authenticateHTTP:
		return soap_in_PointerTons1__authenticateHTTP(soap, NULL, NULL, "ns1:authenticateHTTP");
	case SOAP_TYPE_PointerTons1__getPipelineResponse:
		return soap_in_PointerTons1__getPipelineResponse(soap, NULL, NULL, "ns1:getPipelineResponse");
	case SOAP_TYPE_PointerTons1__getPipeline:
		return soap_in_PointerTons1__getPipeline(soap, NULL, NULL, "ns1:getPipeline");
	case SOAP_TYPE_PointerTons1__deleteExecutionResponse:
		return soap_in_PointerTons1__deleteExecutionResponse(soap, NULL, NULL, "ns1:deleteExecutionResponse");
	case SOAP_TYPE_PointerTons1__deleteExecution:
		return soap_in_PointerTons1__deleteExecution(soap, NULL, NULL, "ns1:deleteExecution");
	case SOAP_TYPE_PointerTons1__authenticateSessionResponse:
		return soap_in_PointerTons1__authenticateSessionResponse(soap, NULL, NULL, "ns1:authenticateSessionResponse");
	case SOAP_TYPE_PointerTons1__authenticateSession:
		return soap_in_PointerTons1__authenticateSession(soap, NULL, NULL, "ns1:authenticateSession");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerTons1__IntKeyStringValuePair:
		return soap_in_PointerTons1__IntKeyStringValuePair(soap, NULL, NULL, "ns1:IntKeyStringValuePair");
	case SOAP_TYPE_PointerTons1__PipelineParameter:
		return soap_in_PointerTons1__PipelineParameter(soap, NULL, NULL, "ns1:PipelineParameter");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons1__StringKeyParameterValuePair:
		return soap_in_PointerTons1__StringKeyParameterValuePair(soap, NULL, NULL, "ns1:StringKeyParameterValuePair");
	case SOAP_TYPE_PointerTons1__StringKeyValuePair:
		return soap_in_PointerTons1__StringKeyValuePair(soap, NULL, NULL, "ns1:StringKeyValuePair");
	case SOAP_TYPE_PointerTons1__ParameterTypedValue:
		return soap_in_PointerTons1__ParameterTypedValue(soap, NULL, NULL, "ns1:ParameterTypedValue");
	case SOAP_TYPE_PointerTons1__PipelineKeyBooleanValuePair:
		return soap_in_PointerTons1__PipelineKeyBooleanValuePair(soap, NULL, NULL, "ns1:PipelineKeyBooleanValuePair");
	case SOAP_TYPE_PointerTons1__ExecutionStatus:
		return soap_in_PointerTons1__ExecutionStatus(soap, NULL, NULL, "ns1:ExecutionStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfPipelines:
		return soap_in_PointerTons1__ArrayOfPipelines(soap, NULL, NULL, "ns1:ArrayOfPipelines");
	case SOAP_TYPE_PointerTons1__ArrayOfExecutions:
		return soap_in_PointerTons1__ArrayOfExecutions(soap, NULL, NULL, "ns1:ArrayOfExecutions");
	case SOAP_TYPE_PointerTons1__ArrayOfStrings:
		return soap_in_PointerTons1__ArrayOfStrings(soap, NULL, NULL, "ns1:ArrayOfStrings");
	case SOAP_TYPE_PointerTons1__GlobalProperties:
		return soap_in_PointerTons1__GlobalProperties(soap, NULL, NULL, "ns1:GlobalProperties");
	case SOAP_TYPE_PointerTons1__Execution:
		return soap_in_PointerTons1__Execution(soap, NULL, NULL, "ns1:Execution");
	case SOAP_TYPE_PointerTons1__Pipeline:
		return soap_in_PointerTons1__Pipeline(soap, NULL, NULL, "ns1:Pipeline");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__Response:
		return soap_in_PointerTons1__Response(soap, NULL, NULL, "ns1:Response");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listExecutionsResponse"))
		{	*type = SOAP_TYPE_ns1__listExecutionsResponse;
			return soap_in_ns1__listExecutionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listExecutions"))
		{	*type = SOAP_TYPE_ns1__listExecutions;
			return soap_in_ns1__listExecutions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listPipelinesResponse"))
		{	*type = SOAP_TYPE_ns1__listPipelinesResponse;
			return soap_in_ns1__listPipelinesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:listPipelines"))
		{	*type = SOAP_TYPE_ns1__listPipelines;
			return soap_in_ns1__listPipelines(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:playExecutionResponse"))
		{	*type = SOAP_TYPE_ns1__playExecutionResponse;
			return soap_in_ns1__playExecutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:playExecution"))
		{	*type = SOAP_TYPE_ns1__playExecution;
			return soap_in_ns1__playExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getExecutionResponse"))
		{	*type = SOAP_TYPE_ns1__getExecutionResponse;
			return soap_in_ns1__getExecutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getExecution"))
		{	*type = SOAP_TYPE_ns1__getExecution;
			return soap_in_ns1__getExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:killExecutionResponse"))
		{	*type = SOAP_TYPE_ns1__killExecutionResponse;
			return soap_in_ns1__killExecutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStdErrResponse"))
		{	*type = SOAP_TYPE_ns1__getStdErrResponse;
			return soap_in_ns1__getStdErrResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStdErr"))
		{	*type = SOAP_TYPE_ns1__getStdErr;
			return soap_in_ns1__getStdErr(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStdOutResponse"))
		{	*type = SOAP_TYPE_ns1__getStdOutResponse;
			return soap_in_ns1__getStdOutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStdOut"))
		{	*type = SOAP_TYPE_ns1__getStdOut;
			return soap_in_ns1__getStdOut(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:killExecution"))
		{	*type = SOAP_TYPE_ns1__killExecution;
			return soap_in_ns1__killExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getExecutionResultsResponse"))
		{	*type = SOAP_TYPE_ns1__getExecutionResultsResponse;
			return soap_in_ns1__getExecutionResultsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getExecutionResults"))
		{	*type = SOAP_TYPE_ns1__getExecutionResults;
			return soap_in_ns1__getExecutionResults(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:initExecutionResponse"))
		{	*type = SOAP_TYPE_ns1__initExecutionResponse;
			return soap_in_ns1__initExecutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:initExecution"))
		{	*type = SOAP_TYPE_ns1__initExecution;
			return soap_in_ns1__initExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getGlobalPropertiesResponse"))
		{	*type = SOAP_TYPE_ns1__getGlobalPropertiesResponse;
			return soap_in_ns1__getGlobalPropertiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getGlobalProperties"))
		{	*type = SOAP_TYPE_ns1__getGlobalProperties;
			return soap_in_ns1__getGlobalProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateExecutionResponse"))
		{	*type = SOAP_TYPE_ns1__updateExecutionResponse;
			return soap_in_ns1__updateExecutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StringKeyValuePair"))
		{	*type = SOAP_TYPE_ns1__StringKeyValuePair;
			return soap_in_ns1__StringKeyValuePair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateExecution"))
		{	*type = SOAP_TYPE_ns1__updateExecution;
			return soap_in_ns1__updateExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logoutResponse"))
		{	*type = SOAP_TYPE_ns1__logoutResponse;
			return soap_in_ns1__logoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logout"))
		{	*type = SOAP_TYPE_ns1__logout;
			return soap_in_ns1__logout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateHTTPResponse"))
		{	*type = SOAP_TYPE_ns1__authenticateHTTPResponse;
			return soap_in_ns1__authenticateHTTPResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateHTTP"))
		{	*type = SOAP_TYPE_ns1__authenticateHTTP;
			return soap_in_ns1__authenticateHTTP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPipelineResponse"))
		{	*type = SOAP_TYPE_ns1__getPipelineResponse;
			return soap_in_ns1__getPipelineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPipeline"))
		{	*type = SOAP_TYPE_ns1__getPipeline;
			return soap_in_ns1__getPipeline(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteExecutionResponse"))
		{	*type = SOAP_TYPE_ns1__deleteExecutionResponse;
			return soap_in_ns1__deleteExecutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteExecution"))
		{	*type = SOAP_TYPE_ns1__deleteExecution;
			return soap_in_ns1__deleteExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PipelineKeyBooleanValuePair"))
		{	*type = SOAP_TYPE_ns1__PipelineKeyBooleanValuePair;
			return soap_in_ns1__PipelineKeyBooleanValuePair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GlobalProperties"))
		{	*type = SOAP_TYPE_ns1__GlobalProperties;
			return soap_in_ns1__GlobalProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StringKeyParameterValuePair"))
		{	*type = SOAP_TYPE_ns1__StringKeyParameterValuePair;
			return soap_in_ns1__StringKeyParameterValuePair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Execution"))
		{	*type = SOAP_TYPE_ns1__Execution;
			return soap_in_ns1__Execution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IntKeyStringValuePair"))
		{	*type = SOAP_TYPE_ns1__IntKeyStringValuePair;
			return soap_in_ns1__IntKeyStringValuePair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ParameterTypedValue"))
		{	*type = SOAP_TYPE_ns1__ParameterTypedValue;
			return soap_in_ns1__ParameterTypedValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PipelineParameter"))
		{	*type = SOAP_TYPE_ns1__PipelineParameter;
			return soap_in_ns1__PipelineParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfExecutions"))
		{	*type = SOAP_TYPE_ns1__ArrayOfExecutions;
			return soap_in_ns1__ArrayOfExecutions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPipelines"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPipelines;
			return soap_in_ns1__ArrayOfPipelines(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfStrings"))
		{	*type = SOAP_TYPE_ns1__ArrayOfStrings;
			return soap_in_ns1__ArrayOfStrings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Object"))
		{	*type = SOAP_TYPE_ns1__Object;
			return soap_in_ns1__Object(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Pipeline"))
		{	*type = SOAP_TYPE_ns1__Pipeline;
			return soap_in_ns1__Pipeline(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Response"))
		{	*type = SOAP_TYPE_ns1__Response;
			return soap_in_ns1__Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateSessionResponse"))
		{	*type = SOAP_TYPE_ns1__authenticateSessionResponse;
			return soap_in_ns1__authenticateSessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateSession"))
		{	*type = SOAP_TYPE_ns1__authenticateSession;
			return soap_in_ns1__authenticateSession(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Module"))
		{	*type = SOAP_TYPE_ns1__Module;
			return soap_in_ns1__Module(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecutionStatus"))
		{	*type = SOAP_TYPE_ns1__ExecutionStatus;
			return soap_in_ns1__ExecutionStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ParameterType"))
		{	*type = SOAP_TYPE_ns1__ParameterType;
			return soap_in_ns1__ParameterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__Module:
		return soap_out_ns1__Module(soap, tag, id, (const enum ns1__Module *)ptr, "ns1:Module");
	case SOAP_TYPE_ns1__ExecutionStatus:
		return soap_out_ns1__ExecutionStatus(soap, tag, id, (const enum ns1__ExecutionStatus *)ptr, "ns1:ExecutionStatus");
	case SOAP_TYPE_ns1__ParameterType:
		return soap_out_ns1__ParameterType(soap, tag, id, (const enum ns1__ParameterType *)ptr, "ns1:ParameterType");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__listExecutionsResponse:
		return ((ns1__listExecutionsResponse *)ptr)->soap_out(soap, tag, id, "ns1:listExecutionsResponse");
	case SOAP_TYPE_ns1__listExecutions:
		return ((ns1__listExecutions *)ptr)->soap_out(soap, tag, id, "ns1:listExecutions");
	case SOAP_TYPE_ns1__listPipelinesResponse:
		return ((ns1__listPipelinesResponse *)ptr)->soap_out(soap, tag, id, "ns1:listPipelinesResponse");
	case SOAP_TYPE_ns1__listPipelines:
		return ((ns1__listPipelines *)ptr)->soap_out(soap, tag, id, "ns1:listPipelines");
	case SOAP_TYPE_ns1__playExecutionResponse:
		return ((ns1__playExecutionResponse *)ptr)->soap_out(soap, tag, id, "ns1:playExecutionResponse");
	case SOAP_TYPE_ns1__playExecution:
		return ((ns1__playExecution *)ptr)->soap_out(soap, tag, id, "ns1:playExecution");
	case SOAP_TYPE_ns1__getExecutionResponse:
		return ((ns1__getExecutionResponse *)ptr)->soap_out(soap, tag, id, "ns1:getExecutionResponse");
	case SOAP_TYPE_ns1__getExecution:
		return ((ns1__getExecution *)ptr)->soap_out(soap, tag, id, "ns1:getExecution");
	case SOAP_TYPE_ns1__killExecutionResponse:
		return ((ns1__killExecutionResponse *)ptr)->soap_out(soap, tag, id, "ns1:killExecutionResponse");
	case SOAP_TYPE_ns1__getStdErrResponse:
		return ((ns1__getStdErrResponse *)ptr)->soap_out(soap, tag, id, "ns1:getStdErrResponse");
	case SOAP_TYPE_ns1__getStdErr:
		return ((ns1__getStdErr *)ptr)->soap_out(soap, tag, id, "ns1:getStdErr");
	case SOAP_TYPE_ns1__getStdOutResponse:
		return ((ns1__getStdOutResponse *)ptr)->soap_out(soap, tag, id, "ns1:getStdOutResponse");
	case SOAP_TYPE_ns1__getStdOut:
		return ((ns1__getStdOut *)ptr)->soap_out(soap, tag, id, "ns1:getStdOut");
	case SOAP_TYPE_ns1__killExecution:
		return ((ns1__killExecution *)ptr)->soap_out(soap, tag, id, "ns1:killExecution");
	case SOAP_TYPE_ns1__getExecutionResultsResponse:
		return ((ns1__getExecutionResultsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getExecutionResultsResponse");
	case SOAP_TYPE_ns1__getExecutionResults:
		return ((ns1__getExecutionResults *)ptr)->soap_out(soap, tag, id, "ns1:getExecutionResults");
	case SOAP_TYPE_ns1__initExecutionResponse:
		return ((ns1__initExecutionResponse *)ptr)->soap_out(soap, tag, id, "ns1:initExecutionResponse");
	case SOAP_TYPE_ns1__initExecution:
		return ((ns1__initExecution *)ptr)->soap_out(soap, tag, id, "ns1:initExecution");
	case SOAP_TYPE_ns1__getGlobalPropertiesResponse:
		return ((ns1__getGlobalPropertiesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getGlobalPropertiesResponse");
	case SOAP_TYPE_ns1__getGlobalProperties:
		return ((ns1__getGlobalProperties *)ptr)->soap_out(soap, tag, id, "ns1:getGlobalProperties");
	case SOAP_TYPE_ns1__updateExecutionResponse:
		return ((ns1__updateExecutionResponse *)ptr)->soap_out(soap, tag, id, "ns1:updateExecutionResponse");
	case SOAP_TYPE_ns1__StringKeyValuePair:
		return ((ns1__StringKeyValuePair *)ptr)->soap_out(soap, tag, id, "ns1:StringKeyValuePair");
	case SOAP_TYPE_ns1__updateExecution:
		return ((ns1__updateExecution *)ptr)->soap_out(soap, tag, id, "ns1:updateExecution");
	case SOAP_TYPE_ns1__logoutResponse:
		return ((ns1__logoutResponse *)ptr)->soap_out(soap, tag, id, "ns1:logoutResponse");
	case SOAP_TYPE_ns1__logout:
		return ((ns1__logout *)ptr)->soap_out(soap, tag, id, "ns1:logout");
	case SOAP_TYPE_ns1__authenticateHTTPResponse:
		return ((ns1__authenticateHTTPResponse *)ptr)->soap_out(soap, tag, id, "ns1:authenticateHTTPResponse");
	case SOAP_TYPE_ns1__authenticateHTTP:
		return ((ns1__authenticateHTTP *)ptr)->soap_out(soap, tag, id, "ns1:authenticateHTTP");
	case SOAP_TYPE_ns1__getPipelineResponse:
		return ((ns1__getPipelineResponse *)ptr)->soap_out(soap, tag, id, "ns1:getPipelineResponse");
	case SOAP_TYPE_ns1__getPipeline:
		return ((ns1__getPipeline *)ptr)->soap_out(soap, tag, id, "ns1:getPipeline");
	case SOAP_TYPE_ns1__deleteExecutionResponse:
		return ((ns1__deleteExecutionResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteExecutionResponse");
	case SOAP_TYPE_ns1__deleteExecution:
		return ((ns1__deleteExecution *)ptr)->soap_out(soap, tag, id, "ns1:deleteExecution");
	case SOAP_TYPE_ns1__PipelineKeyBooleanValuePair:
		return ((ns1__PipelineKeyBooleanValuePair *)ptr)->soap_out(soap, tag, id, "ns1:PipelineKeyBooleanValuePair");
	case SOAP_TYPE_ns1__GlobalProperties:
		return ((ns1__GlobalProperties *)ptr)->soap_out(soap, tag, id, "ns1:GlobalProperties");
	case SOAP_TYPE_ns1__StringKeyParameterValuePair:
		return ((ns1__StringKeyParameterValuePair *)ptr)->soap_out(soap, tag, id, "ns1:StringKeyParameterValuePair");
	case SOAP_TYPE_ns1__Execution:
		return ((ns1__Execution *)ptr)->soap_out(soap, tag, id, "ns1:Execution");
	case SOAP_TYPE_ns1__IntKeyStringValuePair:
		return ((ns1__IntKeyStringValuePair *)ptr)->soap_out(soap, tag, id, "ns1:IntKeyStringValuePair");
	case SOAP_TYPE_ns1__ParameterTypedValue:
		return ((ns1__ParameterTypedValue *)ptr)->soap_out(soap, tag, id, "ns1:ParameterTypedValue");
	case SOAP_TYPE_ns1__PipelineParameter:
		return ((ns1__PipelineParameter *)ptr)->soap_out(soap, tag, id, "ns1:PipelineParameter");
	case SOAP_TYPE_ns1__ArrayOfExecutions:
		return ((ns1__ArrayOfExecutions *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfExecutions");
	case SOAP_TYPE_ns1__ArrayOfPipelines:
		return ((ns1__ArrayOfPipelines *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfPipelines");
	case SOAP_TYPE_ns1__ArrayOfStrings:
		return ((ns1__ArrayOfStrings *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfStrings");
	case SOAP_TYPE_ns1__Object:
		return ((ns1__Object *)ptr)->soap_out(soap, tag, id, "ns1:Object");
	case SOAP_TYPE_ns1__Pipeline:
		return ((ns1__Pipeline *)ptr)->soap_out(soap, tag, id, "ns1:Pipeline");
	case SOAP_TYPE_ns1__Response:
		return ((ns1__Response *)ptr)->soap_out(soap, tag, id, "ns1:Response");
	case SOAP_TYPE_ns1__authenticateSessionResponse:
		return ((ns1__authenticateSessionResponse *)ptr)->soap_out(soap, tag, id, "ns1:authenticateSessionResponse");
	case SOAP_TYPE_ns1__authenticateSession:
		return ((ns1__authenticateSession *)ptr)->soap_out(soap, tag, id, "ns1:authenticateSession");
	case SOAP_TYPE_PointerTons1__listExecutionsResponse:
		return soap_out_PointerTons1__listExecutionsResponse(soap, tag, id, (ns1__listExecutionsResponse *const*)ptr, "ns1:listExecutionsResponse");
	case SOAP_TYPE_PointerTons1__listExecutions:
		return soap_out_PointerTons1__listExecutions(soap, tag, id, (ns1__listExecutions *const*)ptr, "ns1:listExecutions");
	case SOAP_TYPE_PointerTons1__listPipelinesResponse:
		return soap_out_PointerTons1__listPipelinesResponse(soap, tag, id, (ns1__listPipelinesResponse *const*)ptr, "ns1:listPipelinesResponse");
	case SOAP_TYPE_PointerTons1__listPipelines:
		return soap_out_PointerTons1__listPipelines(soap, tag, id, (ns1__listPipelines *const*)ptr, "ns1:listPipelines");
	case SOAP_TYPE_PointerTons1__playExecutionResponse:
		return soap_out_PointerTons1__playExecutionResponse(soap, tag, id, (ns1__playExecutionResponse *const*)ptr, "ns1:playExecutionResponse");
	case SOAP_TYPE_PointerTons1__playExecution:
		return soap_out_PointerTons1__playExecution(soap, tag, id, (ns1__playExecution *const*)ptr, "ns1:playExecution");
	case SOAP_TYPE_PointerTons1__getExecutionResponse:
		return soap_out_PointerTons1__getExecutionResponse(soap, tag, id, (ns1__getExecutionResponse *const*)ptr, "ns1:getExecutionResponse");
	case SOAP_TYPE_PointerTons1__getExecution:
		return soap_out_PointerTons1__getExecution(soap, tag, id, (ns1__getExecution *const*)ptr, "ns1:getExecution");
	case SOAP_TYPE_PointerTons1__killExecutionResponse:
		return soap_out_PointerTons1__killExecutionResponse(soap, tag, id, (ns1__killExecutionResponse *const*)ptr, "ns1:killExecutionResponse");
	case SOAP_TYPE_PointerTons1__killExecution:
		return soap_out_PointerTons1__killExecution(soap, tag, id, (ns1__killExecution *const*)ptr, "ns1:killExecution");
	case SOAP_TYPE_PointerTons1__getExecutionResultsResponse:
		return soap_out_PointerTons1__getExecutionResultsResponse(soap, tag, id, (ns1__getExecutionResultsResponse *const*)ptr, "ns1:getExecutionResultsResponse");
	case SOAP_TYPE_PointerTons1__getExecutionResults:
		return soap_out_PointerTons1__getExecutionResults(soap, tag, id, (ns1__getExecutionResults *const*)ptr, "ns1:getExecutionResults");
	case SOAP_TYPE_PointerTons1__getStdErrResponse:
		return soap_out_PointerTons1__getStdErrResponse(soap, tag, id, (ns1__getStdErrResponse *const*)ptr, "ns1:getStdErrResponse");
	case SOAP_TYPE_PointerTons1__getStdErr:
		return soap_out_PointerTons1__getStdErr(soap, tag, id, (ns1__getStdErr *const*)ptr, "ns1:getStdErr");
	case SOAP_TYPE_PointerTons1__getStdOutResponse:
		return soap_out_PointerTons1__getStdOutResponse(soap, tag, id, (ns1__getStdOutResponse *const*)ptr, "ns1:getStdOutResponse");
	case SOAP_TYPE_PointerTons1__getStdOut:
		return soap_out_PointerTons1__getStdOut(soap, tag, id, (ns1__getStdOut *const*)ptr, "ns1:getStdOut");
	case SOAP_TYPE_PointerTons1__initExecutionResponse:
		return soap_out_PointerTons1__initExecutionResponse(soap, tag, id, (ns1__initExecutionResponse *const*)ptr, "ns1:initExecutionResponse");
	case SOAP_TYPE_PointerTons1__initExecution:
		return soap_out_PointerTons1__initExecution(soap, tag, id, (ns1__initExecution *const*)ptr, "ns1:initExecution");
	case SOAP_TYPE_PointerTons1__getGlobalPropertiesResponse:
		return soap_out_PointerTons1__getGlobalPropertiesResponse(soap, tag, id, (ns1__getGlobalPropertiesResponse *const*)ptr, "ns1:getGlobalPropertiesResponse");
	case SOAP_TYPE_PointerTons1__getGlobalProperties:
		return soap_out_PointerTons1__getGlobalProperties(soap, tag, id, (ns1__getGlobalProperties *const*)ptr, "ns1:getGlobalProperties");
	case SOAP_TYPE_PointerTons1__updateExecutionResponse:
		return soap_out_PointerTons1__updateExecutionResponse(soap, tag, id, (ns1__updateExecutionResponse *const*)ptr, "ns1:updateExecutionResponse");
	case SOAP_TYPE_PointerTons1__updateExecution:
		return soap_out_PointerTons1__updateExecution(soap, tag, id, (ns1__updateExecution *const*)ptr, "ns1:updateExecution");
	case SOAP_TYPE_PointerTons1__logoutResponse:
		return soap_out_PointerTons1__logoutResponse(soap, tag, id, (ns1__logoutResponse *const*)ptr, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTons1__logout:
		return soap_out_PointerTons1__logout(soap, tag, id, (ns1__logout *const*)ptr, "ns1:logout");
	case SOAP_TYPE_PointerTons1__authenticateHTTPResponse:
		return soap_out_PointerTons1__authenticateHTTPResponse(soap, tag, id, (ns1__authenticateHTTPResponse *const*)ptr, "ns1:authenticateHTTPResponse");
	case SOAP_TYPE_PointerTons1__authenticateHTTP:
		return soap_out_PointerTons1__authenticateHTTP(soap, tag, id, (ns1__authenticateHTTP *const*)ptr, "ns1:authenticateHTTP");
	case SOAP_TYPE_PointerTons1__getPipelineResponse:
		return soap_out_PointerTons1__getPipelineResponse(soap, tag, id, (ns1__getPipelineResponse *const*)ptr, "ns1:getPipelineResponse");
	case SOAP_TYPE_PointerTons1__getPipeline:
		return soap_out_PointerTons1__getPipeline(soap, tag, id, (ns1__getPipeline *const*)ptr, "ns1:getPipeline");
	case SOAP_TYPE_PointerTons1__deleteExecutionResponse:
		return soap_out_PointerTons1__deleteExecutionResponse(soap, tag, id, (ns1__deleteExecutionResponse *const*)ptr, "ns1:deleteExecutionResponse");
	case SOAP_TYPE_PointerTons1__deleteExecution:
		return soap_out_PointerTons1__deleteExecution(soap, tag, id, (ns1__deleteExecution *const*)ptr, "ns1:deleteExecution");
	case SOAP_TYPE_PointerTons1__authenticateSessionResponse:
		return soap_out_PointerTons1__authenticateSessionResponse(soap, tag, id, (ns1__authenticateSessionResponse *const*)ptr, "ns1:authenticateSessionResponse");
	case SOAP_TYPE_PointerTons1__authenticateSession:
		return soap_out_PointerTons1__authenticateSession(soap, tag, id, (ns1__authenticateSession *const*)ptr, "ns1:authenticateSession");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerTons1__IntKeyStringValuePair:
		return soap_out_PointerTons1__IntKeyStringValuePair(soap, tag, id, (ns1__IntKeyStringValuePair *const*)ptr, "ns1:IntKeyStringValuePair");
	case SOAP_TYPE_PointerTons1__PipelineParameter:
		return soap_out_PointerTons1__PipelineParameter(soap, tag, id, (ns1__PipelineParameter *const*)ptr, "ns1:PipelineParameter");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons1__StringKeyParameterValuePair:
		return soap_out_PointerTons1__StringKeyParameterValuePair(soap, tag, id, (ns1__StringKeyParameterValuePair *const*)ptr, "ns1:StringKeyParameterValuePair");
	case SOAP_TYPE_PointerTons1__StringKeyValuePair:
		return soap_out_PointerTons1__StringKeyValuePair(soap, tag, id, (ns1__StringKeyValuePair *const*)ptr, "ns1:StringKeyValuePair");
	case SOAP_TYPE_PointerTons1__ParameterTypedValue:
		return soap_out_PointerTons1__ParameterTypedValue(soap, tag, id, (ns1__ParameterTypedValue *const*)ptr, "ns1:ParameterTypedValue");
	case SOAP_TYPE_PointerTons1__PipelineKeyBooleanValuePair:
		return soap_out_PointerTons1__PipelineKeyBooleanValuePair(soap, tag, id, (ns1__PipelineKeyBooleanValuePair *const*)ptr, "ns1:PipelineKeyBooleanValuePair");
	case SOAP_TYPE_PointerTons1__ExecutionStatus:
		return soap_out_PointerTons1__ExecutionStatus(soap, tag, id, (enum ns1__ExecutionStatus *const*)ptr, "ns1:ExecutionStatus");
	case SOAP_TYPE_PointerTons1__ArrayOfPipelines:
		return soap_out_PointerTons1__ArrayOfPipelines(soap, tag, id, (ns1__ArrayOfPipelines *const*)ptr, "ns1:ArrayOfPipelines");
	case SOAP_TYPE_PointerTons1__ArrayOfExecutions:
		return soap_out_PointerTons1__ArrayOfExecutions(soap, tag, id, (ns1__ArrayOfExecutions *const*)ptr, "ns1:ArrayOfExecutions");
	case SOAP_TYPE_PointerTons1__ArrayOfStrings:
		return soap_out_PointerTons1__ArrayOfStrings(soap, tag, id, (ns1__ArrayOfStrings *const*)ptr, "ns1:ArrayOfStrings");
	case SOAP_TYPE_PointerTons1__GlobalProperties:
		return soap_out_PointerTons1__GlobalProperties(soap, tag, id, (ns1__GlobalProperties *const*)ptr, "ns1:GlobalProperties");
	case SOAP_TYPE_PointerTons1__Execution:
		return soap_out_PointerTons1__Execution(soap, tag, id, (ns1__Execution *const*)ptr, "ns1:Execution");
	case SOAP_TYPE_PointerTons1__Pipeline:
		return soap_out_PointerTons1__Pipeline(soap, tag, id, (ns1__Pipeline *const*)ptr, "ns1:Pipeline");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__Response:
		return soap_out_PointerTons1__Response(soap, tag, id, (ns1__Response *const*)ptr, "ns1:Response");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__listExecutionsResponse:
		((ns1__listExecutionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listExecutions:
		((ns1__listExecutions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listPipelinesResponse:
		((ns1__listPipelinesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__listPipelines:
		((ns1__listPipelines *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__playExecutionResponse:
		((ns1__playExecutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__playExecution:
		((ns1__playExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getExecutionResponse:
		((ns1__getExecutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getExecution:
		((ns1__getExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__killExecutionResponse:
		((ns1__killExecutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getStdErrResponse:
		((ns1__getStdErrResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getStdErr:
		((ns1__getStdErr *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getStdOutResponse:
		((ns1__getStdOutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getStdOut:
		((ns1__getStdOut *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__killExecution:
		((ns1__killExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getExecutionResultsResponse:
		((ns1__getExecutionResultsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getExecutionResults:
		((ns1__getExecutionResults *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__initExecutionResponse:
		((ns1__initExecutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__initExecution:
		((ns1__initExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getGlobalPropertiesResponse:
		((ns1__getGlobalPropertiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getGlobalProperties:
		((ns1__getGlobalProperties *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateExecutionResponse:
		((ns1__updateExecutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StringKeyValuePair:
		((ns1__StringKeyValuePair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateExecution:
		((ns1__updateExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__logoutResponse:
		((ns1__logoutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__logout:
		((ns1__logout *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateHTTPResponse:
		((ns1__authenticateHTTPResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateHTTP:
		((ns1__authenticateHTTP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPipelineResponse:
		((ns1__getPipelineResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPipeline:
		((ns1__getPipeline *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteExecutionResponse:
		((ns1__deleteExecutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteExecution:
		((ns1__deleteExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PipelineKeyBooleanValuePair:
		((ns1__PipelineKeyBooleanValuePair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GlobalProperties:
		((ns1__GlobalProperties *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StringKeyParameterValuePair:
		((ns1__StringKeyParameterValuePair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Execution:
		((ns1__Execution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__IntKeyStringValuePair:
		((ns1__IntKeyStringValuePair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ParameterTypedValue:
		((ns1__ParameterTypedValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PipelineParameter:
		((ns1__PipelineParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfExecutions:
		((ns1__ArrayOfExecutions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfPipelines:
		((ns1__ArrayOfPipelines *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfStrings:
		((ns1__ArrayOfStrings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Object:
		((ns1__Object *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Pipeline:
		((ns1__Pipeline *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Response:
		((ns1__Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateSessionResponse:
		((ns1__authenticateSessionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateSession:
		((ns1__authenticateSession *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__listExecutions:
		soap_serialize___ns1__listExecutions(soap, (const struct __ns1__listExecutions *)ptr);
		break;
	case SOAP_TYPE___ns1__listPipelines:
		soap_serialize___ns1__listPipelines(soap, (const struct __ns1__listPipelines *)ptr);
		break;
	case SOAP_TYPE___ns1__playExecution:
		soap_serialize___ns1__playExecution(soap, (const struct __ns1__playExecution *)ptr);
		break;
	case SOAP_TYPE___ns1__getExecution:
		soap_serialize___ns1__getExecution(soap, (const struct __ns1__getExecution *)ptr);
		break;
	case SOAP_TYPE___ns1__killExecution:
		soap_serialize___ns1__killExecution(soap, (const struct __ns1__killExecution *)ptr);
		break;
	case SOAP_TYPE___ns1__getExecutionResults:
		soap_serialize___ns1__getExecutionResults(soap, (const struct __ns1__getExecutionResults *)ptr);
		break;
	case SOAP_TYPE___ns1__getStdErr:
		soap_serialize___ns1__getStdErr(soap, (const struct __ns1__getStdErr *)ptr);
		break;
	case SOAP_TYPE___ns1__getStdOut:
		soap_serialize___ns1__getStdOut(soap, (const struct __ns1__getStdOut *)ptr);
		break;
	case SOAP_TYPE___ns1__initExecution:
		soap_serialize___ns1__initExecution(soap, (const struct __ns1__initExecution *)ptr);
		break;
	case SOAP_TYPE___ns1__getGlobalProperties:
		soap_serialize___ns1__getGlobalProperties(soap, (const struct __ns1__getGlobalProperties *)ptr);
		break;
	case SOAP_TYPE___ns1__updateExecution:
		soap_serialize___ns1__updateExecution(soap, (const struct __ns1__updateExecution *)ptr);
		break;
	case SOAP_TYPE___ns1__logout:
		soap_serialize___ns1__logout(soap, (const struct __ns1__logout *)ptr);
		break;
	case SOAP_TYPE___ns1__authenticateHTTP:
		soap_serialize___ns1__authenticateHTTP(soap, (const struct __ns1__authenticateHTTP *)ptr);
		break;
	case SOAP_TYPE___ns1__getPipeline:
		soap_serialize___ns1__getPipeline(soap, (const struct __ns1__getPipeline *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteExecution:
		soap_serialize___ns1__deleteExecution(soap, (const struct __ns1__deleteExecution *)ptr);
		break;
	case SOAP_TYPE___ns1__authenticateSession:
		soap_serialize___ns1__authenticateSession(soap, (const struct __ns1__authenticateSession *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listExecutionsResponse:
		soap_serialize_PointerTons1__listExecutionsResponse(soap, (ns1__listExecutionsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listExecutions:
		soap_serialize_PointerTons1__listExecutions(soap, (ns1__listExecutions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listPipelinesResponse:
		soap_serialize_PointerTons1__listPipelinesResponse(soap, (ns1__listPipelinesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__listPipelines:
		soap_serialize_PointerTons1__listPipelines(soap, (ns1__listPipelines *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__playExecutionResponse:
		soap_serialize_PointerTons1__playExecutionResponse(soap, (ns1__playExecutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__playExecution:
		soap_serialize_PointerTons1__playExecution(soap, (ns1__playExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getExecutionResponse:
		soap_serialize_PointerTons1__getExecutionResponse(soap, (ns1__getExecutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getExecution:
		soap_serialize_PointerTons1__getExecution(soap, (ns1__getExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__killExecutionResponse:
		soap_serialize_PointerTons1__killExecutionResponse(soap, (ns1__killExecutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__killExecution:
		soap_serialize_PointerTons1__killExecution(soap, (ns1__killExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getExecutionResultsResponse:
		soap_serialize_PointerTons1__getExecutionResultsResponse(soap, (ns1__getExecutionResultsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getExecutionResults:
		soap_serialize_PointerTons1__getExecutionResults(soap, (ns1__getExecutionResults *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getStdErrResponse:
		soap_serialize_PointerTons1__getStdErrResponse(soap, (ns1__getStdErrResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getStdErr:
		soap_serialize_PointerTons1__getStdErr(soap, (ns1__getStdErr *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getStdOutResponse:
		soap_serialize_PointerTons1__getStdOutResponse(soap, (ns1__getStdOutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getStdOut:
		soap_serialize_PointerTons1__getStdOut(soap, (ns1__getStdOut *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__initExecutionResponse:
		soap_serialize_PointerTons1__initExecutionResponse(soap, (ns1__initExecutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__initExecution:
		soap_serialize_PointerTons1__initExecution(soap, (ns1__initExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getGlobalPropertiesResponse:
		soap_serialize_PointerTons1__getGlobalPropertiesResponse(soap, (ns1__getGlobalPropertiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getGlobalProperties:
		soap_serialize_PointerTons1__getGlobalProperties(soap, (ns1__getGlobalProperties *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateExecutionResponse:
		soap_serialize_PointerTons1__updateExecutionResponse(soap, (ns1__updateExecutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateExecution:
		soap_serialize_PointerTons1__updateExecution(soap, (ns1__updateExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__logoutResponse:
		soap_serialize_PointerTons1__logoutResponse(soap, (ns1__logoutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__logout:
		soap_serialize_PointerTons1__logout(soap, (ns1__logout *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateHTTPResponse:
		soap_serialize_PointerTons1__authenticateHTTPResponse(soap, (ns1__authenticateHTTPResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateHTTP:
		soap_serialize_PointerTons1__authenticateHTTP(soap, (ns1__authenticateHTTP *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPipelineResponse:
		soap_serialize_PointerTons1__getPipelineResponse(soap, (ns1__getPipelineResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPipeline:
		soap_serialize_PointerTons1__getPipeline(soap, (ns1__getPipeline *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteExecutionResponse:
		soap_serialize_PointerTons1__deleteExecutionResponse(soap, (ns1__deleteExecutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteExecution:
		soap_serialize_PointerTons1__deleteExecution(soap, (ns1__deleteExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateSessionResponse:
		soap_serialize_PointerTons1__authenticateSessionResponse(soap, (ns1__authenticateSessionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateSession:
		soap_serialize_PointerTons1__authenticateSession(soap, (ns1__authenticateSession *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__IntKeyStringValuePair:
		soap_serialize_PointerTons1__IntKeyStringValuePair(soap, (ns1__IntKeyStringValuePair *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PipelineParameter:
		soap_serialize_PointerTons1__PipelineParameter(soap, (ns1__PipelineParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StringKeyParameterValuePair:
		soap_serialize_PointerTons1__StringKeyParameterValuePair(soap, (ns1__StringKeyParameterValuePair *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StringKeyValuePair:
		soap_serialize_PointerTons1__StringKeyValuePair(soap, (ns1__StringKeyValuePair *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ParameterTypedValue:
		soap_serialize_PointerTons1__ParameterTypedValue(soap, (ns1__ParameterTypedValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PipelineKeyBooleanValuePair:
		soap_serialize_PointerTons1__PipelineKeyBooleanValuePair(soap, (ns1__PipelineKeyBooleanValuePair *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ExecutionStatus:
		soap_serialize_PointerTons1__ExecutionStatus(soap, (enum ns1__ExecutionStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPipelines:
		soap_serialize_PointerTons1__ArrayOfPipelines(soap, (ns1__ArrayOfPipelines *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfExecutions:
		soap_serialize_PointerTons1__ArrayOfExecutions(soap, (ns1__ArrayOfExecutions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfStrings:
		soap_serialize_PointerTons1__ArrayOfStrings(soap, (ns1__ArrayOfStrings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GlobalProperties:
		soap_serialize_PointerTons1__GlobalProperties(soap, (ns1__GlobalProperties *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Execution:
		soap_serialize_PointerTons1__Execution(soap, (ns1__Execution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Pipeline:
		soap_serialize_PointerTons1__Pipeline(soap, (ns1__Pipeline *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Response:
		soap_serialize_PointerTons1__Response(soap, (ns1__Response *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateSession:
		return (void*)soap_instantiate_ns1__authenticateSession(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateSessionResponse:
		return (void*)soap_instantiate_ns1__authenticateSessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Response:
		return (void*)soap_instantiate_ns1__Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Object:
		return (void*)soap_instantiate_ns1__Object(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfStrings:
		return (void*)soap_instantiate_ns1__ArrayOfStrings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfPipelines:
		return (void*)soap_instantiate_ns1__ArrayOfPipelines(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfExecutions:
		return (void*)soap_instantiate_ns1__ArrayOfExecutions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PipelineParameter:
		return (void*)soap_instantiate_ns1__PipelineParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ParameterTypedValue:
		return (void*)soap_instantiate_ns1__ParameterTypedValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__IntKeyStringValuePair:
		return (void*)soap_instantiate_ns1__IntKeyStringValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StringKeyParameterValuePair:
		return (void*)soap_instantiate_ns1__StringKeyParameterValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PipelineKeyBooleanValuePair:
		return (void*)soap_instantiate_ns1__PipelineKeyBooleanValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteExecution:
		return (void*)soap_instantiate_ns1__deleteExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteExecutionResponse:
		return (void*)soap_instantiate_ns1__deleteExecutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPipeline:
		return (void*)soap_instantiate_ns1__getPipeline(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPipelineResponse:
		return (void*)soap_instantiate_ns1__getPipelineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateHTTP:
		return (void*)soap_instantiate_ns1__authenticateHTTP(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateHTTPResponse:
		return (void*)soap_instantiate_ns1__authenticateHTTPResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__logout:
		return (void*)soap_instantiate_ns1__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__logoutResponse:
		return (void*)soap_instantiate_ns1__logoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateExecution:
		return (void*)soap_instantiate_ns1__updateExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StringKeyValuePair:
		return (void*)soap_instantiate_ns1__StringKeyValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateExecutionResponse:
		return (void*)soap_instantiate_ns1__updateExecutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getGlobalProperties:
		return (void*)soap_instantiate_ns1__getGlobalProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getGlobalPropertiesResponse:
		return (void*)soap_instantiate_ns1__getGlobalPropertiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__initExecution:
		return (void*)soap_instantiate_ns1__initExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__initExecutionResponse:
		return (void*)soap_instantiate_ns1__initExecutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getExecutionResults:
		return (void*)soap_instantiate_ns1__getExecutionResults(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getExecutionResultsResponse:
		return (void*)soap_instantiate_ns1__getExecutionResultsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__killExecution:
		return (void*)soap_instantiate_ns1__killExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStdOut:
		return (void*)soap_instantiate_ns1__getStdOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStdOutResponse:
		return (void*)soap_instantiate_ns1__getStdOutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStdErr:
		return (void*)soap_instantiate_ns1__getStdErr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStdErrResponse:
		return (void*)soap_instantiate_ns1__getStdErrResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__killExecutionResponse:
		return (void*)soap_instantiate_ns1__killExecutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getExecution:
		return (void*)soap_instantiate_ns1__getExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getExecutionResponse:
		return (void*)soap_instantiate_ns1__getExecutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__playExecution:
		return (void*)soap_instantiate_ns1__playExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__playExecutionResponse:
		return (void*)soap_instantiate_ns1__playExecutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listPipelines:
		return (void*)soap_instantiate_ns1__listPipelines(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listPipelinesResponse:
		return (void*)soap_instantiate_ns1__listPipelinesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listExecutions:
		return (void*)soap_instantiate_ns1__listExecutions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__listExecutionsResponse:
		return (void*)soap_instantiate_ns1__listExecutionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Pipeline:
		return (void*)soap_instantiate_ns1__Pipeline(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Execution:
		return (void*)soap_instantiate_ns1__Execution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GlobalProperties:
		return (void*)soap_instantiate_ns1__GlobalProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__authenticateSession:
		return (void*)soap_instantiate___ns1__authenticateSession(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteExecution:
		return (void*)soap_instantiate___ns1__deleteExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPipeline:
		return (void*)soap_instantiate___ns1__getPipeline(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__authenticateHTTP:
		return (void*)soap_instantiate___ns1__authenticateHTTP(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__logout:
		return (void*)soap_instantiate___ns1__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateExecution:
		return (void*)soap_instantiate___ns1__updateExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getGlobalProperties:
		return (void*)soap_instantiate___ns1__getGlobalProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__initExecution:
		return (void*)soap_instantiate___ns1__initExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getStdOut:
		return (void*)soap_instantiate___ns1__getStdOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getStdErr:
		return (void*)soap_instantiate___ns1__getStdErr(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getExecutionResults:
		return (void*)soap_instantiate___ns1__getExecutionResults(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__killExecution:
		return (void*)soap_instantiate___ns1__killExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getExecution:
		return (void*)soap_instantiate___ns1__getExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__playExecution:
		return (void*)soap_instantiate___ns1__playExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__listPipelines:
		return (void*)soap_instantiate___ns1__listPipelines(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__listExecutions:
		return (void*)soap_instantiate___ns1__listExecutions(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfns1__Module:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__Module(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PipelineParameter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__PipelineParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringKeyValuePair:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__StringKeyValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Execution:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Execution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfPipelines:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ArrayOfPipelines(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfExecutions:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ArrayOfExecutions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfStrings:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ArrayOfStrings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Pipeline:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Pipeline(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateSession:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateSession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateSession*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateSessionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateSessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateSessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Response:
		if (p->size < 0)
			SOAP_DELETE((ns1__Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Response*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Object:
		if (p->size < 0)
			SOAP_DELETE((ns1__Object*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Object*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfStrings:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfStrings*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfStrings*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPipelines:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfPipelines*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfPipelines*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfExecutions:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfExecutions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfExecutions*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PipelineParameter:
		if (p->size < 0)
			SOAP_DELETE((ns1__PipelineParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PipelineParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ParameterTypedValue:
		if (p->size < 0)
			SOAP_DELETE((ns1__ParameterTypedValue*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ParameterTypedValue*)p->ptr);
		break;
	case SOAP_TYPE_ns1__IntKeyStringValuePair:
		if (p->size < 0)
			SOAP_DELETE((ns1__IntKeyStringValuePair*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__IntKeyStringValuePair*)p->ptr);
		break;
	case SOAP_TYPE_ns1__StringKeyParameterValuePair:
		if (p->size < 0)
			SOAP_DELETE((ns1__StringKeyParameterValuePair*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__StringKeyParameterValuePair*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PipelineKeyBooleanValuePair:
		if (p->size < 0)
			SOAP_DELETE((ns1__PipelineKeyBooleanValuePair*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PipelineKeyBooleanValuePair*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteExecution:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteExecution*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteExecutionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__deleteExecutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__deleteExecutionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getPipeline:
		if (p->size < 0)
			SOAP_DELETE((ns1__getPipeline*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getPipeline*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getPipelineResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getPipelineResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getPipelineResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateHTTP:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateHTTP*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateHTTP*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateHTTPResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateHTTPResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateHTTPResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__logout:
		if (p->size < 0)
			SOAP_DELETE((ns1__logout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__logout*)p->ptr);
		break;
	case SOAP_TYPE_ns1__logoutResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__logoutResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__logoutResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__updateExecution:
		if (p->size < 0)
			SOAP_DELETE((ns1__updateExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__updateExecution*)p->ptr);
		break;
	case SOAP_TYPE_ns1__StringKeyValuePair:
		if (p->size < 0)
			SOAP_DELETE((ns1__StringKeyValuePair*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__StringKeyValuePair*)p->ptr);
		break;
	case SOAP_TYPE_ns1__updateExecutionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__updateExecutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__updateExecutionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getGlobalProperties:
		if (p->size < 0)
			SOAP_DELETE((ns1__getGlobalProperties*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getGlobalProperties*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getGlobalPropertiesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getGlobalPropertiesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getGlobalPropertiesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__initExecution:
		if (p->size < 0)
			SOAP_DELETE((ns1__initExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__initExecution*)p->ptr);
		break;
	case SOAP_TYPE_ns1__initExecutionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__initExecutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__initExecutionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getExecutionResults:
		if (p->size < 0)
			SOAP_DELETE((ns1__getExecutionResults*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getExecutionResults*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getExecutionResultsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getExecutionResultsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getExecutionResultsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__killExecution:
		if (p->size < 0)
			SOAP_DELETE((ns1__killExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__killExecution*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getStdOut:
		if (p->size < 0)
			SOAP_DELETE((ns1__getStdOut*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getStdOut*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getStdOutResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getStdOutResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getStdOutResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getStdErr:
		if (p->size < 0)
			SOAP_DELETE((ns1__getStdErr*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getStdErr*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getStdErrResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getStdErrResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getStdErrResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__killExecutionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__killExecutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__killExecutionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getExecution:
		if (p->size < 0)
			SOAP_DELETE((ns1__getExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getExecution*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getExecutionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getExecutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getExecutionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__playExecution:
		if (p->size < 0)
			SOAP_DELETE((ns1__playExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__playExecution*)p->ptr);
		break;
	case SOAP_TYPE_ns1__playExecutionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__playExecutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__playExecutionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listPipelines:
		if (p->size < 0)
			SOAP_DELETE((ns1__listPipelines*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listPipelines*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listPipelinesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__listPipelinesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listPipelinesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listExecutions:
		if (p->size < 0)
			SOAP_DELETE((ns1__listExecutions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listExecutions*)p->ptr);
		break;
	case SOAP_TYPE_ns1__listExecutionsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__listExecutionsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__listExecutionsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Pipeline:
		if (p->size < 0)
			SOAP_DELETE((ns1__Pipeline*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Pipeline*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Execution:
		if (p->size < 0)
			SOAP_DELETE((ns1__Execution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Execution*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GlobalProperties:
		if (p->size < 0)
			SOAP_DELETE((ns1__GlobalProperties*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__GlobalProperties*)p->ptr);
		break;
	case SOAP_TYPE___ns1__authenticateSession:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__authenticateSession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__authenticateSession*)p->ptr);
		break;
	case SOAP_TYPE___ns1__deleteExecution:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__deleteExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__deleteExecution*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getPipeline:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getPipeline*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getPipeline*)p->ptr);
		break;
	case SOAP_TYPE___ns1__authenticateHTTP:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__authenticateHTTP*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__authenticateHTTP*)p->ptr);
		break;
	case SOAP_TYPE___ns1__logout:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__logout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__logout*)p->ptr);
		break;
	case SOAP_TYPE___ns1__updateExecution:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__updateExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__updateExecution*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getGlobalProperties:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getGlobalProperties*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getGlobalProperties*)p->ptr);
		break;
	case SOAP_TYPE___ns1__initExecution:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__initExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__initExecution*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getStdOut:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getStdOut*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getStdOut*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getStdErr:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getStdErr*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getStdErr*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getExecutionResults:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getExecutionResults*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getExecutionResults*)p->ptr);
		break;
	case SOAP_TYPE___ns1__killExecution:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__killExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__killExecution*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getExecution:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getExecution*)p->ptr);
		break;
	case SOAP_TYPE___ns1__playExecution:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__playExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__playExecution*)p->ptr);
		break;
	case SOAP_TYPE___ns1__listPipelines:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__listPipelines*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__listPipelines*)p->ptr);
		break;
	case SOAP_TYPE___ns1__listExecutions:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__listExecutions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__listExecutions*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__Module:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum ns1__Module >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum ns1__Module >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__IntKeyStringValuePair * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__IntKeyStringValuePair * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PipelineParameter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__PipelineParameter * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__PipelineParameter * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__StringKeyParameterValuePair * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__StringKeyParameterValuePair * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringKeyValuePair:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__StringKeyValuePair * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__StringKeyValuePair * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Execution:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__Execution * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__Execution * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__PipelineKeyBooleanValuePair * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__PipelineKeyBooleanValuePair * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfPipelines:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__ArrayOfPipelines * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__ArrayOfPipelines * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfExecutions:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__ArrayOfExecutions * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__ArrayOfExecutions * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfStrings:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__ArrayOfStrings * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__ArrayOfStrings * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Pipeline:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__Pipeline * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__Pipeline * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfns1__Module:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum ns1__Module >*)p)[len] = *(enum ns1__Module *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__IntKeyStringValuePair * >*)p)[len] = *(ns1__IntKeyStringValuePair **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PipelineParameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__PipelineParameter * >*)p)[len] = *(ns1__PipelineParameter **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__StringKeyParameterValuePair * >*)p)[len] = *(ns1__StringKeyParameterValuePair **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringKeyValuePair:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__StringKeyValuePair * >*)p)[len] = *(ns1__StringKeyValuePair **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Execution:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__Execution * >*)p)[len] = *(ns1__Execution **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__PipelineKeyBooleanValuePair * >*)p)[len] = *(ns1__PipelineKeyBooleanValuePair **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfPipelines:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__ArrayOfPipelines * >*)p)[len] = *(ns1__ArrayOfPipelines **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfExecutions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__ArrayOfExecutions * >*)p)[len] = *(ns1__ArrayOfExecutions **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfStrings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__ArrayOfStrings * >*)p)[len] = *(ns1__ArrayOfStrings **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Pipeline:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__Pipeline * >*)p)[len] = *(ns1__Pipeline **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Module(struct soap *soap, enum ns1__Module *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__Module
	*a = SOAP_DEFAULT_ns1__Module;
#else
	*a = (enum ns1__Module)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__Module[] =
{	{ (long)ns1__Module__Processing, "Processing" },
	{ (long)ns1__Module__Data, "Data" },
	{ (long)ns1__Module__Management, "Management" },
	{ (long)ns1__Module__Commercial, "Commercial" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Module2s(struct soap *soap, enum ns1__Module n)
{	const char *s = soap_code_str(soap_codes_ns1__Module, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Module(struct soap *soap, const char *tag, int id, const enum ns1__Module *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Module), type) || soap_send(soap, soap_ns1__Module2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Module(struct soap *soap, const char *s, enum ns1__Module *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Module, s);
	if (map)
		*a = (enum ns1__Module)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Module)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Module * SOAP_FMAC4 soap_in_ns1__Module(struct soap *soap, const char *tag, enum ns1__Module *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Module *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Module, sizeof(enum ns1__Module), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__Module(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__Module *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Module, 0, sizeof(enum ns1__Module), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Module(struct soap *soap, const enum ns1__Module *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Module);
	if (soap_out_ns1__Module(soap, tag?tag:"ns1:Module", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Module * SOAP_FMAC4 soap_get_ns1__Module(struct soap *soap, enum ns1__Module *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Module(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ExecutionStatus(struct soap *soap, enum ns1__ExecutionStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__ExecutionStatus
	*a = SOAP_DEFAULT_ns1__ExecutionStatus;
#else
	*a = (enum ns1__ExecutionStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__ExecutionStatus[] =
{	{ (long)ns1__ExecutionStatus__Initializing, "Initializing" },
	{ (long)ns1__ExecutionStatus__Ready, "Ready" },
	{ (long)ns1__ExecutionStatus__Running, "Running" },
	{ (long)ns1__ExecutionStatus__Finished, "Finished" },
	{ (long)ns1__ExecutionStatus__InitializationFailed, "InitializationFailed" },
	{ (long)ns1__ExecutionStatus__ExecutionFailed, "ExecutionFailed" },
	{ (long)ns1__ExecutionStatus__Unknown, "Unknown" },
	{ (long)ns1__ExecutionStatus__Killed, "Killed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ExecutionStatus2s(struct soap *soap, enum ns1__ExecutionStatus n)
{	const char *s = soap_code_str(soap_codes_ns1__ExecutionStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExecutionStatus(struct soap *soap, const char *tag, int id, const enum ns1__ExecutionStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ExecutionStatus), type) || soap_send(soap, soap_ns1__ExecutionStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ExecutionStatus(struct soap *soap, const char *s, enum ns1__ExecutionStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__ExecutionStatus, s);
	if (map)
		*a = (enum ns1__ExecutionStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ExecutionStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ExecutionStatus * SOAP_FMAC4 soap_in_ns1__ExecutionStatus(struct soap *soap, const char *tag, enum ns1__ExecutionStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ExecutionStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ExecutionStatus, sizeof(enum ns1__ExecutionStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__ExecutionStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ExecutionStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ExecutionStatus, 0, sizeof(enum ns1__ExecutionStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExecutionStatus(struct soap *soap, const enum ns1__ExecutionStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ExecutionStatus);
	if (soap_out_ns1__ExecutionStatus(soap, tag?tag:"ns1:ExecutionStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ExecutionStatus * SOAP_FMAC4 soap_get_ns1__ExecutionStatus(struct soap *soap, enum ns1__ExecutionStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExecutionStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ParameterType(struct soap *soap, enum ns1__ParameterType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__ParameterType
	*a = SOAP_DEFAULT_ns1__ParameterType;
#else
	*a = (enum ns1__ParameterType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__ParameterType[] =
{	{ (long)ns1__ParameterType__File, "File" },
	{ (long)ns1__ParameterType__String, "String" },
	{ (long)ns1__ParameterType__Boolean, "Boolean" },
	{ (long)ns1__ParameterType__Int64, "Int64" },
	{ (long)ns1__ParameterType__Double, "Double" },
	{ (long)ns1__ParameterType__List, "List" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ParameterType2s(struct soap *soap, enum ns1__ParameterType n)
{	const char *s = soap_code_str(soap_codes_ns1__ParameterType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ParameterType(struct soap *soap, const char *tag, int id, const enum ns1__ParameterType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ParameterType), type) || soap_send(soap, soap_ns1__ParameterType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ParameterType(struct soap *soap, const char *s, enum ns1__ParameterType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__ParameterType, s);
	if (map)
		*a = (enum ns1__ParameterType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ParameterType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ParameterType * SOAP_FMAC4 soap_in_ns1__ParameterType(struct soap *soap, const char *tag, enum ns1__ParameterType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ParameterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ParameterType, sizeof(enum ns1__ParameterType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__ParameterType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ParameterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ParameterType, 0, sizeof(enum ns1__ParameterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ParameterType(struct soap *soap, const enum ns1__ParameterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ParameterType);
	if (soap_out_ns1__ParameterType(soap, tag?tag:"ns1:ParameterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ParameterType * SOAP_FMAC4 soap_get_ns1__ParameterType(struct soap *soap, enum ns1__ParameterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ParameterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void ns1__listExecutionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__listExecutionsResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__listExecutionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__listExecutionsResponse::return_);
	/* transient soap skipped */
}

int ns1__listExecutionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listExecutionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listExecutionsResponse(struct soap *soap, const char *tag, int id, const ns1__listExecutionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listExecutionsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__listExecutionsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__listExecutionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listExecutionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listExecutionsResponse * SOAP_FMAC4 soap_in_ns1__listExecutionsResponse(struct soap *soap, const char *tag, ns1__listExecutionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listExecutionsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listExecutionsResponse, sizeof(ns1__listExecutionsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listExecutionsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listExecutionsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__listExecutionsResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listExecutionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listExecutionsResponse, 0, sizeof(ns1__listExecutionsResponse), 0, soap_copy_ns1__listExecutionsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__listExecutionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listExecutionsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:listExecutionsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listExecutionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listExecutionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listExecutionsResponse * SOAP_FMAC4 soap_get_ns1__listExecutionsResponse(struct soap *soap, ns1__listExecutionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listExecutionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listExecutionsResponse * SOAP_FMAC2 soap_instantiate_ns1__listExecutionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listExecutionsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listExecutionsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listExecutionsResponse);
		if (size)
			*size = sizeof(ns1__listExecutionsResponse);
		((ns1__listExecutionsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listExecutionsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listExecutionsResponse);
		for (int i = 0; i < n; i++)
			((ns1__listExecutionsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listExecutionsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listExecutionsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listExecutionsResponse %p -> %p\n", q, p));
	*(ns1__listExecutionsResponse*)p = *(ns1__listExecutionsResponse*)q;
}

void ns1__listExecutions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__listExecutions::studyIdentifier);
	/* transient soap skipped */
}

void ns1__listExecutions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__listExecutions::studyIdentifier, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__listExecutions::studyIdentifier);
	/* transient soap skipped */
}

int ns1__listExecutions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listExecutions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listExecutions(struct soap *soap, const char *tag, int id, const ns1__listExecutions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listExecutions), type))
		return soap->error;
	if (soap_out_std__string(soap, "studyIdentifier", -1, &(a->ns1__listExecutions::studyIdentifier), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__listExecutions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listExecutions(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listExecutions * SOAP_FMAC4 soap_in_ns1__listExecutions(struct soap *soap, const char *tag, ns1__listExecutions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listExecutions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listExecutions, sizeof(ns1__listExecutions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listExecutions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listExecutions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_studyIdentifier1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_studyIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "studyIdentifier", &(a->ns1__listExecutions::studyIdentifier), "xsd:string"))
				{	soap_flag_studyIdentifier1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listExecutions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listExecutions, 0, sizeof(ns1__listExecutions), 0, soap_copy_ns1__listExecutions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_studyIdentifier1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__listExecutions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listExecutions);
	if (this->soap_out(soap, tag?tag:"ns1:listExecutions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listExecutions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listExecutions(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listExecutions * SOAP_FMAC4 soap_get_ns1__listExecutions(struct soap *soap, ns1__listExecutions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listExecutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listExecutions * SOAP_FMAC2 soap_instantiate_ns1__listExecutions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listExecutions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listExecutions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listExecutions);
		if (size)
			*size = sizeof(ns1__listExecutions);
		((ns1__listExecutions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listExecutions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listExecutions);
		for (int i = 0; i < n; i++)
			((ns1__listExecutions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listExecutions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listExecutions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listExecutions %p -> %p\n", q, p));
	*(ns1__listExecutions*)p = *(ns1__listExecutions*)q;
}

void ns1__listPipelinesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__listPipelinesResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__listPipelinesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__listPipelinesResponse::return_);
	/* transient soap skipped */
}

int ns1__listPipelinesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listPipelinesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listPipelinesResponse(struct soap *soap, const char *tag, int id, const ns1__listPipelinesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listPipelinesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__listPipelinesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__listPipelinesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listPipelinesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listPipelinesResponse * SOAP_FMAC4 soap_in_ns1__listPipelinesResponse(struct soap *soap, const char *tag, ns1__listPipelinesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listPipelinesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listPipelinesResponse, sizeof(ns1__listPipelinesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listPipelinesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listPipelinesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__listPipelinesResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listPipelinesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listPipelinesResponse, 0, sizeof(ns1__listPipelinesResponse), 0, soap_copy_ns1__listPipelinesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__listPipelinesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listPipelinesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:listPipelinesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listPipelinesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listPipelinesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listPipelinesResponse * SOAP_FMAC4 soap_get_ns1__listPipelinesResponse(struct soap *soap, ns1__listPipelinesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listPipelinesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listPipelinesResponse * SOAP_FMAC2 soap_instantiate_ns1__listPipelinesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listPipelinesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listPipelinesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listPipelinesResponse);
		if (size)
			*size = sizeof(ns1__listPipelinesResponse);
		((ns1__listPipelinesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listPipelinesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listPipelinesResponse);
		for (int i = 0; i < n; i++)
			((ns1__listPipelinesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listPipelinesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listPipelinesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listPipelinesResponse %p -> %p\n", q, p));
	*(ns1__listPipelinesResponse*)p = *(ns1__listPipelinesResponse*)q;
}

void ns1__listPipelines::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__listPipelines::studyIdentifier);
	/* transient soap skipped */
}

void ns1__listPipelines::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__listPipelines::studyIdentifier, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__listPipelines::studyIdentifier);
	/* transient soap skipped */
}

int ns1__listPipelines::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__listPipelines(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__listPipelines(struct soap *soap, const char *tag, int id, const ns1__listPipelines *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__listPipelines), type))
		return soap->error;
	if (soap_out_std__string(soap, "studyIdentifier", -1, &(a->ns1__listPipelines::studyIdentifier), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__listPipelines::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__listPipelines(soap, tag, this, type);
}

SOAP_FMAC3 ns1__listPipelines * SOAP_FMAC4 soap_in_ns1__listPipelines(struct soap *soap, const char *tag, ns1__listPipelines *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__listPipelines *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__listPipelines, sizeof(ns1__listPipelines), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__listPipelines)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__listPipelines *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_studyIdentifier1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_studyIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "studyIdentifier", &(a->ns1__listPipelines::studyIdentifier), "xsd:string"))
				{	soap_flag_studyIdentifier1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__listPipelines *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__listPipelines, 0, sizeof(ns1__listPipelines), 0, soap_copy_ns1__listPipelines);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_studyIdentifier1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__listPipelines::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__listPipelines);
	if (this->soap_out(soap, tag?tag:"ns1:listPipelines", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__listPipelines::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__listPipelines(soap, this, tag, type);
}

SOAP_FMAC3 ns1__listPipelines * SOAP_FMAC4 soap_get_ns1__listPipelines(struct soap *soap, ns1__listPipelines *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__listPipelines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__listPipelines * SOAP_FMAC2 soap_instantiate_ns1__listPipelines(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__listPipelines(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__listPipelines, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__listPipelines);
		if (size)
			*size = sizeof(ns1__listPipelines);
		((ns1__listPipelines*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__listPipelines[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__listPipelines);
		for (int i = 0; i < n; i++)
			((ns1__listPipelines*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__listPipelines*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__listPipelines(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__listPipelines %p -> %p\n", q, p));
	*(ns1__listPipelines*)p = *(ns1__listPipelines*)q;
}

void ns1__playExecutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__playExecutionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__playExecutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__playExecutionResponse::return_);
	/* transient soap skipped */
}

int ns1__playExecutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__playExecutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__playExecutionResponse(struct soap *soap, const char *tag, int id, const ns1__playExecutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__playExecutionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__playExecutionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__playExecutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__playExecutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__playExecutionResponse * SOAP_FMAC4 soap_in_ns1__playExecutionResponse(struct soap *soap, const char *tag, ns1__playExecutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__playExecutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__playExecutionResponse, sizeof(ns1__playExecutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__playExecutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__playExecutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__playExecutionResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__playExecutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__playExecutionResponse, 0, sizeof(ns1__playExecutionResponse), 0, soap_copy_ns1__playExecutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__playExecutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__playExecutionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:playExecutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__playExecutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__playExecutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__playExecutionResponse * SOAP_FMAC4 soap_get_ns1__playExecutionResponse(struct soap *soap, ns1__playExecutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__playExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__playExecutionResponse * SOAP_FMAC2 soap_instantiate_ns1__playExecutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__playExecutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__playExecutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__playExecutionResponse);
		if (size)
			*size = sizeof(ns1__playExecutionResponse);
		((ns1__playExecutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__playExecutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__playExecutionResponse);
		for (int i = 0; i < n; i++)
			((ns1__playExecutionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__playExecutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__playExecutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__playExecutionResponse %p -> %p\n", q, p));
	*(ns1__playExecutionResponse*)p = *(ns1__playExecutionResponse*)q;
}

void ns1__playExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__playExecution::executionId);
	/* transient soap skipped */
}

void ns1__playExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__playExecution::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__playExecution::executionId);
	/* transient soap skipped */
}

int ns1__playExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__playExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__playExecution(struct soap *soap, const char *tag, int id, const ns1__playExecution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__playExecution), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->ns1__playExecution::executionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__playExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__playExecution(soap, tag, this, type);
}

SOAP_FMAC3 ns1__playExecution * SOAP_FMAC4 soap_in_ns1__playExecution(struct soap *soap, const char *tag, ns1__playExecution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__playExecution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__playExecution, sizeof(ns1__playExecution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__playExecution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__playExecution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->ns1__playExecution::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__playExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__playExecution, 0, sizeof(ns1__playExecution), 0, soap_copy_ns1__playExecution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__playExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__playExecution);
	if (this->soap_out(soap, tag?tag:"ns1:playExecution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__playExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__playExecution(soap, this, tag, type);
}

SOAP_FMAC3 ns1__playExecution * SOAP_FMAC4 soap_get_ns1__playExecution(struct soap *soap, ns1__playExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__playExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__playExecution * SOAP_FMAC2 soap_instantiate_ns1__playExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__playExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__playExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__playExecution);
		if (size)
			*size = sizeof(ns1__playExecution);
		((ns1__playExecution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__playExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__playExecution);
		for (int i = 0; i < n; i++)
			((ns1__playExecution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__playExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__playExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__playExecution %p -> %p\n", q, p));
	*(ns1__playExecution*)p = *(ns1__playExecution*)q;
}

void ns1__getExecutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getExecutionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getExecutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__getExecutionResponse::return_);
	/* transient soap skipped */
}

int ns1__getExecutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getExecutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getExecutionResponse(struct soap *soap, const char *tag, int id, const ns1__getExecutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getExecutionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__getExecutionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getExecutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getExecutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getExecutionResponse * SOAP_FMAC4 soap_in_ns1__getExecutionResponse(struct soap *soap, const char *tag, ns1__getExecutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getExecutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getExecutionResponse, sizeof(ns1__getExecutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getExecutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getExecutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__getExecutionResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getExecutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getExecutionResponse, 0, sizeof(ns1__getExecutionResponse), 0, soap_copy_ns1__getExecutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getExecutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getExecutionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getExecutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getExecutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getExecutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getExecutionResponse * SOAP_FMAC4 soap_get_ns1__getExecutionResponse(struct soap *soap, ns1__getExecutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getExecutionResponse * SOAP_FMAC2 soap_instantiate_ns1__getExecutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getExecutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getExecutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getExecutionResponse);
		if (size)
			*size = sizeof(ns1__getExecutionResponse);
		((ns1__getExecutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getExecutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getExecutionResponse);
		for (int i = 0; i < n; i++)
			((ns1__getExecutionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getExecutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getExecutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getExecutionResponse %p -> %p\n", q, p));
	*(ns1__getExecutionResponse*)p = *(ns1__getExecutionResponse*)q;
}

void ns1__getExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__getExecution::executionId);
	/* transient soap skipped */
}

void ns1__getExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__getExecution::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__getExecution::executionId);
	/* transient soap skipped */
}

int ns1__getExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getExecution(struct soap *soap, const char *tag, int id, const ns1__getExecution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getExecution), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->ns1__getExecution::executionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getExecution(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getExecution * SOAP_FMAC4 soap_in_ns1__getExecution(struct soap *soap, const char *tag, ns1__getExecution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getExecution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getExecution, sizeof(ns1__getExecution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getExecution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getExecution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->ns1__getExecution::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getExecution, 0, sizeof(ns1__getExecution), 0, soap_copy_ns1__getExecution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getExecution);
	if (this->soap_out(soap, tag?tag:"ns1:getExecution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getExecution(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getExecution * SOAP_FMAC4 soap_get_ns1__getExecution(struct soap *soap, ns1__getExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getExecution * SOAP_FMAC2 soap_instantiate_ns1__getExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getExecution);
		if (size)
			*size = sizeof(ns1__getExecution);
		((ns1__getExecution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getExecution);
		for (int i = 0; i < n; i++)
			((ns1__getExecution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getExecution %p -> %p\n", q, p));
	*(ns1__getExecution*)p = *(ns1__getExecution*)q;
}

void ns1__killExecutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__killExecutionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__killExecutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__killExecutionResponse::return_);
	/* transient soap skipped */
}

int ns1__killExecutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__killExecutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__killExecutionResponse(struct soap *soap, const char *tag, int id, const ns1__killExecutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__killExecutionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__killExecutionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__killExecutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__killExecutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__killExecutionResponse * SOAP_FMAC4 soap_in_ns1__killExecutionResponse(struct soap *soap, const char *tag, ns1__killExecutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__killExecutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__killExecutionResponse, sizeof(ns1__killExecutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__killExecutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__killExecutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__killExecutionResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__killExecutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__killExecutionResponse, 0, sizeof(ns1__killExecutionResponse), 0, soap_copy_ns1__killExecutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__killExecutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__killExecutionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:killExecutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__killExecutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__killExecutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__killExecutionResponse * SOAP_FMAC4 soap_get_ns1__killExecutionResponse(struct soap *soap, ns1__killExecutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__killExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__killExecutionResponse * SOAP_FMAC2 soap_instantiate_ns1__killExecutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__killExecutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__killExecutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__killExecutionResponse);
		if (size)
			*size = sizeof(ns1__killExecutionResponse);
		((ns1__killExecutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__killExecutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__killExecutionResponse);
		for (int i = 0; i < n; i++)
			((ns1__killExecutionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__killExecutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__killExecutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__killExecutionResponse %p -> %p\n", q, p));
	*(ns1__killExecutionResponse*)p = *(ns1__killExecutionResponse*)q;
}

void ns1__getStdErrResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getStdErrResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getStdErrResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__getStdErrResponse::return_);
	/* transient soap skipped */
}

int ns1__getStdErrResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getStdErrResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStdErrResponse(struct soap *soap, const char *tag, int id, const ns1__getStdErrResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStdErrResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__getStdErrResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getStdErrResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getStdErrResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getStdErrResponse * SOAP_FMAC4 soap_in_ns1__getStdErrResponse(struct soap *soap, const char *tag, ns1__getStdErrResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getStdErrResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStdErrResponse, sizeof(ns1__getStdErrResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getStdErrResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getStdErrResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__getStdErrResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getStdErrResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStdErrResponse, 0, sizeof(ns1__getStdErrResponse), 0, soap_copy_ns1__getStdErrResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getStdErrResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getStdErrResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getStdErrResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getStdErrResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getStdErrResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getStdErrResponse * SOAP_FMAC4 soap_get_ns1__getStdErrResponse(struct soap *soap, ns1__getStdErrResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStdErrResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getStdErrResponse * SOAP_FMAC2 soap_instantiate_ns1__getStdErrResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getStdErrResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getStdErrResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getStdErrResponse);
		if (size)
			*size = sizeof(ns1__getStdErrResponse);
		((ns1__getStdErrResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getStdErrResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getStdErrResponse);
		for (int i = 0; i < n; i++)
			((ns1__getStdErrResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getStdErrResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getStdErrResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getStdErrResponse %p -> %p\n", q, p));
	*(ns1__getStdErrResponse*)p = *(ns1__getStdErrResponse*)q;
}

void ns1__getStdErr::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__getStdErr::executionId);
	/* transient soap skipped */
}

void ns1__getStdErr::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__getStdErr::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__getStdErr::executionId);
	/* transient soap skipped */
}

int ns1__getStdErr::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getStdErr(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStdErr(struct soap *soap, const char *tag, int id, const ns1__getStdErr *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStdErr), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->ns1__getStdErr::executionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getStdErr::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getStdErr(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getStdErr * SOAP_FMAC4 soap_in_ns1__getStdErr(struct soap *soap, const char *tag, ns1__getStdErr *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getStdErr *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStdErr, sizeof(ns1__getStdErr), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getStdErr)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getStdErr *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->ns1__getStdErr::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getStdErr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStdErr, 0, sizeof(ns1__getStdErr), 0, soap_copy_ns1__getStdErr);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getStdErr::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getStdErr);
	if (this->soap_out(soap, tag?tag:"ns1:getStdErr", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getStdErr::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getStdErr(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getStdErr * SOAP_FMAC4 soap_get_ns1__getStdErr(struct soap *soap, ns1__getStdErr *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStdErr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getStdErr * SOAP_FMAC2 soap_instantiate_ns1__getStdErr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getStdErr(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getStdErr, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getStdErr);
		if (size)
			*size = sizeof(ns1__getStdErr);
		((ns1__getStdErr*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getStdErr[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getStdErr);
		for (int i = 0; i < n; i++)
			((ns1__getStdErr*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getStdErr*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getStdErr(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getStdErr %p -> %p\n", q, p));
	*(ns1__getStdErr*)p = *(ns1__getStdErr*)q;
}

void ns1__getStdOutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getStdOutResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getStdOutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__getStdOutResponse::return_);
	/* transient soap skipped */
}

int ns1__getStdOutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getStdOutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStdOutResponse(struct soap *soap, const char *tag, int id, const ns1__getStdOutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStdOutResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__getStdOutResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getStdOutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getStdOutResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getStdOutResponse * SOAP_FMAC4 soap_in_ns1__getStdOutResponse(struct soap *soap, const char *tag, ns1__getStdOutResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getStdOutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStdOutResponse, sizeof(ns1__getStdOutResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getStdOutResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getStdOutResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__getStdOutResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getStdOutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStdOutResponse, 0, sizeof(ns1__getStdOutResponse), 0, soap_copy_ns1__getStdOutResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getStdOutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getStdOutResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getStdOutResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getStdOutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getStdOutResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getStdOutResponse * SOAP_FMAC4 soap_get_ns1__getStdOutResponse(struct soap *soap, ns1__getStdOutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStdOutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getStdOutResponse * SOAP_FMAC2 soap_instantiate_ns1__getStdOutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getStdOutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getStdOutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getStdOutResponse);
		if (size)
			*size = sizeof(ns1__getStdOutResponse);
		((ns1__getStdOutResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getStdOutResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getStdOutResponse);
		for (int i = 0; i < n; i++)
			((ns1__getStdOutResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getStdOutResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getStdOutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getStdOutResponse %p -> %p\n", q, p));
	*(ns1__getStdOutResponse*)p = *(ns1__getStdOutResponse*)q;
}

void ns1__getStdOut::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__getStdOut::executionId);
	/* transient soap skipped */
}

void ns1__getStdOut::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__getStdOut::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__getStdOut::executionId);
	/* transient soap skipped */
}

int ns1__getStdOut::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getStdOut(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStdOut(struct soap *soap, const char *tag, int id, const ns1__getStdOut *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStdOut), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->ns1__getStdOut::executionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getStdOut::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getStdOut(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getStdOut * SOAP_FMAC4 soap_in_ns1__getStdOut(struct soap *soap, const char *tag, ns1__getStdOut *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getStdOut *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStdOut, sizeof(ns1__getStdOut), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getStdOut)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getStdOut *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->ns1__getStdOut::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getStdOut *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStdOut, 0, sizeof(ns1__getStdOut), 0, soap_copy_ns1__getStdOut);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getStdOut::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getStdOut);
	if (this->soap_out(soap, tag?tag:"ns1:getStdOut", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getStdOut::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getStdOut(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getStdOut * SOAP_FMAC4 soap_get_ns1__getStdOut(struct soap *soap, ns1__getStdOut *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStdOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getStdOut * SOAP_FMAC2 soap_instantiate_ns1__getStdOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getStdOut(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getStdOut, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getStdOut);
		if (size)
			*size = sizeof(ns1__getStdOut);
		((ns1__getStdOut*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getStdOut[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getStdOut);
		for (int i = 0; i < n; i++)
			((ns1__getStdOut*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getStdOut*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getStdOut(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getStdOut %p -> %p\n", q, p));
	*(ns1__getStdOut*)p = *(ns1__getStdOut*)q;
}

void ns1__killExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__killExecution::executionId);
	/* transient soap skipped */
}

void ns1__killExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__killExecution::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__killExecution::executionId);
	/* transient soap skipped */
}

int ns1__killExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__killExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__killExecution(struct soap *soap, const char *tag, int id, const ns1__killExecution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__killExecution), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->ns1__killExecution::executionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__killExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__killExecution(soap, tag, this, type);
}

SOAP_FMAC3 ns1__killExecution * SOAP_FMAC4 soap_in_ns1__killExecution(struct soap *soap, const char *tag, ns1__killExecution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__killExecution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__killExecution, sizeof(ns1__killExecution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__killExecution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__killExecution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->ns1__killExecution::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__killExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__killExecution, 0, sizeof(ns1__killExecution), 0, soap_copy_ns1__killExecution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__killExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__killExecution);
	if (this->soap_out(soap, tag?tag:"ns1:killExecution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__killExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__killExecution(soap, this, tag, type);
}

SOAP_FMAC3 ns1__killExecution * SOAP_FMAC4 soap_get_ns1__killExecution(struct soap *soap, ns1__killExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__killExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__killExecution * SOAP_FMAC2 soap_instantiate_ns1__killExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__killExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__killExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__killExecution);
		if (size)
			*size = sizeof(ns1__killExecution);
		((ns1__killExecution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__killExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__killExecution);
		for (int i = 0; i < n; i++)
			((ns1__killExecution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__killExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__killExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__killExecution %p -> %p\n", q, p));
	*(ns1__killExecution*)p = *(ns1__killExecution*)q;
}

void ns1__getExecutionResultsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getExecutionResultsResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getExecutionResultsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__getExecutionResultsResponse::return_);
	/* transient soap skipped */
}

int ns1__getExecutionResultsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getExecutionResultsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getExecutionResultsResponse(struct soap *soap, const char *tag, int id, const ns1__getExecutionResultsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getExecutionResultsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__getExecutionResultsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getExecutionResultsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getExecutionResultsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getExecutionResultsResponse * SOAP_FMAC4 soap_in_ns1__getExecutionResultsResponse(struct soap *soap, const char *tag, ns1__getExecutionResultsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getExecutionResultsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getExecutionResultsResponse, sizeof(ns1__getExecutionResultsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getExecutionResultsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getExecutionResultsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__getExecutionResultsResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getExecutionResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getExecutionResultsResponse, 0, sizeof(ns1__getExecutionResultsResponse), 0, soap_copy_ns1__getExecutionResultsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getExecutionResultsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getExecutionResultsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getExecutionResultsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getExecutionResultsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getExecutionResultsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getExecutionResultsResponse * SOAP_FMAC4 soap_get_ns1__getExecutionResultsResponse(struct soap *soap, ns1__getExecutionResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getExecutionResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getExecutionResultsResponse * SOAP_FMAC2 soap_instantiate_ns1__getExecutionResultsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getExecutionResultsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getExecutionResultsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getExecutionResultsResponse);
		if (size)
			*size = sizeof(ns1__getExecutionResultsResponse);
		((ns1__getExecutionResultsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getExecutionResultsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getExecutionResultsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getExecutionResultsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getExecutionResultsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getExecutionResultsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getExecutionResultsResponse %p -> %p\n", q, p));
	*(ns1__getExecutionResultsResponse*)p = *(ns1__getExecutionResultsResponse*)q;
}

void ns1__getExecutionResults::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__getExecutionResults::executionId);
	/* transient soap skipped */
}

void ns1__getExecutionResults::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__getExecutionResults::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__getExecutionResults::executionId);
	/* transient soap skipped */
}

int ns1__getExecutionResults::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getExecutionResults(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getExecutionResults(struct soap *soap, const char *tag, int id, const ns1__getExecutionResults *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getExecutionResults), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->ns1__getExecutionResults::executionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getExecutionResults::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getExecutionResults(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getExecutionResults * SOAP_FMAC4 soap_in_ns1__getExecutionResults(struct soap *soap, const char *tag, ns1__getExecutionResults *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getExecutionResults *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getExecutionResults, sizeof(ns1__getExecutionResults), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getExecutionResults)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getExecutionResults *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->ns1__getExecutionResults::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getExecutionResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getExecutionResults, 0, sizeof(ns1__getExecutionResults), 0, soap_copy_ns1__getExecutionResults);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getExecutionResults::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getExecutionResults);
	if (this->soap_out(soap, tag?tag:"ns1:getExecutionResults", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getExecutionResults::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getExecutionResults(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getExecutionResults * SOAP_FMAC4 soap_get_ns1__getExecutionResults(struct soap *soap, ns1__getExecutionResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getExecutionResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getExecutionResults * SOAP_FMAC2 soap_instantiate_ns1__getExecutionResults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getExecutionResults(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getExecutionResults, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getExecutionResults);
		if (size)
			*size = sizeof(ns1__getExecutionResults);
		((ns1__getExecutionResults*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getExecutionResults[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getExecutionResults);
		for (int i = 0; i < n; i++)
			((ns1__getExecutionResults*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getExecutionResults*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getExecutionResults(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getExecutionResults %p -> %p\n", q, p));
	*(ns1__getExecutionResults*)p = *(ns1__getExecutionResults*)q;
}

void ns1__initExecutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__initExecutionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__initExecutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__initExecutionResponse::return_);
	/* transient soap skipped */
}

int ns1__initExecutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__initExecutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__initExecutionResponse(struct soap *soap, const char *tag, int id, const ns1__initExecutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__initExecutionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__initExecutionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__initExecutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__initExecutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__initExecutionResponse * SOAP_FMAC4 soap_in_ns1__initExecutionResponse(struct soap *soap, const char *tag, ns1__initExecutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__initExecutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__initExecutionResponse, sizeof(ns1__initExecutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__initExecutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__initExecutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__initExecutionResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__initExecutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__initExecutionResponse, 0, sizeof(ns1__initExecutionResponse), 0, soap_copy_ns1__initExecutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__initExecutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__initExecutionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:initExecutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__initExecutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__initExecutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__initExecutionResponse * SOAP_FMAC4 soap_get_ns1__initExecutionResponse(struct soap *soap, ns1__initExecutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__initExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__initExecutionResponse * SOAP_FMAC2 soap_instantiate_ns1__initExecutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__initExecutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__initExecutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__initExecutionResponse);
		if (size)
			*size = sizeof(ns1__initExecutionResponse);
		((ns1__initExecutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__initExecutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__initExecutionResponse);
		for (int i = 0; i < n; i++)
			((ns1__initExecutionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__initExecutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__initExecutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__initExecutionResponse %p -> %p\n", q, p));
	*(ns1__initExecutionResponse*)p = *(ns1__initExecutionResponse*)q;
}

void ns1__initExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__initExecution::pipelineId);
	soap_default_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, &this->ns1__initExecution::inputValue);
	this->ns1__initExecution::timeout = NULL;
	this->ns1__initExecution::executionName = NULL;
	this->ns1__initExecution::studyId = NULL;
	this->ns1__initExecution::playExecution = NULL;
	/* transient soap skipped */
}

void ns1__initExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__initExecution::pipelineId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__initExecution::pipelineId);
	soap_serialize_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, &this->ns1__initExecution::inputValue);
	soap_serialize_PointerToint(soap, &this->ns1__initExecution::timeout);
	soap_serialize_PointerTostd__string(soap, &this->ns1__initExecution::executionName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__initExecution::studyId);
	soap_serialize_PointerTobool(soap, &this->ns1__initExecution::playExecution);
	/* transient soap skipped */
}

int ns1__initExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__initExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__initExecution(struct soap *soap, const char *tag, int id, const ns1__initExecution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__initExecution), type))
		return soap->error;
	if (soap_out_std__string(soap, "pipelineId", -1, &(a->ns1__initExecution::pipelineId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, "inputValue", -1, &(a->ns1__initExecution::inputValue), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "timeout", -1, &(a->ns1__initExecution::timeout), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "executionName", -1, &(a->ns1__initExecution::executionName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "studyId", -1, &(a->ns1__initExecution::studyId), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "playExecution", -1, &(a->ns1__initExecution::playExecution), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__initExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__initExecution(soap, tag, this, type);
}

SOAP_FMAC3 ns1__initExecution * SOAP_FMAC4 soap_in_ns1__initExecution(struct soap *soap, const char *tag, ns1__initExecution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__initExecution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__initExecution, sizeof(ns1__initExecution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__initExecution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__initExecution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_pipelineId1 = 1;
	size_t soap_flag_timeout1 = 1;
	size_t soap_flag_executionName1 = 1;
	size_t soap_flag_studyId1 = 1;
	size_t soap_flag_playExecution1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pipelineId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pipelineId", &(a->ns1__initExecution::pipelineId), "xsd:string"))
				{	soap_flag_pipelineId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, "inputValue", &(a->ns1__initExecution::inputValue), "ns1:StringKeyParameterValuePair"))
					continue;
			if (soap_flag_timeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "timeout", &(a->ns1__initExecution::timeout), "xsd:int"))
				{	soap_flag_timeout1--;
					continue;
				}
			if (soap_flag_executionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "executionName", &(a->ns1__initExecution::executionName), "xsd:string"))
				{	soap_flag_executionName1--;
					continue;
				}
			if (soap_flag_studyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "studyId", &(a->ns1__initExecution::studyId), "xsd:string"))
				{	soap_flag_studyId1--;
					continue;
				}
			if (soap_flag_playExecution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "playExecution", &(a->ns1__initExecution::playExecution), "xsd:boolean"))
				{	soap_flag_playExecution1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__initExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__initExecution, 0, sizeof(ns1__initExecution), 0, soap_copy_ns1__initExecution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pipelineId1 > 0 || a->ns1__initExecution::inputValue.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__initExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__initExecution);
	if (this->soap_out(soap, tag?tag:"ns1:initExecution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__initExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__initExecution(soap, this, tag, type);
}

SOAP_FMAC3 ns1__initExecution * SOAP_FMAC4 soap_get_ns1__initExecution(struct soap *soap, ns1__initExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__initExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__initExecution * SOAP_FMAC2 soap_instantiate_ns1__initExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__initExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__initExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__initExecution);
		if (size)
			*size = sizeof(ns1__initExecution);
		((ns1__initExecution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__initExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__initExecution);
		for (int i = 0; i < n; i++)
			((ns1__initExecution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__initExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__initExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__initExecution %p -> %p\n", q, p));
	*(ns1__initExecution*)p = *(ns1__initExecution*)q;
}

void ns1__getGlobalPropertiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getGlobalPropertiesResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getGlobalPropertiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__getGlobalPropertiesResponse::return_);
	/* transient soap skipped */
}

int ns1__getGlobalPropertiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getGlobalPropertiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getGlobalPropertiesResponse(struct soap *soap, const char *tag, int id, const ns1__getGlobalPropertiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getGlobalPropertiesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__getGlobalPropertiesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getGlobalPropertiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getGlobalPropertiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getGlobalPropertiesResponse * SOAP_FMAC4 soap_in_ns1__getGlobalPropertiesResponse(struct soap *soap, const char *tag, ns1__getGlobalPropertiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getGlobalPropertiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getGlobalPropertiesResponse, sizeof(ns1__getGlobalPropertiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getGlobalPropertiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getGlobalPropertiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__getGlobalPropertiesResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getGlobalPropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getGlobalPropertiesResponse, 0, sizeof(ns1__getGlobalPropertiesResponse), 0, soap_copy_ns1__getGlobalPropertiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getGlobalPropertiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getGlobalPropertiesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getGlobalPropertiesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getGlobalPropertiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getGlobalPropertiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getGlobalPropertiesResponse * SOAP_FMAC4 soap_get_ns1__getGlobalPropertiesResponse(struct soap *soap, ns1__getGlobalPropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getGlobalPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getGlobalPropertiesResponse * SOAP_FMAC2 soap_instantiate_ns1__getGlobalPropertiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getGlobalPropertiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getGlobalPropertiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getGlobalPropertiesResponse);
		if (size)
			*size = sizeof(ns1__getGlobalPropertiesResponse);
		((ns1__getGlobalPropertiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getGlobalPropertiesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getGlobalPropertiesResponse);
		for (int i = 0; i < n; i++)
			((ns1__getGlobalPropertiesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getGlobalPropertiesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getGlobalPropertiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getGlobalPropertiesResponse %p -> %p\n", q, p));
	*(ns1__getGlobalPropertiesResponse*)p = *(ns1__getGlobalPropertiesResponse*)q;
}

void ns1__getGlobalProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__getGlobalProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getGlobalProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getGlobalProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getGlobalProperties(struct soap *soap, const char *tag, int id, const ns1__getGlobalProperties *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getGlobalProperties), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getGlobalProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getGlobalProperties(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getGlobalProperties * SOAP_FMAC4 soap_in_ns1__getGlobalProperties(struct soap *soap, const char *tag, ns1__getGlobalProperties *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getGlobalProperties *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getGlobalProperties, sizeof(ns1__getGlobalProperties), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getGlobalProperties)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getGlobalProperties *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getGlobalProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getGlobalProperties, 0, sizeof(ns1__getGlobalProperties), 0, soap_copy_ns1__getGlobalProperties);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getGlobalProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getGlobalProperties);
	if (this->soap_out(soap, tag?tag:"ns1:getGlobalProperties", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getGlobalProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getGlobalProperties(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getGlobalProperties * SOAP_FMAC4 soap_get_ns1__getGlobalProperties(struct soap *soap, ns1__getGlobalProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getGlobalProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getGlobalProperties * SOAP_FMAC2 soap_instantiate_ns1__getGlobalProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getGlobalProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getGlobalProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getGlobalProperties);
		if (size)
			*size = sizeof(ns1__getGlobalProperties);
		((ns1__getGlobalProperties*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getGlobalProperties[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getGlobalProperties);
		for (int i = 0; i < n; i++)
			((ns1__getGlobalProperties*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getGlobalProperties*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getGlobalProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getGlobalProperties %p -> %p\n", q, p));
	*(ns1__getGlobalProperties*)p = *(ns1__getGlobalProperties*)q;
}

void ns1__updateExecutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__updateExecutionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__updateExecutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__updateExecutionResponse::return_);
	/* transient soap skipped */
}

int ns1__updateExecutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateExecutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateExecutionResponse(struct soap *soap, const char *tag, int id, const ns1__updateExecutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateExecutionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__updateExecutionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updateExecutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateExecutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateExecutionResponse * SOAP_FMAC4 soap_in_ns1__updateExecutionResponse(struct soap *soap, const char *tag, ns1__updateExecutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateExecutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateExecutionResponse, sizeof(ns1__updateExecutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateExecutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateExecutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__updateExecutionResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateExecutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateExecutionResponse, 0, sizeof(ns1__updateExecutionResponse), 0, soap_copy_ns1__updateExecutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__updateExecutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateExecutionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:updateExecutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__updateExecutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateExecutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateExecutionResponse * SOAP_FMAC4 soap_get_ns1__updateExecutionResponse(struct soap *soap, ns1__updateExecutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__updateExecutionResponse * SOAP_FMAC2 soap_instantiate_ns1__updateExecutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateExecutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateExecutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateExecutionResponse);
		if (size)
			*size = sizeof(ns1__updateExecutionResponse);
		((ns1__updateExecutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateExecutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateExecutionResponse);
		for (int i = 0; i < n; i++)
			((ns1__updateExecutionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateExecutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateExecutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateExecutionResponse %p -> %p\n", q, p));
	*(ns1__updateExecutionResponse*)p = *(ns1__updateExecutionResponse*)q;
}

void ns1__StringKeyValuePair::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__StringKeyValuePair::name);
	this->ns1__StringKeyValuePair::__union_StringKeyValuePair = 0;
	/* transient soap skipped */
}

void ns1__StringKeyValuePair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__StringKeyValuePair::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__StringKeyValuePair::name);
	soap_serialize__ns1__union_StringKeyValuePair(soap, this->ns1__StringKeyValuePair::__union_StringKeyValuePair, &this->ns1__StringKeyValuePair::union_StringKeyValuePair);
	/* transient soap skipped */
}

int ns1__StringKeyValuePair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StringKeyValuePair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StringKeyValuePair(struct soap *soap, const char *tag, int id, const ns1__StringKeyValuePair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StringKeyValuePair), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns1__StringKeyValuePair::name), ""))
		return soap->error;
	if (soap_out__ns1__union_StringKeyValuePair(soap, a->ns1__StringKeyValuePair::__union_StringKeyValuePair, &a->ns1__StringKeyValuePair::union_StringKeyValuePair))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__StringKeyValuePair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__StringKeyValuePair(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StringKeyValuePair * SOAP_FMAC4 soap_in_ns1__StringKeyValuePair(struct soap *soap, const char *tag, ns1__StringKeyValuePair *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StringKeyValuePair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StringKeyValuePair, sizeof(ns1__StringKeyValuePair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__StringKeyValuePair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__StringKeyValuePair *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_union_StringKeyValuePair1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns1__StringKeyValuePair::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_union_StringKeyValuePair1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__union_StringKeyValuePair(soap, &a->ns1__StringKeyValuePair::__union_StringKeyValuePair, &a->ns1__StringKeyValuePair::union_StringKeyValuePair))
				{	soap_flag_union_StringKeyValuePair1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__StringKeyValuePair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StringKeyValuePair, 0, sizeof(ns1__StringKeyValuePair), 0, soap_copy_ns1__StringKeyValuePair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_union_StringKeyValuePair1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__StringKeyValuePair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__StringKeyValuePair);
	if (this->soap_out(soap, tag?tag:"ns1:StringKeyValuePair", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StringKeyValuePair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StringKeyValuePair(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StringKeyValuePair * SOAP_FMAC4 soap_get_ns1__StringKeyValuePair(struct soap *soap, ns1__StringKeyValuePair *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StringKeyValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__StringKeyValuePair * SOAP_FMAC2 soap_instantiate_ns1__StringKeyValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StringKeyValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StringKeyValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__StringKeyValuePair);
		if (size)
			*size = sizeof(ns1__StringKeyValuePair);
		((ns1__StringKeyValuePair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__StringKeyValuePair[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__StringKeyValuePair);
		for (int i = 0; i < n; i++)
			((ns1__StringKeyValuePair*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__StringKeyValuePair*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StringKeyValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__StringKeyValuePair %p -> %p\n", q, p));
	*(ns1__StringKeyValuePair*)p = *(ns1__StringKeyValuePair*)q;
}

void ns1__updateExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__updateExecution::executionId);
	soap_default_std__vectorTemplateOfPointerTons1__StringKeyValuePair(soap, &this->ns1__updateExecution::keyValuePair);
	/* transient soap skipped */
}

void ns1__updateExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__updateExecution::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__updateExecution::executionId);
	soap_serialize_std__vectorTemplateOfPointerTons1__StringKeyValuePair(soap, &this->ns1__updateExecution::keyValuePair);
	/* transient soap skipped */
}

int ns1__updateExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateExecution(struct soap *soap, const char *tag, int id, const ns1__updateExecution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateExecution), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->ns1__updateExecution::executionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__StringKeyValuePair(soap, "keyValuePair", -1, &(a->ns1__updateExecution::keyValuePair), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updateExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateExecution(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateExecution * SOAP_FMAC4 soap_in_ns1__updateExecution(struct soap *soap, const char *tag, ns1__updateExecution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateExecution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateExecution, sizeof(ns1__updateExecution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateExecution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateExecution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->ns1__updateExecution::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__StringKeyValuePair(soap, "keyValuePair", &(a->ns1__updateExecution::keyValuePair), "ns1:StringKeyValuePair"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateExecution, 0, sizeof(ns1__updateExecution), 0, soap_copy_ns1__updateExecution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0 || a->ns1__updateExecution::keyValuePair.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__updateExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateExecution);
	if (this->soap_out(soap, tag?tag:"ns1:updateExecution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__updateExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateExecution(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateExecution * SOAP_FMAC4 soap_get_ns1__updateExecution(struct soap *soap, ns1__updateExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__updateExecution * SOAP_FMAC2 soap_instantiate_ns1__updateExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateExecution);
		if (size)
			*size = sizeof(ns1__updateExecution);
		((ns1__updateExecution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateExecution);
		for (int i = 0; i < n; i++)
			((ns1__updateExecution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateExecution %p -> %p\n", q, p));
	*(ns1__updateExecution*)p = *(ns1__updateExecution*)q;
}

void ns1__logoutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__logoutResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__logoutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__logoutResponse::return_);
	/* transient soap skipped */
}

int ns1__logoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__logoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logoutResponse(struct soap *soap, const char *tag, int id, const ns1__logoutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__logoutResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__logoutResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__logoutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__logoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__logoutResponse * SOAP_FMAC4 soap_in_ns1__logoutResponse(struct soap *soap, const char *tag, ns1__logoutResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__logoutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__logoutResponse, sizeof(ns1__logoutResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__logoutResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__logoutResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__logoutResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__logoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__logoutResponse, 0, sizeof(ns1__logoutResponse), 0, soap_copy_ns1__logoutResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__logoutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__logoutResponse);
	if (this->soap_out(soap, tag?tag:"ns1:logoutResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__logoutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__logoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__logoutResponse * SOAP_FMAC4 soap_get_ns1__logoutResponse(struct soap *soap, ns1__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__logoutResponse * SOAP_FMAC2 soap_instantiate_ns1__logoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__logoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__logoutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__logoutResponse);
		if (size)
			*size = sizeof(ns1__logoutResponse);
		((ns1__logoutResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__logoutResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__logoutResponse);
		for (int i = 0; i < n; i++)
			((ns1__logoutResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__logoutResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__logoutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__logoutResponse %p -> %p\n", q, p));
	*(ns1__logoutResponse*)p = *(ns1__logoutResponse*)q;
}

void ns1__logout::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__logout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__logout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__logout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logout(struct soap *soap, const char *tag, int id, const ns1__logout *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__logout), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__logout::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__logout(soap, tag, this, type);
}

SOAP_FMAC3 ns1__logout * SOAP_FMAC4 soap_in_ns1__logout(struct soap *soap, const char *tag, ns1__logout *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__logout *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__logout, sizeof(ns1__logout), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__logout)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__logout *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__logout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__logout, 0, sizeof(ns1__logout), 0, soap_copy_ns1__logout);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__logout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__logout);
	if (this->soap_out(soap, tag?tag:"ns1:logout", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__logout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__logout(soap, this, tag, type);
}

SOAP_FMAC3 ns1__logout * SOAP_FMAC4 soap_get_ns1__logout(struct soap *soap, ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__logout * SOAP_FMAC2 soap_instantiate_ns1__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__logout);
		if (size)
			*size = sizeof(ns1__logout);
		((ns1__logout*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__logout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__logout);
		for (int i = 0; i < n; i++)
			((ns1__logout*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__logout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__logout %p -> %p\n", q, p));
	*(ns1__logout*)p = *(ns1__logout*)q;
}

void ns1__authenticateHTTPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__authenticateHTTPResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__authenticateHTTPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__authenticateHTTPResponse::return_);
	/* transient soap skipped */
}

int ns1__authenticateHTTPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateHTTPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateHTTPResponse(struct soap *soap, const char *tag, int id, const ns1__authenticateHTTPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateHTTPResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__authenticateHTTPResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateHTTPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateHTTPResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateHTTPResponse * SOAP_FMAC4 soap_in_ns1__authenticateHTTPResponse(struct soap *soap, const char *tag, ns1__authenticateHTTPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateHTTPResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateHTTPResponse, sizeof(ns1__authenticateHTTPResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateHTTPResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateHTTPResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__authenticateHTTPResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateHTTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateHTTPResponse, 0, sizeof(ns1__authenticateHTTPResponse), 0, soap_copy_ns1__authenticateHTTPResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__authenticateHTTPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateHTTPResponse);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateHTTPResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateHTTPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateHTTPResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateHTTPResponse * SOAP_FMAC4 soap_get_ns1__authenticateHTTPResponse(struct soap *soap, ns1__authenticateHTTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateHTTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateHTTPResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateHTTPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateHTTPResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateHTTPResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateHTTPResponse);
		if (size)
			*size = sizeof(ns1__authenticateHTTPResponse);
		((ns1__authenticateHTTPResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateHTTPResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__authenticateHTTPResponse);
		for (int i = 0; i < n; i++)
			((ns1__authenticateHTTPResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__authenticateHTTPResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateHTTPResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateHTTPResponse %p -> %p\n", q, p));
	*(ns1__authenticateHTTPResponse*)p = *(ns1__authenticateHTTPResponse*)q;
}

void ns1__authenticateHTTP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__authenticateHTTP::userName);
	/* transient soap skipped */
}

void ns1__authenticateHTTP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__authenticateHTTP::userName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__authenticateHTTP::userName);
	/* transient soap skipped */
}

int ns1__authenticateHTTP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateHTTP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateHTTP(struct soap *soap, const char *tag, int id, const ns1__authenticateHTTP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateHTTP), type))
		return soap->error;
	if (soap_out_std__string(soap, "userName", -1, &(a->ns1__authenticateHTTP::userName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateHTTP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateHTTP(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateHTTP * SOAP_FMAC4 soap_in_ns1__authenticateHTTP(struct soap *soap, const char *tag, ns1__authenticateHTTP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateHTTP *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateHTTP, sizeof(ns1__authenticateHTTP), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateHTTP)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateHTTP *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userName", &(a->ns1__authenticateHTTP::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateHTTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateHTTP, 0, sizeof(ns1__authenticateHTTP), 0, soap_copy_ns1__authenticateHTTP);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__authenticateHTTP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateHTTP);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateHTTP", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateHTTP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateHTTP(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateHTTP * SOAP_FMAC4 soap_get_ns1__authenticateHTTP(struct soap *soap, ns1__authenticateHTTP *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateHTTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateHTTP * SOAP_FMAC2 soap_instantiate_ns1__authenticateHTTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateHTTP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateHTTP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateHTTP);
		if (size)
			*size = sizeof(ns1__authenticateHTTP);
		((ns1__authenticateHTTP*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateHTTP[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__authenticateHTTP);
		for (int i = 0; i < n; i++)
			((ns1__authenticateHTTP*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__authenticateHTTP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateHTTP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateHTTP %p -> %p\n", q, p));
	*(ns1__authenticateHTTP*)p = *(ns1__authenticateHTTP*)q;
}

void ns1__getPipelineResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getPipelineResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getPipelineResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__getPipelineResponse::return_);
	/* transient soap skipped */
}

int ns1__getPipelineResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPipelineResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPipelineResponse(struct soap *soap, const char *tag, int id, const ns1__getPipelineResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPipelineResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__getPipelineResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPipelineResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPipelineResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPipelineResponse * SOAP_FMAC4 soap_in_ns1__getPipelineResponse(struct soap *soap, const char *tag, ns1__getPipelineResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPipelineResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPipelineResponse, sizeof(ns1__getPipelineResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPipelineResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPipelineResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__getPipelineResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPipelineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPipelineResponse, 0, sizeof(ns1__getPipelineResponse), 0, soap_copy_ns1__getPipelineResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getPipelineResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPipelineResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getPipelineResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getPipelineResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPipelineResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPipelineResponse * SOAP_FMAC4 soap_get_ns1__getPipelineResponse(struct soap *soap, ns1__getPipelineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPipelineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getPipelineResponse * SOAP_FMAC2 soap_instantiate_ns1__getPipelineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPipelineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPipelineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPipelineResponse);
		if (size)
			*size = sizeof(ns1__getPipelineResponse);
		((ns1__getPipelineResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPipelineResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPipelineResponse);
		for (int i = 0; i < n; i++)
			((ns1__getPipelineResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPipelineResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPipelineResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPipelineResponse %p -> %p\n", q, p));
	*(ns1__getPipelineResponse*)p = *(ns1__getPipelineResponse*)q;
}

void ns1__getPipeline::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__getPipeline::pipelineId);
	/* transient soap skipped */
}

void ns1__getPipeline::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__getPipeline::pipelineId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__getPipeline::pipelineId);
	/* transient soap skipped */
}

int ns1__getPipeline::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPipeline(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPipeline(struct soap *soap, const char *tag, int id, const ns1__getPipeline *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPipeline), type))
		return soap->error;
	if (soap_out_std__string(soap, "pipelineId", -1, &(a->ns1__getPipeline::pipelineId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPipeline::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPipeline(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPipeline * SOAP_FMAC4 soap_in_ns1__getPipeline(struct soap *soap, const char *tag, ns1__getPipeline *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPipeline *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPipeline, sizeof(ns1__getPipeline), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPipeline)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPipeline *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_pipelineId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pipelineId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pipelineId", &(a->ns1__getPipeline::pipelineId), "xsd:string"))
				{	soap_flag_pipelineId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPipeline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPipeline, 0, sizeof(ns1__getPipeline), 0, soap_copy_ns1__getPipeline);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pipelineId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getPipeline::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPipeline);
	if (this->soap_out(soap, tag?tag:"ns1:getPipeline", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getPipeline::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPipeline(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPipeline * SOAP_FMAC4 soap_get_ns1__getPipeline(struct soap *soap, ns1__getPipeline *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPipeline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getPipeline * SOAP_FMAC2 soap_instantiate_ns1__getPipeline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPipeline(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPipeline, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPipeline);
		if (size)
			*size = sizeof(ns1__getPipeline);
		((ns1__getPipeline*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPipeline[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPipeline);
		for (int i = 0; i < n; i++)
			((ns1__getPipeline*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPipeline*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPipeline(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPipeline %p -> %p\n", q, p));
	*(ns1__getPipeline*)p = *(ns1__getPipeline*)q;
}

void ns1__deleteExecutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteExecutionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__deleteExecutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__deleteExecutionResponse::return_);
	/* transient soap skipped */
}

int ns1__deleteExecutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteExecutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteExecutionResponse(struct soap *soap, const char *tag, int id, const ns1__deleteExecutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteExecutionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__deleteExecutionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteExecutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteExecutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteExecutionResponse * SOAP_FMAC4 soap_in_ns1__deleteExecutionResponse(struct soap *soap, const char *tag, ns1__deleteExecutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteExecutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteExecutionResponse, sizeof(ns1__deleteExecutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteExecutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteExecutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__deleteExecutionResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteExecutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteExecutionResponse, 0, sizeof(ns1__deleteExecutionResponse), 0, soap_copy_ns1__deleteExecutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__deleteExecutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteExecutionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:deleteExecutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteExecutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteExecutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteExecutionResponse * SOAP_FMAC4 soap_get_ns1__deleteExecutionResponse(struct soap *soap, ns1__deleteExecutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteExecutionResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteExecutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteExecutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteExecutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteExecutionResponse);
		if (size)
			*size = sizeof(ns1__deleteExecutionResponse);
		((ns1__deleteExecutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteExecutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteExecutionResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteExecutionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteExecutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteExecutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteExecutionResponse %p -> %p\n", q, p));
	*(ns1__deleteExecutionResponse*)p = *(ns1__deleteExecutionResponse*)q;
}

void ns1__deleteExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__deleteExecution::executionId);
	soap_default_bool(soap, &this->ns1__deleteExecution::deleteFiles);
	/* transient soap skipped */
}

void ns1__deleteExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__deleteExecution::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__deleteExecution::executionId);
	soap_embedded(soap, &this->ns1__deleteExecution::deleteFiles, SOAP_TYPE_bool);
	/* transient soap skipped */
}

int ns1__deleteExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteExecution(struct soap *soap, const char *tag, int id, const ns1__deleteExecution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteExecution), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->ns1__deleteExecution::executionId), ""))
		return soap->error;
	if (soap_out_bool(soap, "deleteFiles", -1, &(a->ns1__deleteExecution::deleteFiles), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteExecution(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteExecution * SOAP_FMAC4 soap_in_ns1__deleteExecution(struct soap *soap, const char *tag, ns1__deleteExecution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteExecution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteExecution, sizeof(ns1__deleteExecution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteExecution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteExecution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	size_t soap_flag_deleteFiles1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->ns1__deleteExecution::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			if (soap_flag_deleteFiles1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "deleteFiles", &(a->ns1__deleteExecution::deleteFiles), "xsd:boolean"))
				{	soap_flag_deleteFiles1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteExecution, 0, sizeof(ns1__deleteExecution), 0, soap_copy_ns1__deleteExecution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0 || soap_flag_deleteFiles1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__deleteExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteExecution);
	if (this->soap_out(soap, tag?tag:"ns1:deleteExecution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__deleteExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteExecution(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteExecution * SOAP_FMAC4 soap_get_ns1__deleteExecution(struct soap *soap, ns1__deleteExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__deleteExecution * SOAP_FMAC2 soap_instantiate_ns1__deleteExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteExecution);
		if (size)
			*size = sizeof(ns1__deleteExecution);
		((ns1__deleteExecution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__deleteExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteExecution);
		for (int i = 0; i < n; i++)
			((ns1__deleteExecution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteExecution %p -> %p\n", q, p));
	*(ns1__deleteExecution*)p = *(ns1__deleteExecution*)q;
}

void ns1__PipelineKeyBooleanValuePair::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__PipelineKeyBooleanValuePair::name = NULL;
	soap_default_bool(soap, &this->ns1__PipelineKeyBooleanValuePair::value);
	/* transient soap skipped */
}

void ns1__PipelineKeyBooleanValuePair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Pipeline(soap, &this->ns1__PipelineKeyBooleanValuePair::name);
	soap_embedded(soap, &this->ns1__PipelineKeyBooleanValuePair::value, SOAP_TYPE_bool);
	/* transient soap skipped */
}

int ns1__PipelineKeyBooleanValuePair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PipelineKeyBooleanValuePair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, int id, const ns1__PipelineKeyBooleanValuePair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PipelineKeyBooleanValuePair), type))
		return soap->error;
	if (soap_out_PointerTons1__Pipeline(soap, "name", -1, &(a->ns1__PipelineKeyBooleanValuePair::name), ""))
		return soap->error;
	if (soap_out_bool(soap, "value", -1, &(a->ns1__PipelineKeyBooleanValuePair::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PipelineKeyBooleanValuePair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PipelineKeyBooleanValuePair(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PipelineKeyBooleanValuePair * SOAP_FMAC4 soap_in_ns1__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, ns1__PipelineKeyBooleanValuePair *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PipelineKeyBooleanValuePair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PipelineKeyBooleanValuePair, sizeof(ns1__PipelineKeyBooleanValuePair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PipelineKeyBooleanValuePair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PipelineKeyBooleanValuePair *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Pipeline(soap, "name", &(a->ns1__PipelineKeyBooleanValuePair::name), "ns1:Pipeline"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "value", &(a->ns1__PipelineKeyBooleanValuePair::value), "xsd:boolean"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PipelineKeyBooleanValuePair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PipelineKeyBooleanValuePair, 0, sizeof(ns1__PipelineKeyBooleanValuePair), 0, soap_copy_ns1__PipelineKeyBooleanValuePair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PipelineKeyBooleanValuePair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PipelineKeyBooleanValuePair);
	if (this->soap_out(soap, tag?tag:"ns1:PipelineKeyBooleanValuePair", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PipelineKeyBooleanValuePair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PipelineKeyBooleanValuePair(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PipelineKeyBooleanValuePair * SOAP_FMAC4 soap_get_ns1__PipelineKeyBooleanValuePair(struct soap *soap, ns1__PipelineKeyBooleanValuePair *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PipelineKeyBooleanValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PipelineKeyBooleanValuePair * SOAP_FMAC2 soap_instantiate_ns1__PipelineKeyBooleanValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PipelineKeyBooleanValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PipelineKeyBooleanValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PipelineKeyBooleanValuePair);
		if (size)
			*size = sizeof(ns1__PipelineKeyBooleanValuePair);
		((ns1__PipelineKeyBooleanValuePair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PipelineKeyBooleanValuePair[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PipelineKeyBooleanValuePair);
		for (int i = 0; i < n; i++)
			((ns1__PipelineKeyBooleanValuePair*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PipelineKeyBooleanValuePair*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PipelineKeyBooleanValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PipelineKeyBooleanValuePair %p -> %p\n", q, p));
	*(ns1__PipelineKeyBooleanValuePair*)p = *(ns1__PipelineKeyBooleanValuePair*)q;
}

void ns1__GlobalProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(soap, &this->ns1__GlobalProperties::APIErrorCodesAndMessages);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__GlobalProperties::supportedTransferProtocol);
	soap_default_std__vectorTemplateOfns1__Module(soap, &this->ns1__GlobalProperties::supportedModule);
	this->ns1__GlobalProperties::email = NULL;
	this->ns1__GlobalProperties::platformDescription = NULL;
	this->ns1__GlobalProperties::minAuthorizedExecutionTimeout = NULL;
	this->ns1__GlobalProperties::maxAuthorizedExecutionTimeout = NULL;
	this->ns1__GlobalProperties::defaultExecutionTimeout = NULL;
	soap_default_bool(soap, &this->ns1__GlobalProperties::isKillExecutionSupported);
	this->ns1__GlobalProperties::defaultStudy = NULL;
	soap_default_std__string(soap, &this->ns1__GlobalProperties::supportedAPIVersion);
	/* transient soap skipped */
}

void ns1__GlobalProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(soap, &this->ns1__GlobalProperties::APIErrorCodesAndMessages);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__GlobalProperties::supportedTransferProtocol);
	soap_serialize_std__vectorTemplateOfns1__Module(soap, &this->ns1__GlobalProperties::supportedModule);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GlobalProperties::email);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GlobalProperties::platformDescription);
	soap_serialize_PointerToint(soap, &this->ns1__GlobalProperties::minAuthorizedExecutionTimeout);
	soap_serialize_PointerToint(soap, &this->ns1__GlobalProperties::maxAuthorizedExecutionTimeout);
	soap_serialize_PointerToint(soap, &this->ns1__GlobalProperties::defaultExecutionTimeout);
	soap_embedded(soap, &this->ns1__GlobalProperties::isKillExecutionSupported, SOAP_TYPE_bool);
	soap_serialize_PointerTostd__string(soap, &this->ns1__GlobalProperties::defaultStudy);
	soap_embedded(soap, &this->ns1__GlobalProperties::supportedAPIVersion, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__GlobalProperties::supportedAPIVersion);
	/* transient soap skipped */
}

int ns1__GlobalProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GlobalProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GlobalProperties(struct soap *soap, const char *tag, int id, const ns1__GlobalProperties *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GlobalProperties), "ns1:GlobalProperties"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(soap, "APIErrorCodesAndMessages", -1, &(a->ns1__GlobalProperties::APIErrorCodesAndMessages), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "supportedTransferProtocol", -1, &(a->ns1__GlobalProperties::supportedTransferProtocol), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__Module(soap, "supportedModule", -1, &(a->ns1__GlobalProperties::supportedModule), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "email", -1, &(a->ns1__GlobalProperties::email), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "platformDescription", -1, &(a->ns1__GlobalProperties::platformDescription), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "minAuthorizedExecutionTimeout", -1, &(a->ns1__GlobalProperties::minAuthorizedExecutionTimeout), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "maxAuthorizedExecutionTimeout", -1, &(a->ns1__GlobalProperties::maxAuthorizedExecutionTimeout), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "defaultExecutionTimeout", -1, &(a->ns1__GlobalProperties::defaultExecutionTimeout), ""))
		return soap->error;
	if (soap_out_bool(soap, "isKillExecutionSupported", -1, &(a->ns1__GlobalProperties::isKillExecutionSupported), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "defaultStudy", -1, &(a->ns1__GlobalProperties::defaultStudy), ""))
		return soap->error;
	if (soap_out_std__string(soap, "supportedAPIVersion", -1, &(a->ns1__GlobalProperties::supportedAPIVersion), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GlobalProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GlobalProperties(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GlobalProperties * SOAP_FMAC4 soap_in_ns1__GlobalProperties(struct soap *soap, const char *tag, ns1__GlobalProperties *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GlobalProperties *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GlobalProperties, sizeof(ns1__GlobalProperties), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__GlobalProperties)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__GlobalProperties *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_email1 = 1;
	size_t soap_flag_platformDescription1 = 1;
	size_t soap_flag_minAuthorizedExecutionTimeout1 = 1;
	size_t soap_flag_maxAuthorizedExecutionTimeout1 = 1;
	size_t soap_flag_defaultExecutionTimeout1 = 1;
	size_t soap_flag_isKillExecutionSupported1 = 1;
	size_t soap_flag_defaultStudy1 = 1;
	size_t soap_flag_supportedAPIVersion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(soap, "APIErrorCodesAndMessages", &(a->ns1__GlobalProperties::APIErrorCodesAndMessages), "ns1:IntKeyStringValuePair"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "supportedTransferProtocol", &(a->ns1__GlobalProperties::supportedTransferProtocol), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns1__Module(soap, "supportedModule", &(a->ns1__GlobalProperties::supportedModule), "ns1:Module"))
					continue;
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "email", &(a->ns1__GlobalProperties::email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_platformDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "platformDescription", &(a->ns1__GlobalProperties::platformDescription), "xsd:string"))
				{	soap_flag_platformDescription1--;
					continue;
				}
			if (soap_flag_minAuthorizedExecutionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "minAuthorizedExecutionTimeout", &(a->ns1__GlobalProperties::minAuthorizedExecutionTimeout), "xsd:int"))
				{	soap_flag_minAuthorizedExecutionTimeout1--;
					continue;
				}
			if (soap_flag_maxAuthorizedExecutionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "maxAuthorizedExecutionTimeout", &(a->ns1__GlobalProperties::maxAuthorizedExecutionTimeout), "xsd:int"))
				{	soap_flag_maxAuthorizedExecutionTimeout1--;
					continue;
				}
			if (soap_flag_defaultExecutionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "defaultExecutionTimeout", &(a->ns1__GlobalProperties::defaultExecutionTimeout), "xsd:int"))
				{	soap_flag_defaultExecutionTimeout1--;
					continue;
				}
			if (soap_flag_isKillExecutionSupported1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isKillExecutionSupported", &(a->ns1__GlobalProperties::isKillExecutionSupported), "xsd:boolean"))
				{	soap_flag_isKillExecutionSupported1--;
					continue;
				}
			if (soap_flag_defaultStudy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "defaultStudy", &(a->ns1__GlobalProperties::defaultStudy), "xsd:string"))
				{	soap_flag_defaultStudy1--;
					continue;
				}
			if (soap_flag_supportedAPIVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "supportedAPIVersion", &(a->ns1__GlobalProperties::supportedAPIVersion), "xsd:string"))
				{	soap_flag_supportedAPIVersion1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GlobalProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GlobalProperties, 0, sizeof(ns1__GlobalProperties), 0, soap_copy_ns1__GlobalProperties);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__GlobalProperties::supportedTransferProtocol.size() < 1 || a->ns1__GlobalProperties::supportedModule.size() < 1 || soap_flag_isKillExecutionSupported1 > 0 || soap_flag_supportedAPIVersion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__GlobalProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__GlobalProperties);
	if (this->soap_out(soap, tag?tag:"ns1:GlobalProperties", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GlobalProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GlobalProperties(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GlobalProperties * SOAP_FMAC4 soap_get_ns1__GlobalProperties(struct soap *soap, ns1__GlobalProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GlobalProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__GlobalProperties * SOAP_FMAC2 soap_instantiate_ns1__GlobalProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GlobalProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GlobalProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__GlobalProperties);
		if (size)
			*size = sizeof(ns1__GlobalProperties);
		((ns1__GlobalProperties*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__GlobalProperties[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__GlobalProperties);
		for (int i = 0; i < n; i++)
			((ns1__GlobalProperties*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__GlobalProperties*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GlobalProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__GlobalProperties %p -> %p\n", q, p));
	*(ns1__GlobalProperties*)p = *(ns1__GlobalProperties*)q;
}

void ns1__StringKeyParameterValuePair::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__StringKeyParameterValuePair::name);
	this->ns1__StringKeyParameterValuePair::value = NULL;
	/* transient soap skipped */
}

void ns1__StringKeyParameterValuePair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__StringKeyParameterValuePair::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__StringKeyParameterValuePair::name);
	soap_serialize_PointerTons1__ParameterTypedValue(soap, &this->ns1__StringKeyParameterValuePair::value);
	/* transient soap skipped */
}

int ns1__StringKeyParameterValuePair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StringKeyParameterValuePair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StringKeyParameterValuePair(struct soap *soap, const char *tag, int id, const ns1__StringKeyParameterValuePair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StringKeyParameterValuePair), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns1__StringKeyParameterValuePair::name), ""))
		return soap->error;
	if (soap_out_PointerTons1__ParameterTypedValue(soap, "value", -1, &(a->ns1__StringKeyParameterValuePair::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__StringKeyParameterValuePair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__StringKeyParameterValuePair(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StringKeyParameterValuePair * SOAP_FMAC4 soap_in_ns1__StringKeyParameterValuePair(struct soap *soap, const char *tag, ns1__StringKeyParameterValuePair *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StringKeyParameterValuePair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StringKeyParameterValuePair, sizeof(ns1__StringKeyParameterValuePair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__StringKeyParameterValuePair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__StringKeyParameterValuePair *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns1__StringKeyParameterValuePair::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ParameterTypedValue(soap, "value", &(a->ns1__StringKeyParameterValuePair::value), "ns1:ParameterTypedValue"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__StringKeyParameterValuePair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StringKeyParameterValuePair, 0, sizeof(ns1__StringKeyParameterValuePair), 0, soap_copy_ns1__StringKeyParameterValuePair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__StringKeyParameterValuePair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__StringKeyParameterValuePair);
	if (this->soap_out(soap, tag?tag:"ns1:StringKeyParameterValuePair", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StringKeyParameterValuePair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StringKeyParameterValuePair(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StringKeyParameterValuePair * SOAP_FMAC4 soap_get_ns1__StringKeyParameterValuePair(struct soap *soap, ns1__StringKeyParameterValuePair *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StringKeyParameterValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__StringKeyParameterValuePair * SOAP_FMAC2 soap_instantiate_ns1__StringKeyParameterValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StringKeyParameterValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StringKeyParameterValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__StringKeyParameterValuePair);
		if (size)
			*size = sizeof(ns1__StringKeyParameterValuePair);
		((ns1__StringKeyParameterValuePair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__StringKeyParameterValuePair[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__StringKeyParameterValuePair);
		for (int i = 0; i < n; i++)
			((ns1__StringKeyParameterValuePair*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__StringKeyParameterValuePair*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StringKeyParameterValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__StringKeyParameterValuePair %p -> %p\n", q, p));
	*(ns1__StringKeyParameterValuePair*)p = *(ns1__StringKeyParameterValuePair*)q;
}

void ns1__Execution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Execution::identifier);
	soap_default_std__string(soap, &this->ns1__Execution::name);
	soap_default_std__string(soap, &this->ns1__Execution::pipelineIdentifier);
	this->ns1__Execution::timeout = NULL;
	soap_default_ns1__ExecutionStatus(soap, &this->ns1__Execution::status);
	soap_default_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, &this->ns1__Execution::inputValue);
	soap_default_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, &this->ns1__Execution::returnedFile);
	this->ns1__Execution::studyIdentifier = NULL;
	this->ns1__Execution::errorCode = NULL;
	this->ns1__Execution::startDate = NULL;
	this->ns1__Execution::endDate = NULL;
	/* transient soap skipped */
}

void ns1__Execution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__Execution::identifier, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Execution::identifier);
	soap_embedded(soap, &this->ns1__Execution::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Execution::name);
	soap_embedded(soap, &this->ns1__Execution::pipelineIdentifier, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Execution::pipelineIdentifier);
	soap_serialize_PointerToint(soap, &this->ns1__Execution::timeout);
	soap_embedded(soap, &this->ns1__Execution::status, SOAP_TYPE_ns1__ExecutionStatus);
	soap_serialize_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, &this->ns1__Execution::inputValue);
	soap_serialize_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, &this->ns1__Execution::returnedFile);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Execution::studyIdentifier);
	soap_serialize_PointerToint(soap, &this->ns1__Execution::errorCode);
	soap_serialize_PointerToLONG64(soap, &this->ns1__Execution::startDate);
	soap_serialize_PointerToLONG64(soap, &this->ns1__Execution::endDate);
	/* transient soap skipped */
}

int ns1__Execution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Execution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Execution(struct soap *soap, const char *tag, int id, const ns1__Execution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Execution), "ns1:Execution"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "identifier", -1, &(a->ns1__Execution::identifier), ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns1__Execution::name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "pipelineIdentifier", -1, &(a->ns1__Execution::pipelineIdentifier), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "timeout", -1, &(a->ns1__Execution::timeout), ""))
		return soap->error;
	if (soap_out_ns1__ExecutionStatus(soap, "status", -1, &(a->ns1__Execution::status), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, "inputValue", -1, &(a->ns1__Execution::inputValue), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, "returnedFile", -1, &(a->ns1__Execution::returnedFile), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "studyIdentifier", -1, &(a->ns1__Execution::studyIdentifier), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "errorCode", -1, &(a->ns1__Execution::errorCode), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "startDate", -1, &(a->ns1__Execution::startDate), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "endDate", -1, &(a->ns1__Execution::endDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Execution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Execution(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Execution * SOAP_FMAC4 soap_in_ns1__Execution(struct soap *soap, const char *tag, ns1__Execution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Execution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Execution, sizeof(ns1__Execution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Execution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Execution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_identifier1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_pipelineIdentifier1 = 1;
	size_t soap_flag_timeout1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_studyIdentifier1 = 1;
	size_t soap_flag_errorCode1 = 1;
	size_t soap_flag_startDate1 = 1;
	size_t soap_flag_endDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "identifier", &(a->ns1__Execution::identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns1__Execution::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_pipelineIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pipelineIdentifier", &(a->ns1__Execution::pipelineIdentifier), "xsd:string"))
				{	soap_flag_pipelineIdentifier1--;
					continue;
				}
			if (soap_flag_timeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "timeout", &(a->ns1__Execution::timeout), "xsd:int"))
				{	soap_flag_timeout1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__ExecutionStatus(soap, "status", &(a->ns1__Execution::status), "ns1:ExecutionStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, "inputValue", &(a->ns1__Execution::inputValue), "ns1:StringKeyParameterValuePair"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, "returnedFile", &(a->ns1__Execution::returnedFile), "ns1:StringKeyParameterValuePair"))
					continue;
			if (soap_flag_studyIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "studyIdentifier", &(a->ns1__Execution::studyIdentifier), "xsd:string"))
				{	soap_flag_studyIdentifier1--;
					continue;
				}
			if (soap_flag_errorCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "errorCode", &(a->ns1__Execution::errorCode), "xsd:int"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "startDate", &(a->ns1__Execution::startDate), "xsd:long"))
				{	soap_flag_startDate1--;
					continue;
				}
			if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "endDate", &(a->ns1__Execution::endDate), "xsd:long"))
				{	soap_flag_endDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Execution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Execution, 0, sizeof(ns1__Execution), 0, soap_copy_ns1__Execution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_identifier1 > 0 || soap_flag_name1 > 0 || soap_flag_pipelineIdentifier1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Execution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Execution);
	if (this->soap_out(soap, tag?tag:"ns1:Execution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Execution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Execution(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Execution * SOAP_FMAC4 soap_get_ns1__Execution(struct soap *soap, ns1__Execution *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Execution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Execution * SOAP_FMAC2 soap_instantiate_ns1__Execution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Execution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Execution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Execution);
		if (size)
			*size = sizeof(ns1__Execution);
		((ns1__Execution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Execution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Execution);
		for (int i = 0; i < n; i++)
			((ns1__Execution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Execution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Execution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Execution %p -> %p\n", q, p));
	*(ns1__Execution*)p = *(ns1__Execution*)q;
}

void ns1__IntKeyStringValuePair::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__IntKeyStringValuePair::name);
	soap_default_std__string(soap, &this->ns1__IntKeyStringValuePair::value);
	/* transient soap skipped */
}

void ns1__IntKeyStringValuePair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__IntKeyStringValuePair::name, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns1__IntKeyStringValuePair::value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__IntKeyStringValuePair::value);
	/* transient soap skipped */
}

int ns1__IntKeyStringValuePair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__IntKeyStringValuePair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__IntKeyStringValuePair(struct soap *soap, const char *tag, int id, const ns1__IntKeyStringValuePair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__IntKeyStringValuePair), type))
		return soap->error;
	if (soap_out_int(soap, "name", -1, &(a->ns1__IntKeyStringValuePair::name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "value", -1, &(a->ns1__IntKeyStringValuePair::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__IntKeyStringValuePair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__IntKeyStringValuePair(soap, tag, this, type);
}

SOAP_FMAC3 ns1__IntKeyStringValuePair * SOAP_FMAC4 soap_in_ns1__IntKeyStringValuePair(struct soap *soap, const char *tag, ns1__IntKeyStringValuePair *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__IntKeyStringValuePair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__IntKeyStringValuePair, sizeof(ns1__IntKeyStringValuePair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__IntKeyStringValuePair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__IntKeyStringValuePair *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "name", &(a->ns1__IntKeyStringValuePair::name), "xsd:int"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "value", &(a->ns1__IntKeyStringValuePair::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__IntKeyStringValuePair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__IntKeyStringValuePair, 0, sizeof(ns1__IntKeyStringValuePair), 0, soap_copy_ns1__IntKeyStringValuePair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__IntKeyStringValuePair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__IntKeyStringValuePair);
	if (this->soap_out(soap, tag?tag:"ns1:IntKeyStringValuePair", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__IntKeyStringValuePair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__IntKeyStringValuePair(soap, this, tag, type);
}

SOAP_FMAC3 ns1__IntKeyStringValuePair * SOAP_FMAC4 soap_get_ns1__IntKeyStringValuePair(struct soap *soap, ns1__IntKeyStringValuePair *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__IntKeyStringValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__IntKeyStringValuePair * SOAP_FMAC2 soap_instantiate_ns1__IntKeyStringValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__IntKeyStringValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__IntKeyStringValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__IntKeyStringValuePair);
		if (size)
			*size = sizeof(ns1__IntKeyStringValuePair);
		((ns1__IntKeyStringValuePair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__IntKeyStringValuePair[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__IntKeyStringValuePair);
		for (int i = 0; i < n; i++)
			((ns1__IntKeyStringValuePair*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__IntKeyStringValuePair*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__IntKeyStringValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__IntKeyStringValuePair %p -> %p\n", q, p));
	*(ns1__IntKeyStringValuePair*)p = *(ns1__IntKeyStringValuePair*)q;
}

void ns1__ParameterTypedValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__ParameterType(soap, &this->ns1__ParameterTypedValue::type);
	this->ns1__ParameterTypedValue::__union_ParameterTypedValue = 0;
	/* transient soap skipped */
}

void ns1__ParameterTypedValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns1__union_ParameterTypedValue(soap, this->ns1__ParameterTypedValue::__union_ParameterTypedValue, &this->ns1__ParameterTypedValue::union_ParameterTypedValue);
	/* transient soap skipped */
}

int ns1__ParameterTypedValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ParameterTypedValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ParameterTypedValue(struct soap *soap, const char *tag, int id, const ns1__ParameterTypedValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ParameterTypedValue), type))
		return soap->error;
	if (soap_out_ns1__ParameterType(soap, "type", -1, &(a->ns1__ParameterTypedValue::type), ""))
		return soap->error;
	if (soap_out__ns1__union_ParameterTypedValue(soap, a->ns1__ParameterTypedValue::__union_ParameterTypedValue, &a->ns1__ParameterTypedValue::union_ParameterTypedValue))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ParameterTypedValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ParameterTypedValue(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ParameterTypedValue * SOAP_FMAC4 soap_in_ns1__ParameterTypedValue(struct soap *soap, const char *tag, ns1__ParameterTypedValue *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ParameterTypedValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ParameterTypedValue, sizeof(ns1__ParameterTypedValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ParameterTypedValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ParameterTypedValue *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_union_ParameterTypedValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__ParameterType(soap, "type", &(a->ns1__ParameterTypedValue::type), "ns1:ParameterType"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_union_ParameterTypedValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__union_ParameterTypedValue(soap, &a->ns1__ParameterTypedValue::__union_ParameterTypedValue, &a->ns1__ParameterTypedValue::union_ParameterTypedValue))
				{	soap_flag_union_ParameterTypedValue1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ParameterTypedValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ParameterTypedValue, 0, sizeof(ns1__ParameterTypedValue), 0, soap_copy_ns1__ParameterTypedValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0 || soap_flag_union_ParameterTypedValue1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ParameterTypedValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ParameterTypedValue);
	if (this->soap_out(soap, tag?tag:"ns1:ParameterTypedValue", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ParameterTypedValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ParameterTypedValue(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ParameterTypedValue * SOAP_FMAC4 soap_get_ns1__ParameterTypedValue(struct soap *soap, ns1__ParameterTypedValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ParameterTypedValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ParameterTypedValue * SOAP_FMAC2 soap_instantiate_ns1__ParameterTypedValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ParameterTypedValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ParameterTypedValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ParameterTypedValue);
		if (size)
			*size = sizeof(ns1__ParameterTypedValue);
		((ns1__ParameterTypedValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ParameterTypedValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ParameterTypedValue);
		for (int i = 0; i < n; i++)
			((ns1__ParameterTypedValue*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ParameterTypedValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ParameterTypedValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ParameterTypedValue %p -> %p\n", q, p));
	*(ns1__ParameterTypedValue*)p = *(ns1__ParameterTypedValue*)q;
}

void ns1__PipelineParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__PipelineParameter::name);
	soap_default_ns1__ParameterType(soap, &this->ns1__PipelineParameter::type);
	soap_default_bool(soap, &this->ns1__PipelineParameter::isOptional);
	soap_default_bool(soap, &this->ns1__PipelineParameter::isReturnedValue);
	this->ns1__PipelineParameter::defaultValue = NULL;
	this->ns1__PipelineParameter::description = NULL;
	/* transient soap skipped */
}

void ns1__PipelineParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__PipelineParameter::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PipelineParameter::name);
	soap_embedded(soap, &this->ns1__PipelineParameter::isOptional, SOAP_TYPE_bool);
	soap_embedded(soap, &this->ns1__PipelineParameter::isReturnedValue, SOAP_TYPE_bool);
	soap_serialize_PointerTons1__ParameterTypedValue(soap, &this->ns1__PipelineParameter::defaultValue);
	soap_serialize_PointerTostd__string(soap, &this->ns1__PipelineParameter::description);
	/* transient soap skipped */
}

int ns1__PipelineParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PipelineParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PipelineParameter(struct soap *soap, const char *tag, int id, const ns1__PipelineParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PipelineParameter), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns1__PipelineParameter::name), ""))
		return soap->error;
	if (soap_out_ns1__ParameterType(soap, "type", -1, &(a->ns1__PipelineParameter::type), ""))
		return soap->error;
	if (soap_out_bool(soap, "isOptional", -1, &(a->ns1__PipelineParameter::isOptional), ""))
		return soap->error;
	if (soap_out_bool(soap, "isReturnedValue", -1, &(a->ns1__PipelineParameter::isReturnedValue), ""))
		return soap->error;
	if (soap_out_PointerTons1__ParameterTypedValue(soap, "defaultValue", -1, &(a->ns1__PipelineParameter::defaultValue), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__PipelineParameter::description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PipelineParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PipelineParameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PipelineParameter * SOAP_FMAC4 soap_in_ns1__PipelineParameter(struct soap *soap, const char *tag, ns1__PipelineParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PipelineParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PipelineParameter, sizeof(ns1__PipelineParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PipelineParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PipelineParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_isOptional1 = 1;
	size_t soap_flag_isReturnedValue1 = 1;
	size_t soap_flag_defaultValue1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns1__PipelineParameter::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__ParameterType(soap, "type", &(a->ns1__PipelineParameter::type), "ns1:ParameterType"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_isOptional1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isOptional", &(a->ns1__PipelineParameter::isOptional), "xsd:boolean"))
				{	soap_flag_isOptional1--;
					continue;
				}
			if (soap_flag_isReturnedValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isReturnedValue", &(a->ns1__PipelineParameter::isReturnedValue), "xsd:boolean"))
				{	soap_flag_isReturnedValue1--;
					continue;
				}
			if (soap_flag_defaultValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ParameterTypedValue(soap, "defaultValue", &(a->ns1__PipelineParameter::defaultValue), "ns1:ParameterTypedValue"))
				{	soap_flag_defaultValue1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__PipelineParameter::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PipelineParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PipelineParameter, 0, sizeof(ns1__PipelineParameter), 0, soap_copy_ns1__PipelineParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_type1 > 0 || soap_flag_isOptional1 > 0 || soap_flag_isReturnedValue1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PipelineParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PipelineParameter);
	if (this->soap_out(soap, tag?tag:"ns1:PipelineParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PipelineParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PipelineParameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PipelineParameter * SOAP_FMAC4 soap_get_ns1__PipelineParameter(struct soap *soap, ns1__PipelineParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PipelineParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PipelineParameter * SOAP_FMAC2 soap_instantiate_ns1__PipelineParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PipelineParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PipelineParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PipelineParameter);
		if (size)
			*size = sizeof(ns1__PipelineParameter);
		((ns1__PipelineParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PipelineParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PipelineParameter);
		for (int i = 0; i < n; i++)
			((ns1__PipelineParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PipelineParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PipelineParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PipelineParameter %p -> %p\n", q, p));
	*(ns1__PipelineParameter*)p = *(ns1__PipelineParameter*)q;
}

void ns1__ArrayOfExecutions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Execution(soap, &this->ns1__ArrayOfExecutions::item);
	/* transient soap skipped */
}

void ns1__ArrayOfExecutions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Execution(soap, &this->ns1__ArrayOfExecutions::item);
	/* transient soap skipped */
}

int ns1__ArrayOfExecutions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfExecutions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfExecutions(struct soap *soap, const char *tag, int id, const ns1__ArrayOfExecutions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfExecutions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Execution(soap, "item", -1, &(a->ns1__ArrayOfExecutions::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfExecutions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfExecutions(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfExecutions * SOAP_FMAC4 soap_in_ns1__ArrayOfExecutions(struct soap *soap, const char *tag, ns1__ArrayOfExecutions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfExecutions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfExecutions, sizeof(ns1__ArrayOfExecutions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfExecutions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfExecutions *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Execution(soap, "item", &(a->ns1__ArrayOfExecutions::item), "ns1:Execution"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfExecutions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfExecutions, 0, sizeof(ns1__ArrayOfExecutions), 0, soap_copy_ns1__ArrayOfExecutions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfExecutions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfExecutions);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfExecutions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfExecutions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfExecutions(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfExecutions * SOAP_FMAC4 soap_get_ns1__ArrayOfExecutions(struct soap *soap, ns1__ArrayOfExecutions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfExecutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfExecutions * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfExecutions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfExecutions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfExecutions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfExecutions);
		if (size)
			*size = sizeof(ns1__ArrayOfExecutions);
		((ns1__ArrayOfExecutions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfExecutions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfExecutions);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfExecutions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfExecutions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfExecutions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfExecutions %p -> %p\n", q, p));
	*(ns1__ArrayOfExecutions*)p = *(ns1__ArrayOfExecutions*)q;
}

void ns1__ArrayOfPipelines::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Pipeline(soap, &this->ns1__ArrayOfPipelines::item);
	/* transient soap skipped */
}

void ns1__ArrayOfPipelines::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Pipeline(soap, &this->ns1__ArrayOfPipelines::item);
	/* transient soap skipped */
}

int ns1__ArrayOfPipelines::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfPipelines(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPipelines(struct soap *soap, const char *tag, int id, const ns1__ArrayOfPipelines *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPipelines), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Pipeline(soap, "item", -1, &(a->ns1__ArrayOfPipelines::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfPipelines::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfPipelines(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfPipelines * SOAP_FMAC4 soap_in_ns1__ArrayOfPipelines(struct soap *soap, const char *tag, ns1__ArrayOfPipelines *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfPipelines *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPipelines, sizeof(ns1__ArrayOfPipelines), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfPipelines)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfPipelines *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Pipeline(soap, "item", &(a->ns1__ArrayOfPipelines::item), "ns1:Pipeline"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfPipelines *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPipelines, 0, sizeof(ns1__ArrayOfPipelines), 0, soap_copy_ns1__ArrayOfPipelines);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfPipelines::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPipelines);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfPipelines", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfPipelines::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfPipelines(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfPipelines * SOAP_FMAC4 soap_get_ns1__ArrayOfPipelines(struct soap *soap, ns1__ArrayOfPipelines *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPipelines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfPipelines * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfPipelines(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfPipelines(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfPipelines, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPipelines);
		if (size)
			*size = sizeof(ns1__ArrayOfPipelines);
		((ns1__ArrayOfPipelines*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfPipelines[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfPipelines);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfPipelines*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfPipelines*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfPipelines(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfPipelines %p -> %p\n", q, p));
	*(ns1__ArrayOfPipelines*)p = *(ns1__ArrayOfPipelines*)q;
}

void ns1__ArrayOfStrings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__ArrayOfStrings::item);
	/* transient soap skipped */
}

void ns1__ArrayOfStrings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__ArrayOfStrings::item);
	/* transient soap skipped */
}

int ns1__ArrayOfStrings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfStrings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfStrings(struct soap *soap, const char *tag, int id, const ns1__ArrayOfStrings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfStrings), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "item", -1, &(a->ns1__ArrayOfStrings::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfStrings::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfStrings(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfStrings * SOAP_FMAC4 soap_in_ns1__ArrayOfStrings(struct soap *soap, const char *tag, ns1__ArrayOfStrings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfStrings *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfStrings, sizeof(ns1__ArrayOfStrings), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfStrings)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfStrings *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "item", &(a->ns1__ArrayOfStrings::item), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfStrings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfStrings, 0, sizeof(ns1__ArrayOfStrings), 0, soap_copy_ns1__ArrayOfStrings);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfStrings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfStrings);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfStrings", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfStrings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfStrings(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfStrings * SOAP_FMAC4 soap_get_ns1__ArrayOfStrings(struct soap *soap, ns1__ArrayOfStrings *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfStrings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfStrings * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfStrings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfStrings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfStrings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfStrings);
		if (size)
			*size = sizeof(ns1__ArrayOfStrings);
		((ns1__ArrayOfStrings*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfStrings[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfStrings);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfStrings*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfStrings*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfStrings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfStrings %p -> %p\n", q, p));
	*(ns1__ArrayOfStrings*)p = *(ns1__ArrayOfStrings*)q;
}

void ns1__Object::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__Object::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__Object::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Object(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Object(struct soap *soap, const char *tag, int id, const ns1__Object *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Object), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Object::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Object(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Object * SOAP_FMAC4 soap_in_ns1__Object(struct soap *soap, const char *tag, ns1__Object *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Object *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Object, sizeof(ns1__Object), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Object)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Object *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Object *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Object, 0, sizeof(ns1__Object), 0, soap_copy_ns1__Object);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Object::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Object);
	if (this->soap_out(soap, tag?tag:"ns1:Object", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Object::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Object(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Object * SOAP_FMAC4 soap_get_ns1__Object(struct soap *soap, ns1__Object *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Object * SOAP_FMAC2 soap_instantiate_ns1__Object(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Object(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Object, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:Pipeline"))
	{	cp->type = SOAP_TYPE_ns1__Pipeline;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__Pipeline);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__Pipeline);
			((ns1__Pipeline*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__Pipeline[n]);
			if (size)
				*size = n * sizeof(ns1__Pipeline);
			for (int i = 0; i < n; i++)
				((ns1__Pipeline*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__Pipeline*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Execution"))
	{	cp->type = SOAP_TYPE_ns1__Execution;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__Execution);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__Execution);
			((ns1__Execution*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__Execution[n]);
			if (size)
				*size = n * sizeof(ns1__Execution);
			for (int i = 0; i < n; i++)
				((ns1__Execution*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__Execution*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:GlobalProperties"))
	{	cp->type = SOAP_TYPE_ns1__GlobalProperties;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__GlobalProperties);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__GlobalProperties);
			((ns1__GlobalProperties*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__GlobalProperties[n]);
			if (size)
				*size = n * sizeof(ns1__GlobalProperties);
			for (int i = 0; i < n; i++)
				((ns1__GlobalProperties*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__GlobalProperties*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Object);
		if (size)
			*size = sizeof(ns1__Object);
		((ns1__Object*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Object[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Object);
		for (int i = 0; i < n; i++)
			((ns1__Object*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Object*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Object(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Object %p -> %p\n", q, p));
	*(ns1__Object*)p = *(ns1__Object*)q;
}

void ns1__Pipeline::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Pipeline::identifier);
	soap_default_std__string(soap, &this->ns1__Pipeline::name);
	this->ns1__Pipeline::description = NULL;
	soap_default_std__string(soap, &this->ns1__Pipeline::version);
	soap_default_std__vectorTemplateOfPointerTons1__PipelineParameter(soap, &this->ns1__Pipeline::parameters);
	soap_default_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(soap, &this->ns1__Pipeline::errorCodesAndMessages);
	this->ns1__Pipeline::canExecute = NULL;
	/* transient soap skipped */
}

void ns1__Pipeline::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__Pipeline::identifier, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Pipeline::identifier);
	soap_embedded(soap, &this->ns1__Pipeline::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Pipeline::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Pipeline::description);
	soap_embedded(soap, &this->ns1__Pipeline::version, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Pipeline::version);
	soap_serialize_std__vectorTemplateOfPointerTons1__PipelineParameter(soap, &this->ns1__Pipeline::parameters);
	soap_serialize_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(soap, &this->ns1__Pipeline::errorCodesAndMessages);
	soap_serialize_PointerTobool(soap, &this->ns1__Pipeline::canExecute);
	/* transient soap skipped */
}

int ns1__Pipeline::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Pipeline(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Pipeline(struct soap *soap, const char *tag, int id, const ns1__Pipeline *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Pipeline), "ns1:Pipeline"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "identifier", -1, &(a->ns1__Pipeline::identifier), ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns1__Pipeline::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__Pipeline::description), ""))
		return soap->error;
	if (soap_out_std__string(soap, "version", -1, &(a->ns1__Pipeline::version), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__PipelineParameter(soap, "parameters", -1, &(a->ns1__Pipeline::parameters), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(soap, "errorCodesAndMessages", -1, &(a->ns1__Pipeline::errorCodesAndMessages), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "canExecute", -1, &(a->ns1__Pipeline::canExecute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Pipeline::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Pipeline(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Pipeline * SOAP_FMAC4 soap_in_ns1__Pipeline(struct soap *soap, const char *tag, ns1__Pipeline *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Pipeline *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Pipeline, sizeof(ns1__Pipeline), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Pipeline)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Pipeline *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_identifier1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_canExecute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "identifier", &(a->ns1__Pipeline::identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns1__Pipeline::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__Pipeline::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "version", &(a->ns1__Pipeline::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__PipelineParameter(soap, "parameters", &(a->ns1__Pipeline::parameters), "ns1:PipelineParameter"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(soap, "errorCodesAndMessages", &(a->ns1__Pipeline::errorCodesAndMessages), "ns1:IntKeyStringValuePair"))
					continue;
			if (soap_flag_canExecute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "canExecute", &(a->ns1__Pipeline::canExecute), "xsd:boolean"))
				{	soap_flag_canExecute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Pipeline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Pipeline, 0, sizeof(ns1__Pipeline), 0, soap_copy_ns1__Pipeline);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_identifier1 > 0 || soap_flag_name1 > 0 || soap_flag_version1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Pipeline::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Pipeline);
	if (this->soap_out(soap, tag?tag:"ns1:Pipeline", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Pipeline::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Pipeline(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Pipeline * SOAP_FMAC4 soap_get_ns1__Pipeline(struct soap *soap, ns1__Pipeline *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Pipeline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Pipeline * SOAP_FMAC2 soap_instantiate_ns1__Pipeline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Pipeline(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Pipeline, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Pipeline);
		if (size)
			*size = sizeof(ns1__Pipeline);
		((ns1__Pipeline*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Pipeline[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Pipeline);
		for (int i = 0; i < n; i++)
			((ns1__Pipeline*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Pipeline*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Pipeline(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Pipeline %p -> %p\n", q, p));
	*(ns1__Pipeline*)p = *(ns1__Pipeline*)q;
}

void ns1__Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__Response::statusCode);
	this->ns1__Response::errorMessage = NULL;
	this->ns1__Response::__union_Response = 0;
	/* transient soap skipped */
}

void ns1__Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__Response::statusCode, SOAP_TYPE_int);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Response::errorMessage);
	soap_serialize__ns1__union_Response(soap, this->ns1__Response::__union_Response, &this->ns1__Response::union_Response);
	/* transient soap skipped */
}

int ns1__Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Response(struct soap *soap, const char *tag, int id, const ns1__Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Response), type))
		return soap->error;
	if (soap_out_int(soap, "statusCode", -1, &(a->ns1__Response::statusCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "errorMessage", -1, &(a->ns1__Response::errorMessage), ""))
		return soap->error;
	if (soap_out__ns1__union_Response(soap, a->ns1__Response::__union_Response, &a->ns1__Response::union_Response))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Response(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Response * SOAP_FMAC4 soap_in_ns1__Response(struct soap *soap, const char *tag, ns1__Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Response, sizeof(ns1__Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_statusCode1 = 1;
	size_t soap_flag_errorMessage1 = 1;
	size_t soap_flag_union_Response1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "statusCode", &(a->ns1__Response::statusCode), "xsd:int"))
				{	soap_flag_statusCode1--;
					continue;
				}
			if (soap_flag_errorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "errorMessage", &(a->ns1__Response::errorMessage), "xsd:string"))
				{	soap_flag_errorMessage1--;
					continue;
				}
			if (soap_flag_union_Response1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__union_Response(soap, &a->ns1__Response::__union_Response, &a->ns1__Response::union_Response))
				{	soap_flag_union_Response1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Response, 0, sizeof(ns1__Response), 0, soap_copy_ns1__Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_statusCode1 > 0 || soap_flag_union_Response1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Response);
	if (this->soap_out(soap, tag?tag:"ns1:Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Response(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Response * SOAP_FMAC4 soap_get_ns1__Response(struct soap *soap, ns1__Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Response * SOAP_FMAC2 soap_instantiate_ns1__Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Response);
		if (size)
			*size = sizeof(ns1__Response);
		((ns1__Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Response);
		for (int i = 0; i < n; i++)
			((ns1__Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Response %p -> %p\n", q, p));
	*(ns1__Response*)p = *(ns1__Response*)q;
}

void ns1__authenticateSessionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__authenticateSessionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__authenticateSessionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Response(soap, &this->ns1__authenticateSessionResponse::return_);
	/* transient soap skipped */
}

int ns1__authenticateSessionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateSessionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateSessionResponse(struct soap *soap, const char *tag, int id, const ns1__authenticateSessionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateSessionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Response(soap, "return", -1, &(a->ns1__authenticateSessionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateSessionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateSessionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateSessionResponse * SOAP_FMAC4 soap_in_ns1__authenticateSessionResponse(struct soap *soap, const char *tag, ns1__authenticateSessionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateSessionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateSessionResponse, sizeof(ns1__authenticateSessionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateSessionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateSessionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Response(soap, "return", &(a->ns1__authenticateSessionResponse::return_), "ns1:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateSessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateSessionResponse, 0, sizeof(ns1__authenticateSessionResponse), 0, soap_copy_ns1__authenticateSessionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__authenticateSessionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateSessionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateSessionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateSessionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateSessionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateSessionResponse * SOAP_FMAC4 soap_get_ns1__authenticateSessionResponse(struct soap *soap, ns1__authenticateSessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateSessionResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateSessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateSessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateSessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateSessionResponse);
		if (size)
			*size = sizeof(ns1__authenticateSessionResponse);
		((ns1__authenticateSessionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateSessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__authenticateSessionResponse);
		for (int i = 0; i < n; i++)
			((ns1__authenticateSessionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__authenticateSessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateSessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateSessionResponse %p -> %p\n", q, p));
	*(ns1__authenticateSessionResponse*)p = *(ns1__authenticateSessionResponse*)q;
}

void ns1__authenticateSession::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__authenticateSession::userName);
	soap_default_std__string(soap, &this->ns1__authenticateSession::password);
	/* transient soap skipped */
}

void ns1__authenticateSession::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__authenticateSession::userName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__authenticateSession::userName);
	soap_embedded(soap, &this->ns1__authenticateSession::password, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__authenticateSession::password);
	/* transient soap skipped */
}

int ns1__authenticateSession::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateSession(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateSession(struct soap *soap, const char *tag, int id, const ns1__authenticateSession *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateSession), type))
		return soap->error;
	if (soap_out_std__string(soap, "userName", -1, &(a->ns1__authenticateSession::userName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "password", -1, &(a->ns1__authenticateSession::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateSession::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateSession(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateSession * SOAP_FMAC4 soap_in_ns1__authenticateSession(struct soap *soap, const char *tag, ns1__authenticateSession *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateSession *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateSession, sizeof(ns1__authenticateSession), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateSession)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateSession *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userName", &(a->ns1__authenticateSession::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "password", &(a->ns1__authenticateSession::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateSession *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateSession, 0, sizeof(ns1__authenticateSession), 0, soap_copy_ns1__authenticateSession);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userName1 > 0 || soap_flag_password1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__authenticateSession::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateSession);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateSession", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateSession::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateSession(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateSession * SOAP_FMAC4 soap_get_ns1__authenticateSession(struct soap *soap, ns1__authenticateSession *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateSession * SOAP_FMAC2 soap_instantiate_ns1__authenticateSession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateSession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateSession, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateSession);
		if (size)
			*size = sizeof(ns1__authenticateSession);
		((ns1__authenticateSession*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateSession[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__authenticateSession);
		for (int i = 0; i < n; i++)
			((ns1__authenticateSession*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__authenticateSession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateSession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateSession %p -> %p\n", q, p));
	*(ns1__authenticateSession*)p = *(ns1__authenticateSession*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listExecutions(struct soap *soap, struct __ns1__listExecutions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__listExecutions_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listExecutions(struct soap *soap, const struct __ns1__listExecutions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__listExecutions(soap, &a->ns1__listExecutions_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listExecutions(struct soap *soap, const char *tag, int id, const struct __ns1__listExecutions *a, const char *type)
{
	if (soap_out_PointerTons1__listExecutions(soap, "ns1:listExecutions", -1, &a->ns1__listExecutions_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listExecutions * SOAP_FMAC4 soap_in___ns1__listExecutions(struct soap *soap, const char *tag, struct __ns1__listExecutions *a, const char *type)
{
	size_t soap_flag_ns1__listExecutions_ = 1;
	short soap_flag;
	a = (struct __ns1__listExecutions *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listExecutions, sizeof(struct __ns1__listExecutions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listExecutions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__listExecutions_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listExecutions(soap, "ns1:listExecutions", &a->ns1__listExecutions_, "ns1:listExecutions"))
				{	soap_flag_ns1__listExecutions_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listExecutions(struct soap *soap, const struct __ns1__listExecutions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listExecutions(soap, tag?tag:"-ns1:listExecutions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listExecutions * SOAP_FMAC4 soap_get___ns1__listExecutions(struct soap *soap, struct __ns1__listExecutions *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listExecutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__listExecutions * SOAP_FMAC2 soap_instantiate___ns1__listExecutions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__listExecutions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__listExecutions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listExecutions);
		if (size)
			*size = sizeof(struct __ns1__listExecutions);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listExecutions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__listExecutions);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__listExecutions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__listExecutions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__listExecutions %p -> %p\n", q, p));
	*(struct __ns1__listExecutions*)p = *(struct __ns1__listExecutions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__listPipelines(struct soap *soap, struct __ns1__listPipelines *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__listPipelines_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__listPipelines(struct soap *soap, const struct __ns1__listPipelines *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__listPipelines(soap, &a->ns1__listPipelines_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__listPipelines(struct soap *soap, const char *tag, int id, const struct __ns1__listPipelines *a, const char *type)
{
	if (soap_out_PointerTons1__listPipelines(soap, "ns1:listPipelines", -1, &a->ns1__listPipelines_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listPipelines * SOAP_FMAC4 soap_in___ns1__listPipelines(struct soap *soap, const char *tag, struct __ns1__listPipelines *a, const char *type)
{
	size_t soap_flag_ns1__listPipelines_ = 1;
	short soap_flag;
	a = (struct __ns1__listPipelines *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__listPipelines, sizeof(struct __ns1__listPipelines), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__listPipelines(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__listPipelines_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__listPipelines(soap, "ns1:listPipelines", &a->ns1__listPipelines_, "ns1:listPipelines"))
				{	soap_flag_ns1__listPipelines_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__listPipelines(struct soap *soap, const struct __ns1__listPipelines *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__listPipelines(soap, tag?tag:"-ns1:listPipelines", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__listPipelines * SOAP_FMAC4 soap_get___ns1__listPipelines(struct soap *soap, struct __ns1__listPipelines *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__listPipelines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__listPipelines * SOAP_FMAC2 soap_instantiate___ns1__listPipelines(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__listPipelines(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__listPipelines, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listPipelines);
		if (size)
			*size = sizeof(struct __ns1__listPipelines);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__listPipelines[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__listPipelines);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__listPipelines*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__listPipelines(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__listPipelines %p -> %p\n", q, p));
	*(struct __ns1__listPipelines*)p = *(struct __ns1__listPipelines*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__playExecution(struct soap *soap, struct __ns1__playExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__playExecution_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__playExecution(struct soap *soap, const struct __ns1__playExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__playExecution(soap, &a->ns1__playExecution_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__playExecution(struct soap *soap, const char *tag, int id, const struct __ns1__playExecution *a, const char *type)
{
	if (soap_out_PointerTons1__playExecution(soap, "ns1:playExecution", -1, &a->ns1__playExecution_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__playExecution * SOAP_FMAC4 soap_in___ns1__playExecution(struct soap *soap, const char *tag, struct __ns1__playExecution *a, const char *type)
{
	size_t soap_flag_ns1__playExecution_ = 1;
	short soap_flag;
	a = (struct __ns1__playExecution *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__playExecution, sizeof(struct __ns1__playExecution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__playExecution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__playExecution_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__playExecution(soap, "ns1:playExecution", &a->ns1__playExecution_, "ns1:playExecution"))
				{	soap_flag_ns1__playExecution_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__playExecution(struct soap *soap, const struct __ns1__playExecution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__playExecution(soap, tag?tag:"-ns1:playExecution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__playExecution * SOAP_FMAC4 soap_get___ns1__playExecution(struct soap *soap, struct __ns1__playExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__playExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__playExecution * SOAP_FMAC2 soap_instantiate___ns1__playExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__playExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__playExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__playExecution);
		if (size)
			*size = sizeof(struct __ns1__playExecution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__playExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__playExecution);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__playExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__playExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__playExecution %p -> %p\n", q, p));
	*(struct __ns1__playExecution*)p = *(struct __ns1__playExecution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getExecution(struct soap *soap, struct __ns1__getExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getExecution_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getExecution(struct soap *soap, const struct __ns1__getExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getExecution(soap, &a->ns1__getExecution_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getExecution(struct soap *soap, const char *tag, int id, const struct __ns1__getExecution *a, const char *type)
{
	if (soap_out_PointerTons1__getExecution(soap, "ns1:getExecution", -1, &a->ns1__getExecution_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getExecution * SOAP_FMAC4 soap_in___ns1__getExecution(struct soap *soap, const char *tag, struct __ns1__getExecution *a, const char *type)
{
	size_t soap_flag_ns1__getExecution_ = 1;
	short soap_flag;
	a = (struct __ns1__getExecution *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getExecution, sizeof(struct __ns1__getExecution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getExecution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getExecution_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getExecution(soap, "ns1:getExecution", &a->ns1__getExecution_, "ns1:getExecution"))
				{	soap_flag_ns1__getExecution_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getExecution(struct soap *soap, const struct __ns1__getExecution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getExecution(soap, tag?tag:"-ns1:getExecution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getExecution * SOAP_FMAC4 soap_get___ns1__getExecution(struct soap *soap, struct __ns1__getExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getExecution * SOAP_FMAC2 soap_instantiate___ns1__getExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getExecution);
		if (size)
			*size = sizeof(struct __ns1__getExecution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getExecution);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getExecution %p -> %p\n", q, p));
	*(struct __ns1__getExecution*)p = *(struct __ns1__getExecution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__killExecution(struct soap *soap, struct __ns1__killExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__killExecution_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__killExecution(struct soap *soap, const struct __ns1__killExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__killExecution(soap, &a->ns1__killExecution_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__killExecution(struct soap *soap, const char *tag, int id, const struct __ns1__killExecution *a, const char *type)
{
	if (soap_out_PointerTons1__killExecution(soap, "ns1:killExecution", -1, &a->ns1__killExecution_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__killExecution * SOAP_FMAC4 soap_in___ns1__killExecution(struct soap *soap, const char *tag, struct __ns1__killExecution *a, const char *type)
{
	size_t soap_flag_ns1__killExecution_ = 1;
	short soap_flag;
	a = (struct __ns1__killExecution *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__killExecution, sizeof(struct __ns1__killExecution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__killExecution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__killExecution_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__killExecution(soap, "ns1:killExecution", &a->ns1__killExecution_, "ns1:killExecution"))
				{	soap_flag_ns1__killExecution_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__killExecution(struct soap *soap, const struct __ns1__killExecution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__killExecution(soap, tag?tag:"-ns1:killExecution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__killExecution * SOAP_FMAC4 soap_get___ns1__killExecution(struct soap *soap, struct __ns1__killExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__killExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__killExecution * SOAP_FMAC2 soap_instantiate___ns1__killExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__killExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__killExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__killExecution);
		if (size)
			*size = sizeof(struct __ns1__killExecution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__killExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__killExecution);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__killExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__killExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__killExecution %p -> %p\n", q, p));
	*(struct __ns1__killExecution*)p = *(struct __ns1__killExecution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getExecutionResults(struct soap *soap, struct __ns1__getExecutionResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getExecutionResults_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getExecutionResults(struct soap *soap, const struct __ns1__getExecutionResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getExecutionResults(soap, &a->ns1__getExecutionResults_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getExecutionResults(struct soap *soap, const char *tag, int id, const struct __ns1__getExecutionResults *a, const char *type)
{
	if (soap_out_PointerTons1__getExecutionResults(soap, "ns1:getExecutionResults", -1, &a->ns1__getExecutionResults_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getExecutionResults * SOAP_FMAC4 soap_in___ns1__getExecutionResults(struct soap *soap, const char *tag, struct __ns1__getExecutionResults *a, const char *type)
{
	size_t soap_flag_ns1__getExecutionResults_ = 1;
	short soap_flag;
	a = (struct __ns1__getExecutionResults *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getExecutionResults, sizeof(struct __ns1__getExecutionResults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getExecutionResults(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getExecutionResults_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getExecutionResults(soap, "ns1:getExecutionResults", &a->ns1__getExecutionResults_, "ns1:getExecutionResults"))
				{	soap_flag_ns1__getExecutionResults_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getExecutionResults(struct soap *soap, const struct __ns1__getExecutionResults *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getExecutionResults(soap, tag?tag:"-ns1:getExecutionResults", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getExecutionResults * SOAP_FMAC4 soap_get___ns1__getExecutionResults(struct soap *soap, struct __ns1__getExecutionResults *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getExecutionResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getExecutionResults * SOAP_FMAC2 soap_instantiate___ns1__getExecutionResults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getExecutionResults(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getExecutionResults, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getExecutionResults);
		if (size)
			*size = sizeof(struct __ns1__getExecutionResults);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getExecutionResults[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getExecutionResults);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getExecutionResults*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getExecutionResults(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getExecutionResults %p -> %p\n", q, p));
	*(struct __ns1__getExecutionResults*)p = *(struct __ns1__getExecutionResults*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getStdErr(struct soap *soap, struct __ns1__getStdErr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getStdErr_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getStdErr(struct soap *soap, const struct __ns1__getStdErr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getStdErr(soap, &a->ns1__getStdErr_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getStdErr(struct soap *soap, const char *tag, int id, const struct __ns1__getStdErr *a, const char *type)
{
	if (soap_out_PointerTons1__getStdErr(soap, "ns1:getStdErr", -1, &a->ns1__getStdErr_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStdErr * SOAP_FMAC4 soap_in___ns1__getStdErr(struct soap *soap, const char *tag, struct __ns1__getStdErr *a, const char *type)
{
	size_t soap_flag_ns1__getStdErr_ = 1;
	short soap_flag;
	a = (struct __ns1__getStdErr *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getStdErr, sizeof(struct __ns1__getStdErr), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getStdErr(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getStdErr_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getStdErr(soap, "ns1:getStdErr", &a->ns1__getStdErr_, "ns1:getStdErr"))
				{	soap_flag_ns1__getStdErr_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getStdErr(struct soap *soap, const struct __ns1__getStdErr *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getStdErr(soap, tag?tag:"-ns1:getStdErr", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStdErr * SOAP_FMAC4 soap_get___ns1__getStdErr(struct soap *soap, struct __ns1__getStdErr *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getStdErr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getStdErr * SOAP_FMAC2 soap_instantiate___ns1__getStdErr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getStdErr(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getStdErr, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getStdErr);
		if (size)
			*size = sizeof(struct __ns1__getStdErr);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getStdErr[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getStdErr);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getStdErr*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getStdErr(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getStdErr %p -> %p\n", q, p));
	*(struct __ns1__getStdErr*)p = *(struct __ns1__getStdErr*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getStdOut(struct soap *soap, struct __ns1__getStdOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getStdOut_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getStdOut(struct soap *soap, const struct __ns1__getStdOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getStdOut(soap, &a->ns1__getStdOut_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getStdOut(struct soap *soap, const char *tag, int id, const struct __ns1__getStdOut *a, const char *type)
{
	if (soap_out_PointerTons1__getStdOut(soap, "ns1:getStdOut", -1, &a->ns1__getStdOut_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStdOut * SOAP_FMAC4 soap_in___ns1__getStdOut(struct soap *soap, const char *tag, struct __ns1__getStdOut *a, const char *type)
{
	size_t soap_flag_ns1__getStdOut_ = 1;
	short soap_flag;
	a = (struct __ns1__getStdOut *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getStdOut, sizeof(struct __ns1__getStdOut), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getStdOut(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getStdOut_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getStdOut(soap, "ns1:getStdOut", &a->ns1__getStdOut_, "ns1:getStdOut"))
				{	soap_flag_ns1__getStdOut_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getStdOut(struct soap *soap, const struct __ns1__getStdOut *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getStdOut(soap, tag?tag:"-ns1:getStdOut", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getStdOut * SOAP_FMAC4 soap_get___ns1__getStdOut(struct soap *soap, struct __ns1__getStdOut *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getStdOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getStdOut * SOAP_FMAC2 soap_instantiate___ns1__getStdOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getStdOut(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getStdOut, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getStdOut);
		if (size)
			*size = sizeof(struct __ns1__getStdOut);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getStdOut[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getStdOut);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getStdOut*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getStdOut(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getStdOut %p -> %p\n", q, p));
	*(struct __ns1__getStdOut*)p = *(struct __ns1__getStdOut*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__initExecution(struct soap *soap, struct __ns1__initExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__initExecution_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__initExecution(struct soap *soap, const struct __ns1__initExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__initExecution(soap, &a->ns1__initExecution_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__initExecution(struct soap *soap, const char *tag, int id, const struct __ns1__initExecution *a, const char *type)
{
	if (soap_out_PointerTons1__initExecution(soap, "ns1:initExecution", -1, &a->ns1__initExecution_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__initExecution * SOAP_FMAC4 soap_in___ns1__initExecution(struct soap *soap, const char *tag, struct __ns1__initExecution *a, const char *type)
{
	size_t soap_flag_ns1__initExecution_ = 1;
	short soap_flag;
	a = (struct __ns1__initExecution *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__initExecution, sizeof(struct __ns1__initExecution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__initExecution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__initExecution_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__initExecution(soap, "ns1:initExecution", &a->ns1__initExecution_, "ns1:initExecution"))
				{	soap_flag_ns1__initExecution_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__initExecution(struct soap *soap, const struct __ns1__initExecution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__initExecution(soap, tag?tag:"-ns1:initExecution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__initExecution * SOAP_FMAC4 soap_get___ns1__initExecution(struct soap *soap, struct __ns1__initExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__initExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__initExecution * SOAP_FMAC2 soap_instantiate___ns1__initExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__initExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__initExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__initExecution);
		if (size)
			*size = sizeof(struct __ns1__initExecution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__initExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__initExecution);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__initExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__initExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__initExecution %p -> %p\n", q, p));
	*(struct __ns1__initExecution*)p = *(struct __ns1__initExecution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getGlobalProperties(struct soap *soap, struct __ns1__getGlobalProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getGlobalProperties_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getGlobalProperties(struct soap *soap, const struct __ns1__getGlobalProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getGlobalProperties(soap, &a->ns1__getGlobalProperties_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getGlobalProperties(struct soap *soap, const char *tag, int id, const struct __ns1__getGlobalProperties *a, const char *type)
{
	if (soap_out_PointerTons1__getGlobalProperties(soap, "ns1:getGlobalProperties", -1, &a->ns1__getGlobalProperties_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getGlobalProperties * SOAP_FMAC4 soap_in___ns1__getGlobalProperties(struct soap *soap, const char *tag, struct __ns1__getGlobalProperties *a, const char *type)
{
	size_t soap_flag_ns1__getGlobalProperties_ = 1;
	short soap_flag;
	a = (struct __ns1__getGlobalProperties *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getGlobalProperties, sizeof(struct __ns1__getGlobalProperties), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getGlobalProperties(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getGlobalProperties_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getGlobalProperties(soap, "ns1:getGlobalProperties", &a->ns1__getGlobalProperties_, "ns1:getGlobalProperties"))
				{	soap_flag_ns1__getGlobalProperties_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getGlobalProperties(struct soap *soap, const struct __ns1__getGlobalProperties *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getGlobalProperties(soap, tag?tag:"-ns1:getGlobalProperties", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getGlobalProperties * SOAP_FMAC4 soap_get___ns1__getGlobalProperties(struct soap *soap, struct __ns1__getGlobalProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getGlobalProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getGlobalProperties * SOAP_FMAC2 soap_instantiate___ns1__getGlobalProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getGlobalProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getGlobalProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getGlobalProperties);
		if (size)
			*size = sizeof(struct __ns1__getGlobalProperties);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getGlobalProperties[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getGlobalProperties);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getGlobalProperties*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getGlobalProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getGlobalProperties %p -> %p\n", q, p));
	*(struct __ns1__getGlobalProperties*)p = *(struct __ns1__getGlobalProperties*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateExecution(struct soap *soap, struct __ns1__updateExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateExecution_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateExecution(struct soap *soap, const struct __ns1__updateExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__updateExecution(soap, &a->ns1__updateExecution_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateExecution(struct soap *soap, const char *tag, int id, const struct __ns1__updateExecution *a, const char *type)
{
	if (soap_out_PointerTons1__updateExecution(soap, "ns1:updateExecution", -1, &a->ns1__updateExecution_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateExecution * SOAP_FMAC4 soap_in___ns1__updateExecution(struct soap *soap, const char *tag, struct __ns1__updateExecution *a, const char *type)
{
	size_t soap_flag_ns1__updateExecution_ = 1;
	short soap_flag;
	a = (struct __ns1__updateExecution *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateExecution, sizeof(struct __ns1__updateExecution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateExecution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateExecution_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__updateExecution(soap, "ns1:updateExecution", &a->ns1__updateExecution_, "ns1:updateExecution"))
				{	soap_flag_ns1__updateExecution_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateExecution(struct soap *soap, const struct __ns1__updateExecution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateExecution(soap, tag?tag:"-ns1:updateExecution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateExecution * SOAP_FMAC4 soap_get___ns1__updateExecution(struct soap *soap, struct __ns1__updateExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__updateExecution * SOAP_FMAC2 soap_instantiate___ns1__updateExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateExecution);
		if (size)
			*size = sizeof(struct __ns1__updateExecution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__updateExecution);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__updateExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateExecution %p -> %p\n", q, p));
	*(struct __ns1__updateExecution*)p = *(struct __ns1__updateExecution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__logout(struct soap *soap, struct __ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__logout_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__logout(struct soap *soap, const struct __ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__logout(soap, &a->ns1__logout_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__logout(struct soap *soap, const char *tag, int id, const struct __ns1__logout *a, const char *type)
{
	if (soap_out_PointerTons1__logout(soap, "ns1:logout", -1, &a->ns1__logout_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_in___ns1__logout(struct soap *soap, const char *tag, struct __ns1__logout *a, const char *type)
{
	size_t soap_flag_ns1__logout_ = 1;
	short soap_flag;
	a = (struct __ns1__logout *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__logout, sizeof(struct __ns1__logout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__logout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__logout_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__logout(soap, "ns1:logout", &a->ns1__logout_, "ns1:logout"))
				{	soap_flag_ns1__logout_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__logout(struct soap *soap, const struct __ns1__logout *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__logout(soap, tag?tag:"-ns1:logout", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_get___ns1__logout(struct soap *soap, struct __ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__logout * SOAP_FMAC2 soap_instantiate___ns1__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__logout);
		if (size)
			*size = sizeof(struct __ns1__logout);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__logout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__logout);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__logout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__logout %p -> %p\n", q, p));
	*(struct __ns1__logout*)p = *(struct __ns1__logout*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__authenticateHTTP(struct soap *soap, struct __ns1__authenticateHTTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__authenticateHTTP_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__authenticateHTTP(struct soap *soap, const struct __ns1__authenticateHTTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__authenticateHTTP(soap, &a->ns1__authenticateHTTP_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__authenticateHTTP(struct soap *soap, const char *tag, int id, const struct __ns1__authenticateHTTP *a, const char *type)
{
	if (soap_out_PointerTons1__authenticateHTTP(soap, "ns1:authenticateHTTP", -1, &a->ns1__authenticateHTTP_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateHTTP * SOAP_FMAC4 soap_in___ns1__authenticateHTTP(struct soap *soap, const char *tag, struct __ns1__authenticateHTTP *a, const char *type)
{
	size_t soap_flag_ns1__authenticateHTTP_ = 1;
	short soap_flag;
	a = (struct __ns1__authenticateHTTP *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__authenticateHTTP, sizeof(struct __ns1__authenticateHTTP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__authenticateHTTP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__authenticateHTTP_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__authenticateHTTP(soap, "ns1:authenticateHTTP", &a->ns1__authenticateHTTP_, "ns1:authenticateHTTP"))
				{	soap_flag_ns1__authenticateHTTP_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__authenticateHTTP(struct soap *soap, const struct __ns1__authenticateHTTP *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__authenticateHTTP(soap, tag?tag:"-ns1:authenticateHTTP", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateHTTP * SOAP_FMAC4 soap_get___ns1__authenticateHTTP(struct soap *soap, struct __ns1__authenticateHTTP *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__authenticateHTTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__authenticateHTTP * SOAP_FMAC2 soap_instantiate___ns1__authenticateHTTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__authenticateHTTP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__authenticateHTTP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__authenticateHTTP);
		if (size)
			*size = sizeof(struct __ns1__authenticateHTTP);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__authenticateHTTP[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__authenticateHTTP);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__authenticateHTTP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__authenticateHTTP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__authenticateHTTP %p -> %p\n", q, p));
	*(struct __ns1__authenticateHTTP*)p = *(struct __ns1__authenticateHTTP*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPipeline(struct soap *soap, struct __ns1__getPipeline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPipeline_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPipeline(struct soap *soap, const struct __ns1__getPipeline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getPipeline(soap, &a->ns1__getPipeline_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPipeline(struct soap *soap, const char *tag, int id, const struct __ns1__getPipeline *a, const char *type)
{
	if (soap_out_PointerTons1__getPipeline(soap, "ns1:getPipeline", -1, &a->ns1__getPipeline_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPipeline * SOAP_FMAC4 soap_in___ns1__getPipeline(struct soap *soap, const char *tag, struct __ns1__getPipeline *a, const char *type)
{
	size_t soap_flag_ns1__getPipeline_ = 1;
	short soap_flag;
	a = (struct __ns1__getPipeline *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPipeline, sizeof(struct __ns1__getPipeline), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPipeline(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPipeline_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getPipeline(soap, "ns1:getPipeline", &a->ns1__getPipeline_, "ns1:getPipeline"))
				{	soap_flag_ns1__getPipeline_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPipeline(struct soap *soap, const struct __ns1__getPipeline *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPipeline(soap, tag?tag:"-ns1:getPipeline", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPipeline * SOAP_FMAC4 soap_get___ns1__getPipeline(struct soap *soap, struct __ns1__getPipeline *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPipeline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getPipeline * SOAP_FMAC2 soap_instantiate___ns1__getPipeline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPipeline(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getPipeline, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPipeline);
		if (size)
			*size = sizeof(struct __ns1__getPipeline);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPipeline[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getPipeline);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getPipeline*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getPipeline(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getPipeline %p -> %p\n", q, p));
	*(struct __ns1__getPipeline*)p = *(struct __ns1__getPipeline*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteExecution(struct soap *soap, struct __ns1__deleteExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteExecution_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteExecution(struct soap *soap, const struct __ns1__deleteExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteExecution(soap, &a->ns1__deleteExecution_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteExecution(struct soap *soap, const char *tag, int id, const struct __ns1__deleteExecution *a, const char *type)
{
	if (soap_out_PointerTons1__deleteExecution(soap, "ns1:deleteExecution", -1, &a->ns1__deleteExecution_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteExecution * SOAP_FMAC4 soap_in___ns1__deleteExecution(struct soap *soap, const char *tag, struct __ns1__deleteExecution *a, const char *type)
{
	size_t soap_flag_ns1__deleteExecution_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteExecution *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteExecution, sizeof(struct __ns1__deleteExecution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteExecution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteExecution_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteExecution(soap, "ns1:deleteExecution", &a->ns1__deleteExecution_, "ns1:deleteExecution"))
				{	soap_flag_ns1__deleteExecution_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteExecution(struct soap *soap, const struct __ns1__deleteExecution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteExecution(soap, tag?tag:"-ns1:deleteExecution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteExecution * SOAP_FMAC4 soap_get___ns1__deleteExecution(struct soap *soap, struct __ns1__deleteExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__deleteExecution * SOAP_FMAC2 soap_instantiate___ns1__deleteExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteExecution);
		if (size)
			*size = sizeof(struct __ns1__deleteExecution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__deleteExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteExecution);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteExecution %p -> %p\n", q, p));
	*(struct __ns1__deleteExecution*)p = *(struct __ns1__deleteExecution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__authenticateSession(struct soap *soap, struct __ns1__authenticateSession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__authenticateSession_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__authenticateSession(struct soap *soap, const struct __ns1__authenticateSession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__authenticateSession(soap, &a->ns1__authenticateSession_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__authenticateSession(struct soap *soap, const char *tag, int id, const struct __ns1__authenticateSession *a, const char *type)
{
	if (soap_out_PointerTons1__authenticateSession(soap, "ns1:authenticateSession", -1, &a->ns1__authenticateSession_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateSession * SOAP_FMAC4 soap_in___ns1__authenticateSession(struct soap *soap, const char *tag, struct __ns1__authenticateSession *a, const char *type)
{
	size_t soap_flag_ns1__authenticateSession_ = 1;
	short soap_flag;
	a = (struct __ns1__authenticateSession *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__authenticateSession, sizeof(struct __ns1__authenticateSession), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__authenticateSession(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__authenticateSession_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__authenticateSession(soap, "ns1:authenticateSession", &a->ns1__authenticateSession_, "ns1:authenticateSession"))
				{	soap_flag_ns1__authenticateSession_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__authenticateSession(struct soap *soap, const struct __ns1__authenticateSession *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__authenticateSession(soap, tag?tag:"-ns1:authenticateSession", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateSession * SOAP_FMAC4 soap_get___ns1__authenticateSession(struct soap *soap, struct __ns1__authenticateSession *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__authenticateSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__authenticateSession * SOAP_FMAC2 soap_instantiate___ns1__authenticateSession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__authenticateSession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__authenticateSession, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__authenticateSession);
		if (size)
			*size = sizeof(struct __ns1__authenticateSession);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__authenticateSession[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__authenticateSession);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__authenticateSession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__authenticateSession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__authenticateSession %p -> %p\n", q, p));
	*(struct __ns1__authenticateSession*)p = *(struct __ns1__authenticateSession*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_StringKeyValuePair(struct soap *soap, int choice, const union _ns1__union_StringKeyValuePair *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_StringKeyValuePair_valueStr:
		soap_serialize_PointerTostd__string(soap, &a->valueStr);
		break;
	case SOAP_UNION__ns1__union_StringKeyValuePair_valueInt:
		soap_embedded(soap, &a->valueInt, SOAP_TYPE_int);
		break;
	case SOAP_UNION__ns1__union_StringKeyValuePair_valueStatus:
		soap_embedded(soap, &a->valueStatus, SOAP_TYPE_ns1__ExecutionStatus);
		break;
	case SOAP_UNION__ns1__union_StringKeyValuePair_valueParamType:
		soap_serialize_PointerTons1__ParameterTypedValue(soap, &a->valueParamType);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_StringKeyValuePair(struct soap *soap, int choice, const union _ns1__union_StringKeyValuePair *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns1__union_StringKeyValuePair_valueStr:
		return soap_out_PointerTostd__string(soap, "valueStr", -1, &a->valueStr, "");
	case SOAP_UNION__ns1__union_StringKeyValuePair_valueInt:
		return soap_out_int(soap, "valueInt", -1, &a->valueInt, "");
	case SOAP_UNION__ns1__union_StringKeyValuePair_valueStatus:
		return soap_out_ns1__ExecutionStatus(soap, "valueStatus", -1, &a->valueStatus, "");
	case SOAP_UNION__ns1__union_StringKeyValuePair_valueParamType:
		return soap_out_PointerTons1__ParameterTypedValue(soap, "valueParamType", -1, &a->valueParamType, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_StringKeyValuePair * SOAP_FMAC4 soap_in__ns1__union_StringKeyValuePair(struct soap *soap, int *choice, union _ns1__union_StringKeyValuePair *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->valueStr = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__string(soap, "valueStr", &a->valueStr, "xsd:string"))
	{	*choice = SOAP_UNION__ns1__union_StringKeyValuePair_valueStr;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_int(soap, "valueInt", &a->valueInt, "xsd:int"))
	{	*choice = SOAP_UNION__ns1__union_StringKeyValuePair_valueInt;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns1__ExecutionStatus(soap, "valueStatus", &a->valueStatus, "ns1:ExecutionStatus"))
	{	*choice = SOAP_UNION__ns1__union_StringKeyValuePair_valueStatus;
		return a;
	}
	a->valueParamType = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ParameterTypedValue(soap, "valueParamType", &a->valueParamType, "ns1:ParameterTypedValue"))
	{	*choice = SOAP_UNION__ns1__union_StringKeyValuePair_valueParamType;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_ParameterTypedValue(struct soap *soap, int choice, const union _ns1__union_ParameterTypedValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ParameterTypedValue_valueStr:
		soap_serialize_PointerTostd__string(soap, &a->valueStr);
		break;
	case SOAP_UNION__ns1__union_ParameterTypedValue_valueBool:
		soap_embedded(soap, &a->valueBool, SOAP_TYPE_bool);
		break;
	case SOAP_UNION__ns1__union_ParameterTypedValue_valueInt:
		soap_embedded(soap, &a->valueInt, SOAP_TYPE_int);
		break;
	case SOAP_UNION__ns1__union_ParameterTypedValue_valueDouble:
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_ParameterTypedValue(struct soap *soap, int choice, const union _ns1__union_ParameterTypedValue *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns1__union_ParameterTypedValue_valueStr:
		return soap_out_PointerTostd__string(soap, "valueStr", -1, &a->valueStr, "");
	case SOAP_UNION__ns1__union_ParameterTypedValue_valueBool:
		return soap_out_bool(soap, "valueBool", -1, &a->valueBool, "");
	case SOAP_UNION__ns1__union_ParameterTypedValue_valueInt:
		return soap_out_int(soap, "valueInt", -1, &a->valueInt, "");
	case SOAP_UNION__ns1__union_ParameterTypedValue_valueDouble:
		return soap_out_double(soap, "valueDouble", -1, &a->valueDouble, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_ParameterTypedValue * SOAP_FMAC4 soap_in__ns1__union_ParameterTypedValue(struct soap *soap, int *choice, union _ns1__union_ParameterTypedValue *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->valueStr = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__string(soap, "valueStr", &a->valueStr, "xsd:string"))
	{	*choice = SOAP_UNION__ns1__union_ParameterTypedValue_valueStr;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_bool(soap, "valueBool", &a->valueBool, "xsd:boolean"))
	{	*choice = SOAP_UNION__ns1__union_ParameterTypedValue_valueBool;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_int(soap, "valueInt", &a->valueInt, "xsd:int"))
	{	*choice = SOAP_UNION__ns1__union_ParameterTypedValue_valueInt;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_double(soap, "valueDouble", &a->valueDouble, "xsd:double"))
	{	*choice = SOAP_UNION__ns1__union_ParameterTypedValue_valueDouble;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_Response(struct soap *soap, int choice, const union _ns1__union_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_Response_returnedValuePipeline:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__Pipeline(soap, &a->returnedValuePipeline);
		break;
	case SOAP_UNION__ns1__union_Response_returnedValueExecution:
		soap_serialize_PointerTons1__Execution(soap, &a->returnedValueExecution);
		break;
	case SOAP_UNION__ns1__union_Response_returnedValueGlobalProp:
		soap_serialize_PointerTons1__GlobalProperties(soap, &a->returnedValueGlobalProp);
		break;
	case SOAP_UNION__ns1__union_Response_returnedValueStr:
		soap_serialize_PointerTostd__vectorTemplateOfstd__string(soap, &a->returnedValueStr);
		break;
	case SOAP_UNION__ns1__union_Response_returnedValueListStrings:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfStrings(soap, &a->returnedValueListStrings);
		break;
	case SOAP_UNION__ns1__union_Response_returnedValueListExecutions:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfExecutions(soap, &a->returnedValueListExecutions);
		break;
	case SOAP_UNION__ns1__union_Response_returnedValueListPipelines:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfPipelines(soap, &a->returnedValueListPipelines);
		break;
	case SOAP_UNION__ns1__union_Response_returnedValueStatus:
		soap_serialize_PointerTons1__ExecutionStatus(soap, &a->returnedValueStatus);
		break;
	case SOAP_UNION__ns1__union_Response_returnedValuePairKey:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(soap, &a->returnedValuePairKey);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_Response(struct soap *soap, int choice, const union _ns1__union_Response *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns1__union_Response_returnedValuePipeline:
		return soap_out_PointerTostd__vectorTemplateOfPointerTons1__Pipeline(soap, "returnedValuePipeline", -1, &a->returnedValuePipeline, "");
	case SOAP_UNION__ns1__union_Response_returnedValueExecution:
		return soap_out_PointerTons1__Execution(soap, "returnedValueExecution", -1, &a->returnedValueExecution, "");
	case SOAP_UNION__ns1__union_Response_returnedValueGlobalProp:
		return soap_out_PointerTons1__GlobalProperties(soap, "returnedValueGlobalProp", -1, &a->returnedValueGlobalProp, "");
	case SOAP_UNION__ns1__union_Response_returnedValueStr:
		return soap_out_PointerTostd__vectorTemplateOfstd__string(soap, "returnedValueStr", -1, &a->returnedValueStr, "");
	case SOAP_UNION__ns1__union_Response_returnedValueListStrings:
		return soap_out_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfStrings(soap, "returnedValueListStrings", -1, &a->returnedValueListStrings, "");
	case SOAP_UNION__ns1__union_Response_returnedValueListExecutions:
		return soap_out_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfExecutions(soap, "returnedValueListExecutions", -1, &a->returnedValueListExecutions, "");
	case SOAP_UNION__ns1__union_Response_returnedValueListPipelines:
		return soap_out_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfPipelines(soap, "returnedValueListPipelines", -1, &a->returnedValueListPipelines, "");
	case SOAP_UNION__ns1__union_Response_returnedValueStatus:
		return soap_out_PointerTons1__ExecutionStatus(soap, "returnedValueStatus", -1, &a->returnedValueStatus, "");
	case SOAP_UNION__ns1__union_Response_returnedValuePairKey:
		return soap_out_PointerTostd__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(soap, "returnedValuePairKey", -1, &a->returnedValuePairKey, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_Response * SOAP_FMAC4 soap_in__ns1__union_Response(struct soap *soap, int *choice, union _ns1__union_Response *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->returnedValuePipeline = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTons1__Pipeline(soap, "returnedValuePipeline", &a->returnedValuePipeline, "ns1:Pipeline"))
	{	*choice = SOAP_UNION__ns1__union_Response_returnedValuePipeline;
		return a;
	}
	a->returnedValueExecution = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__Execution(soap, "returnedValueExecution", &a->returnedValueExecution, "ns1:Execution"))
	{	*choice = SOAP_UNION__ns1__union_Response_returnedValueExecution;
		return a;
	}
	a->returnedValueGlobalProp = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__GlobalProperties(soap, "returnedValueGlobalProp", &a->returnedValueGlobalProp, "ns1:GlobalProperties"))
	{	*choice = SOAP_UNION__ns1__union_Response_returnedValueGlobalProp;
		return a;
	}
	a->returnedValueStr = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfstd__string(soap, "returnedValueStr", &a->returnedValueStr, "xsd:string"))
	{	*choice = SOAP_UNION__ns1__union_Response_returnedValueStr;
		return a;
	}
	a->returnedValueListStrings = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfStrings(soap, "returnedValueListStrings", &a->returnedValueListStrings, "ns1:ArrayOfStrings"))
	{	*choice = SOAP_UNION__ns1__union_Response_returnedValueListStrings;
		return a;
	}
	a->returnedValueListExecutions = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfExecutions(soap, "returnedValueListExecutions", &a->returnedValueListExecutions, "ns1:ArrayOfExecutions"))
	{	*choice = SOAP_UNION__ns1__union_Response_returnedValueListExecutions;
		return a;
	}
	a->returnedValueListPipelines = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfPipelines(soap, "returnedValueListPipelines", &a->returnedValueListPipelines, "ns1:ArrayOfPipelines"))
	{	*choice = SOAP_UNION__ns1__union_Response_returnedValueListPipelines;
		return a;
	}
	a->returnedValueStatus = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__ExecutionStatus(soap, "returnedValueStatus", &a->returnedValueStatus, "ns1:ExecutionStatus"))
	{	*choice = SOAP_UNION__ns1__union_Response_returnedValueStatus;
		return a;
	}
	a->returnedValuePairKey = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(soap, "returnedValuePairKey", &a->returnedValuePairKey, "ns1:PipelineKeyBooleanValuePair"))
	{	*choice = SOAP_UNION__ns1__union_Response_returnedValuePairKey;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listExecutionsResponse(struct soap *soap, ns1__listExecutionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listExecutionsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listExecutionsResponse(struct soap *soap, const char *tag, int id, ns1__listExecutionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listExecutionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listExecutionsResponse ** SOAP_FMAC4 soap_in_PointerTons1__listExecutionsResponse(struct soap *soap, const char *tag, ns1__listExecutionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listExecutionsResponse **)soap_malloc(soap, sizeof(ns1__listExecutionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listExecutionsResponse *)soap_instantiate_ns1__listExecutionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listExecutionsResponse ** p = (ns1__listExecutionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listExecutionsResponse, sizeof(ns1__listExecutionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listExecutionsResponse(struct soap *soap, ns1__listExecutionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listExecutionsResponse);
	if (soap_out_PointerTons1__listExecutionsResponse(soap, tag?tag:"ns1:listExecutionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listExecutionsResponse ** SOAP_FMAC4 soap_get_PointerTons1__listExecutionsResponse(struct soap *soap, ns1__listExecutionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listExecutionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listExecutions(struct soap *soap, ns1__listExecutions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listExecutions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listExecutions(struct soap *soap, const char *tag, int id, ns1__listExecutions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listExecutions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listExecutions ** SOAP_FMAC4 soap_in_PointerTons1__listExecutions(struct soap *soap, const char *tag, ns1__listExecutions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listExecutions **)soap_malloc(soap, sizeof(ns1__listExecutions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listExecutions *)soap_instantiate_ns1__listExecutions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listExecutions ** p = (ns1__listExecutions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listExecutions, sizeof(ns1__listExecutions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listExecutions(struct soap *soap, ns1__listExecutions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listExecutions);
	if (soap_out_PointerTons1__listExecutions(soap, tag?tag:"ns1:listExecutions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listExecutions ** SOAP_FMAC4 soap_get_PointerTons1__listExecutions(struct soap *soap, ns1__listExecutions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listExecutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listPipelinesResponse(struct soap *soap, ns1__listPipelinesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listPipelinesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listPipelinesResponse(struct soap *soap, const char *tag, int id, ns1__listPipelinesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listPipelinesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listPipelinesResponse ** SOAP_FMAC4 soap_in_PointerTons1__listPipelinesResponse(struct soap *soap, const char *tag, ns1__listPipelinesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listPipelinesResponse **)soap_malloc(soap, sizeof(ns1__listPipelinesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listPipelinesResponse *)soap_instantiate_ns1__listPipelinesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listPipelinesResponse ** p = (ns1__listPipelinesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listPipelinesResponse, sizeof(ns1__listPipelinesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listPipelinesResponse(struct soap *soap, ns1__listPipelinesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listPipelinesResponse);
	if (soap_out_PointerTons1__listPipelinesResponse(soap, tag?tag:"ns1:listPipelinesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listPipelinesResponse ** SOAP_FMAC4 soap_get_PointerTons1__listPipelinesResponse(struct soap *soap, ns1__listPipelinesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listPipelinesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__listPipelines(struct soap *soap, ns1__listPipelines *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__listPipelines))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__listPipelines(struct soap *soap, const char *tag, int id, ns1__listPipelines *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__listPipelines);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__listPipelines ** SOAP_FMAC4 soap_in_PointerTons1__listPipelines(struct soap *soap, const char *tag, ns1__listPipelines **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__listPipelines **)soap_malloc(soap, sizeof(ns1__listPipelines *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__listPipelines *)soap_instantiate_ns1__listPipelines(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__listPipelines ** p = (ns1__listPipelines **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__listPipelines, sizeof(ns1__listPipelines), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__listPipelines(struct soap *soap, ns1__listPipelines *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__listPipelines);
	if (soap_out_PointerTons1__listPipelines(soap, tag?tag:"ns1:listPipelines", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__listPipelines ** SOAP_FMAC4 soap_get_PointerTons1__listPipelines(struct soap *soap, ns1__listPipelines **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__listPipelines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__playExecutionResponse(struct soap *soap, ns1__playExecutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__playExecutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__playExecutionResponse(struct soap *soap, const char *tag, int id, ns1__playExecutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__playExecutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__playExecutionResponse ** SOAP_FMAC4 soap_in_PointerTons1__playExecutionResponse(struct soap *soap, const char *tag, ns1__playExecutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__playExecutionResponse **)soap_malloc(soap, sizeof(ns1__playExecutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__playExecutionResponse *)soap_instantiate_ns1__playExecutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__playExecutionResponse ** p = (ns1__playExecutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__playExecutionResponse, sizeof(ns1__playExecutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__playExecutionResponse(struct soap *soap, ns1__playExecutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__playExecutionResponse);
	if (soap_out_PointerTons1__playExecutionResponse(soap, tag?tag:"ns1:playExecutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__playExecutionResponse ** SOAP_FMAC4 soap_get_PointerTons1__playExecutionResponse(struct soap *soap, ns1__playExecutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__playExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__playExecution(struct soap *soap, ns1__playExecution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__playExecution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__playExecution(struct soap *soap, const char *tag, int id, ns1__playExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__playExecution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__playExecution ** SOAP_FMAC4 soap_in_PointerTons1__playExecution(struct soap *soap, const char *tag, ns1__playExecution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__playExecution **)soap_malloc(soap, sizeof(ns1__playExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__playExecution *)soap_instantiate_ns1__playExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__playExecution ** p = (ns1__playExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__playExecution, sizeof(ns1__playExecution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__playExecution(struct soap *soap, ns1__playExecution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__playExecution);
	if (soap_out_PointerTons1__playExecution(soap, tag?tag:"ns1:playExecution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__playExecution ** SOAP_FMAC4 soap_get_PointerTons1__playExecution(struct soap *soap, ns1__playExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__playExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getExecutionResponse(struct soap *soap, ns1__getExecutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getExecutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getExecutionResponse(struct soap *soap, const char *tag, int id, ns1__getExecutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getExecutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getExecutionResponse ** SOAP_FMAC4 soap_in_PointerTons1__getExecutionResponse(struct soap *soap, const char *tag, ns1__getExecutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getExecutionResponse **)soap_malloc(soap, sizeof(ns1__getExecutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getExecutionResponse *)soap_instantiate_ns1__getExecutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getExecutionResponse ** p = (ns1__getExecutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getExecutionResponse, sizeof(ns1__getExecutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getExecutionResponse(struct soap *soap, ns1__getExecutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getExecutionResponse);
	if (soap_out_PointerTons1__getExecutionResponse(soap, tag?tag:"ns1:getExecutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getExecutionResponse ** SOAP_FMAC4 soap_get_PointerTons1__getExecutionResponse(struct soap *soap, ns1__getExecutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getExecution(struct soap *soap, ns1__getExecution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getExecution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getExecution(struct soap *soap, const char *tag, int id, ns1__getExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getExecution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getExecution ** SOAP_FMAC4 soap_in_PointerTons1__getExecution(struct soap *soap, const char *tag, ns1__getExecution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getExecution **)soap_malloc(soap, sizeof(ns1__getExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getExecution *)soap_instantiate_ns1__getExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getExecution ** p = (ns1__getExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getExecution, sizeof(ns1__getExecution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getExecution(struct soap *soap, ns1__getExecution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getExecution);
	if (soap_out_PointerTons1__getExecution(soap, tag?tag:"ns1:getExecution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getExecution ** SOAP_FMAC4 soap_get_PointerTons1__getExecution(struct soap *soap, ns1__getExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__killExecutionResponse(struct soap *soap, ns1__killExecutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__killExecutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__killExecutionResponse(struct soap *soap, const char *tag, int id, ns1__killExecutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__killExecutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__killExecutionResponse ** SOAP_FMAC4 soap_in_PointerTons1__killExecutionResponse(struct soap *soap, const char *tag, ns1__killExecutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__killExecutionResponse **)soap_malloc(soap, sizeof(ns1__killExecutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__killExecutionResponse *)soap_instantiate_ns1__killExecutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__killExecutionResponse ** p = (ns1__killExecutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__killExecutionResponse, sizeof(ns1__killExecutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__killExecutionResponse(struct soap *soap, ns1__killExecutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__killExecutionResponse);
	if (soap_out_PointerTons1__killExecutionResponse(soap, tag?tag:"ns1:killExecutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__killExecutionResponse ** SOAP_FMAC4 soap_get_PointerTons1__killExecutionResponse(struct soap *soap, ns1__killExecutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__killExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__killExecution(struct soap *soap, ns1__killExecution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__killExecution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__killExecution(struct soap *soap, const char *tag, int id, ns1__killExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__killExecution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__killExecution ** SOAP_FMAC4 soap_in_PointerTons1__killExecution(struct soap *soap, const char *tag, ns1__killExecution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__killExecution **)soap_malloc(soap, sizeof(ns1__killExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__killExecution *)soap_instantiate_ns1__killExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__killExecution ** p = (ns1__killExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__killExecution, sizeof(ns1__killExecution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__killExecution(struct soap *soap, ns1__killExecution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__killExecution);
	if (soap_out_PointerTons1__killExecution(soap, tag?tag:"ns1:killExecution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__killExecution ** SOAP_FMAC4 soap_get_PointerTons1__killExecution(struct soap *soap, ns1__killExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__killExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getExecutionResultsResponse(struct soap *soap, ns1__getExecutionResultsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getExecutionResultsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getExecutionResultsResponse(struct soap *soap, const char *tag, int id, ns1__getExecutionResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getExecutionResultsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getExecutionResultsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getExecutionResultsResponse(struct soap *soap, const char *tag, ns1__getExecutionResultsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getExecutionResultsResponse **)soap_malloc(soap, sizeof(ns1__getExecutionResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getExecutionResultsResponse *)soap_instantiate_ns1__getExecutionResultsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getExecutionResultsResponse ** p = (ns1__getExecutionResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getExecutionResultsResponse, sizeof(ns1__getExecutionResultsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getExecutionResultsResponse(struct soap *soap, ns1__getExecutionResultsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getExecutionResultsResponse);
	if (soap_out_PointerTons1__getExecutionResultsResponse(soap, tag?tag:"ns1:getExecutionResultsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getExecutionResultsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getExecutionResultsResponse(struct soap *soap, ns1__getExecutionResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getExecutionResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getExecutionResults(struct soap *soap, ns1__getExecutionResults *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getExecutionResults))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getExecutionResults(struct soap *soap, const char *tag, int id, ns1__getExecutionResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getExecutionResults);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getExecutionResults ** SOAP_FMAC4 soap_in_PointerTons1__getExecutionResults(struct soap *soap, const char *tag, ns1__getExecutionResults **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getExecutionResults **)soap_malloc(soap, sizeof(ns1__getExecutionResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getExecutionResults *)soap_instantiate_ns1__getExecutionResults(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getExecutionResults ** p = (ns1__getExecutionResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getExecutionResults, sizeof(ns1__getExecutionResults), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getExecutionResults(struct soap *soap, ns1__getExecutionResults *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getExecutionResults);
	if (soap_out_PointerTons1__getExecutionResults(soap, tag?tag:"ns1:getExecutionResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getExecutionResults ** SOAP_FMAC4 soap_get_PointerTons1__getExecutionResults(struct soap *soap, ns1__getExecutionResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getExecutionResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getStdErrResponse(struct soap *soap, ns1__getStdErrResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getStdErrResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getStdErrResponse(struct soap *soap, const char *tag, int id, ns1__getStdErrResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getStdErrResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getStdErrResponse ** SOAP_FMAC4 soap_in_PointerTons1__getStdErrResponse(struct soap *soap, const char *tag, ns1__getStdErrResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getStdErrResponse **)soap_malloc(soap, sizeof(ns1__getStdErrResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getStdErrResponse *)soap_instantiate_ns1__getStdErrResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getStdErrResponse ** p = (ns1__getStdErrResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getStdErrResponse, sizeof(ns1__getStdErrResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getStdErrResponse(struct soap *soap, ns1__getStdErrResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getStdErrResponse);
	if (soap_out_PointerTons1__getStdErrResponse(soap, tag?tag:"ns1:getStdErrResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getStdErrResponse ** SOAP_FMAC4 soap_get_PointerTons1__getStdErrResponse(struct soap *soap, ns1__getStdErrResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getStdErrResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getStdErr(struct soap *soap, ns1__getStdErr *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getStdErr))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getStdErr(struct soap *soap, const char *tag, int id, ns1__getStdErr *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getStdErr);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getStdErr ** SOAP_FMAC4 soap_in_PointerTons1__getStdErr(struct soap *soap, const char *tag, ns1__getStdErr **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getStdErr **)soap_malloc(soap, sizeof(ns1__getStdErr *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getStdErr *)soap_instantiate_ns1__getStdErr(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getStdErr ** p = (ns1__getStdErr **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getStdErr, sizeof(ns1__getStdErr), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getStdErr(struct soap *soap, ns1__getStdErr *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getStdErr);
	if (soap_out_PointerTons1__getStdErr(soap, tag?tag:"ns1:getStdErr", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getStdErr ** SOAP_FMAC4 soap_get_PointerTons1__getStdErr(struct soap *soap, ns1__getStdErr **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getStdErr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getStdOutResponse(struct soap *soap, ns1__getStdOutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getStdOutResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getStdOutResponse(struct soap *soap, const char *tag, int id, ns1__getStdOutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getStdOutResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getStdOutResponse ** SOAP_FMAC4 soap_in_PointerTons1__getStdOutResponse(struct soap *soap, const char *tag, ns1__getStdOutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getStdOutResponse **)soap_malloc(soap, sizeof(ns1__getStdOutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getStdOutResponse *)soap_instantiate_ns1__getStdOutResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getStdOutResponse ** p = (ns1__getStdOutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getStdOutResponse, sizeof(ns1__getStdOutResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getStdOutResponse(struct soap *soap, ns1__getStdOutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getStdOutResponse);
	if (soap_out_PointerTons1__getStdOutResponse(soap, tag?tag:"ns1:getStdOutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getStdOutResponse ** SOAP_FMAC4 soap_get_PointerTons1__getStdOutResponse(struct soap *soap, ns1__getStdOutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getStdOutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getStdOut(struct soap *soap, ns1__getStdOut *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getStdOut))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getStdOut(struct soap *soap, const char *tag, int id, ns1__getStdOut *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getStdOut);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getStdOut ** SOAP_FMAC4 soap_in_PointerTons1__getStdOut(struct soap *soap, const char *tag, ns1__getStdOut **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getStdOut **)soap_malloc(soap, sizeof(ns1__getStdOut *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getStdOut *)soap_instantiate_ns1__getStdOut(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getStdOut ** p = (ns1__getStdOut **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getStdOut, sizeof(ns1__getStdOut), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getStdOut(struct soap *soap, ns1__getStdOut *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getStdOut);
	if (soap_out_PointerTons1__getStdOut(soap, tag?tag:"ns1:getStdOut", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getStdOut ** SOAP_FMAC4 soap_get_PointerTons1__getStdOut(struct soap *soap, ns1__getStdOut **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getStdOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__initExecutionResponse(struct soap *soap, ns1__initExecutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__initExecutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__initExecutionResponse(struct soap *soap, const char *tag, int id, ns1__initExecutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__initExecutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__initExecutionResponse ** SOAP_FMAC4 soap_in_PointerTons1__initExecutionResponse(struct soap *soap, const char *tag, ns1__initExecutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__initExecutionResponse **)soap_malloc(soap, sizeof(ns1__initExecutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__initExecutionResponse *)soap_instantiate_ns1__initExecutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__initExecutionResponse ** p = (ns1__initExecutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__initExecutionResponse, sizeof(ns1__initExecutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__initExecutionResponse(struct soap *soap, ns1__initExecutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__initExecutionResponse);
	if (soap_out_PointerTons1__initExecutionResponse(soap, tag?tag:"ns1:initExecutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__initExecutionResponse ** SOAP_FMAC4 soap_get_PointerTons1__initExecutionResponse(struct soap *soap, ns1__initExecutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__initExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__initExecution(struct soap *soap, ns1__initExecution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__initExecution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__initExecution(struct soap *soap, const char *tag, int id, ns1__initExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__initExecution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__initExecution ** SOAP_FMAC4 soap_in_PointerTons1__initExecution(struct soap *soap, const char *tag, ns1__initExecution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__initExecution **)soap_malloc(soap, sizeof(ns1__initExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__initExecution *)soap_instantiate_ns1__initExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__initExecution ** p = (ns1__initExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__initExecution, sizeof(ns1__initExecution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__initExecution(struct soap *soap, ns1__initExecution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__initExecution);
	if (soap_out_PointerTons1__initExecution(soap, tag?tag:"ns1:initExecution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__initExecution ** SOAP_FMAC4 soap_get_PointerTons1__initExecution(struct soap *soap, ns1__initExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__initExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getGlobalPropertiesResponse(struct soap *soap, ns1__getGlobalPropertiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getGlobalPropertiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getGlobalPropertiesResponse(struct soap *soap, const char *tag, int id, ns1__getGlobalPropertiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getGlobalPropertiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getGlobalPropertiesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getGlobalPropertiesResponse(struct soap *soap, const char *tag, ns1__getGlobalPropertiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getGlobalPropertiesResponse **)soap_malloc(soap, sizeof(ns1__getGlobalPropertiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getGlobalPropertiesResponse *)soap_instantiate_ns1__getGlobalPropertiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getGlobalPropertiesResponse ** p = (ns1__getGlobalPropertiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getGlobalPropertiesResponse, sizeof(ns1__getGlobalPropertiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getGlobalPropertiesResponse(struct soap *soap, ns1__getGlobalPropertiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getGlobalPropertiesResponse);
	if (soap_out_PointerTons1__getGlobalPropertiesResponse(soap, tag?tag:"ns1:getGlobalPropertiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getGlobalPropertiesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getGlobalPropertiesResponse(struct soap *soap, ns1__getGlobalPropertiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getGlobalPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getGlobalProperties(struct soap *soap, ns1__getGlobalProperties *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getGlobalProperties))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getGlobalProperties(struct soap *soap, const char *tag, int id, ns1__getGlobalProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getGlobalProperties);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getGlobalProperties ** SOAP_FMAC4 soap_in_PointerTons1__getGlobalProperties(struct soap *soap, const char *tag, ns1__getGlobalProperties **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getGlobalProperties **)soap_malloc(soap, sizeof(ns1__getGlobalProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getGlobalProperties *)soap_instantiate_ns1__getGlobalProperties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getGlobalProperties ** p = (ns1__getGlobalProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getGlobalProperties, sizeof(ns1__getGlobalProperties), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getGlobalProperties(struct soap *soap, ns1__getGlobalProperties *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getGlobalProperties);
	if (soap_out_PointerTons1__getGlobalProperties(soap, tag?tag:"ns1:getGlobalProperties", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getGlobalProperties ** SOAP_FMAC4 soap_get_PointerTons1__getGlobalProperties(struct soap *soap, ns1__getGlobalProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getGlobalProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateExecutionResponse(struct soap *soap, ns1__updateExecutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateExecutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateExecutionResponse(struct soap *soap, const char *tag, int id, ns1__updateExecutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateExecutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateExecutionResponse ** SOAP_FMAC4 soap_in_PointerTons1__updateExecutionResponse(struct soap *soap, const char *tag, ns1__updateExecutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateExecutionResponse **)soap_malloc(soap, sizeof(ns1__updateExecutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateExecutionResponse *)soap_instantiate_ns1__updateExecutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateExecutionResponse ** p = (ns1__updateExecutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateExecutionResponse, sizeof(ns1__updateExecutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateExecutionResponse(struct soap *soap, ns1__updateExecutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateExecutionResponse);
	if (soap_out_PointerTons1__updateExecutionResponse(soap, tag?tag:"ns1:updateExecutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateExecutionResponse ** SOAP_FMAC4 soap_get_PointerTons1__updateExecutionResponse(struct soap *soap, ns1__updateExecutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateExecution(struct soap *soap, ns1__updateExecution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateExecution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateExecution(struct soap *soap, const char *tag, int id, ns1__updateExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateExecution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateExecution ** SOAP_FMAC4 soap_in_PointerTons1__updateExecution(struct soap *soap, const char *tag, ns1__updateExecution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateExecution **)soap_malloc(soap, sizeof(ns1__updateExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateExecution *)soap_instantiate_ns1__updateExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateExecution ** p = (ns1__updateExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateExecution, sizeof(ns1__updateExecution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateExecution(struct soap *soap, ns1__updateExecution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateExecution);
	if (soap_out_PointerTons1__updateExecution(soap, tag?tag:"ns1:updateExecution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateExecution ** SOAP_FMAC4 soap_get_PointerTons1__updateExecution(struct soap *soap, ns1__updateExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__logoutResponse(struct soap *soap, ns1__logoutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__logoutResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__logoutResponse(struct soap *soap, const char *tag, int id, ns1__logoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__logoutResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__logoutResponse ** SOAP_FMAC4 soap_in_PointerTons1__logoutResponse(struct soap *soap, const char *tag, ns1__logoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__logoutResponse **)soap_malloc(soap, sizeof(ns1__logoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__logoutResponse *)soap_instantiate_ns1__logoutResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__logoutResponse ** p = (ns1__logoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__logoutResponse, sizeof(ns1__logoutResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__logoutResponse(struct soap *soap, ns1__logoutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__logoutResponse);
	if (soap_out_PointerTons1__logoutResponse(soap, tag?tag:"ns1:logoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__logoutResponse ** SOAP_FMAC4 soap_get_PointerTons1__logoutResponse(struct soap *soap, ns1__logoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__logout(struct soap *soap, ns1__logout *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__logout))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__logout(struct soap *soap, const char *tag, int id, ns1__logout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__logout);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__logout ** SOAP_FMAC4 soap_in_PointerTons1__logout(struct soap *soap, const char *tag, ns1__logout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__logout **)soap_malloc(soap, sizeof(ns1__logout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__logout *)soap_instantiate_ns1__logout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__logout ** p = (ns1__logout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__logout, sizeof(ns1__logout), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__logout(struct soap *soap, ns1__logout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__logout);
	if (soap_out_PointerTons1__logout(soap, tag?tag:"ns1:logout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__logout ** SOAP_FMAC4 soap_get_PointerTons1__logout(struct soap *soap, ns1__logout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateHTTPResponse(struct soap *soap, ns1__authenticateHTTPResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateHTTPResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateHTTPResponse(struct soap *soap, const char *tag, int id, ns1__authenticateHTTPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateHTTPResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateHTTPResponse ** SOAP_FMAC4 soap_in_PointerTons1__authenticateHTTPResponse(struct soap *soap, const char *tag, ns1__authenticateHTTPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateHTTPResponse **)soap_malloc(soap, sizeof(ns1__authenticateHTTPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateHTTPResponse *)soap_instantiate_ns1__authenticateHTTPResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateHTTPResponse ** p = (ns1__authenticateHTTPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateHTTPResponse, sizeof(ns1__authenticateHTTPResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateHTTPResponse(struct soap *soap, ns1__authenticateHTTPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateHTTPResponse);
	if (soap_out_PointerTons1__authenticateHTTPResponse(soap, tag?tag:"ns1:authenticateHTTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateHTTPResponse ** SOAP_FMAC4 soap_get_PointerTons1__authenticateHTTPResponse(struct soap *soap, ns1__authenticateHTTPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateHTTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateHTTP(struct soap *soap, ns1__authenticateHTTP *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateHTTP))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateHTTP(struct soap *soap, const char *tag, int id, ns1__authenticateHTTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateHTTP);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateHTTP ** SOAP_FMAC4 soap_in_PointerTons1__authenticateHTTP(struct soap *soap, const char *tag, ns1__authenticateHTTP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateHTTP **)soap_malloc(soap, sizeof(ns1__authenticateHTTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateHTTP *)soap_instantiate_ns1__authenticateHTTP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateHTTP ** p = (ns1__authenticateHTTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateHTTP, sizeof(ns1__authenticateHTTP), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateHTTP(struct soap *soap, ns1__authenticateHTTP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateHTTP);
	if (soap_out_PointerTons1__authenticateHTTP(soap, tag?tag:"ns1:authenticateHTTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateHTTP ** SOAP_FMAC4 soap_get_PointerTons1__authenticateHTTP(struct soap *soap, ns1__authenticateHTTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateHTTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPipelineResponse(struct soap *soap, ns1__getPipelineResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPipelineResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPipelineResponse(struct soap *soap, const char *tag, int id, ns1__getPipelineResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPipelineResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPipelineResponse ** SOAP_FMAC4 soap_in_PointerTons1__getPipelineResponse(struct soap *soap, const char *tag, ns1__getPipelineResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPipelineResponse **)soap_malloc(soap, sizeof(ns1__getPipelineResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPipelineResponse *)soap_instantiate_ns1__getPipelineResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPipelineResponse ** p = (ns1__getPipelineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPipelineResponse, sizeof(ns1__getPipelineResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPipelineResponse(struct soap *soap, ns1__getPipelineResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPipelineResponse);
	if (soap_out_PointerTons1__getPipelineResponse(soap, tag?tag:"ns1:getPipelineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getPipelineResponse ** SOAP_FMAC4 soap_get_PointerTons1__getPipelineResponse(struct soap *soap, ns1__getPipelineResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPipelineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPipeline(struct soap *soap, ns1__getPipeline *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPipeline))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPipeline(struct soap *soap, const char *tag, int id, ns1__getPipeline *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPipeline);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPipeline ** SOAP_FMAC4 soap_in_PointerTons1__getPipeline(struct soap *soap, const char *tag, ns1__getPipeline **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPipeline **)soap_malloc(soap, sizeof(ns1__getPipeline *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPipeline *)soap_instantiate_ns1__getPipeline(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPipeline ** p = (ns1__getPipeline **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPipeline, sizeof(ns1__getPipeline), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPipeline(struct soap *soap, ns1__getPipeline *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPipeline);
	if (soap_out_PointerTons1__getPipeline(soap, tag?tag:"ns1:getPipeline", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getPipeline ** SOAP_FMAC4 soap_get_PointerTons1__getPipeline(struct soap *soap, ns1__getPipeline **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPipeline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteExecutionResponse(struct soap *soap, ns1__deleteExecutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteExecutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteExecutionResponse(struct soap *soap, const char *tag, int id, ns1__deleteExecutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteExecutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteExecutionResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteExecutionResponse(struct soap *soap, const char *tag, ns1__deleteExecutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteExecutionResponse **)soap_malloc(soap, sizeof(ns1__deleteExecutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteExecutionResponse *)soap_instantiate_ns1__deleteExecutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteExecutionResponse ** p = (ns1__deleteExecutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteExecutionResponse, sizeof(ns1__deleteExecutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteExecutionResponse(struct soap *soap, ns1__deleteExecutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteExecutionResponse);
	if (soap_out_PointerTons1__deleteExecutionResponse(soap, tag?tag:"ns1:deleteExecutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteExecutionResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteExecutionResponse(struct soap *soap, ns1__deleteExecutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteExecution(struct soap *soap, ns1__deleteExecution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteExecution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteExecution(struct soap *soap, const char *tag, int id, ns1__deleteExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteExecution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteExecution ** SOAP_FMAC4 soap_in_PointerTons1__deleteExecution(struct soap *soap, const char *tag, ns1__deleteExecution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteExecution **)soap_malloc(soap, sizeof(ns1__deleteExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteExecution *)soap_instantiate_ns1__deleteExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteExecution ** p = (ns1__deleteExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteExecution, sizeof(ns1__deleteExecution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteExecution(struct soap *soap, ns1__deleteExecution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteExecution);
	if (soap_out_PointerTons1__deleteExecution(soap, tag?tag:"ns1:deleteExecution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__deleteExecution ** SOAP_FMAC4 soap_get_PointerTons1__deleteExecution(struct soap *soap, ns1__deleteExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateSessionResponse(struct soap *soap, ns1__authenticateSessionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateSessionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateSessionResponse(struct soap *soap, const char *tag, int id, ns1__authenticateSessionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateSessionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateSessionResponse ** SOAP_FMAC4 soap_in_PointerTons1__authenticateSessionResponse(struct soap *soap, const char *tag, ns1__authenticateSessionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateSessionResponse **)soap_malloc(soap, sizeof(ns1__authenticateSessionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateSessionResponse *)soap_instantiate_ns1__authenticateSessionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateSessionResponse ** p = (ns1__authenticateSessionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateSessionResponse, sizeof(ns1__authenticateSessionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateSessionResponse(struct soap *soap, ns1__authenticateSessionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateSessionResponse);
	if (soap_out_PointerTons1__authenticateSessionResponse(soap, tag?tag:"ns1:authenticateSessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateSessionResponse ** SOAP_FMAC4 soap_get_PointerTons1__authenticateSessionResponse(struct soap *soap, ns1__authenticateSessionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateSession(struct soap *soap, ns1__authenticateSession *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateSession))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateSession(struct soap *soap, const char *tag, int id, ns1__authenticateSession *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateSession);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateSession ** SOAP_FMAC4 soap_in_PointerTons1__authenticateSession(struct soap *soap, const char *tag, ns1__authenticateSession **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateSession **)soap_malloc(soap, sizeof(ns1__authenticateSession *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateSession *)soap_instantiate_ns1__authenticateSession(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateSession ** p = (ns1__authenticateSession **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateSession, sizeof(ns1__authenticateSession), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateSession(struct soap *soap, ns1__authenticateSession *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateSession);
	if (soap_out_PointerTons1__authenticateSession(soap, tag?tag:"ns1:authenticateSession", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateSession ** SOAP_FMAC4 soap_get_PointerTons1__authenticateSession(struct soap *soap, ns1__authenticateSession **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__IntKeyStringValuePair(struct soap *soap, ns1__IntKeyStringValuePair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__IntKeyStringValuePair))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__IntKeyStringValuePair(struct soap *soap, const char *tag, int id, ns1__IntKeyStringValuePair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__IntKeyStringValuePair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__IntKeyStringValuePair ** SOAP_FMAC4 soap_in_PointerTons1__IntKeyStringValuePair(struct soap *soap, const char *tag, ns1__IntKeyStringValuePair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__IntKeyStringValuePair **)soap_malloc(soap, sizeof(ns1__IntKeyStringValuePair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__IntKeyStringValuePair *)soap_instantiate_ns1__IntKeyStringValuePair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__IntKeyStringValuePair ** p = (ns1__IntKeyStringValuePair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__IntKeyStringValuePair, sizeof(ns1__IntKeyStringValuePair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__IntKeyStringValuePair(struct soap *soap, ns1__IntKeyStringValuePair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__IntKeyStringValuePair);
	if (soap_out_PointerTons1__IntKeyStringValuePair(soap, tag?tag:"ns1:IntKeyStringValuePair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__IntKeyStringValuePair ** SOAP_FMAC4 soap_get_PointerTons1__IntKeyStringValuePair(struct soap *soap, ns1__IntKeyStringValuePair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__IntKeyStringValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PipelineParameter(struct soap *soap, ns1__PipelineParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PipelineParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PipelineParameter(struct soap *soap, const char *tag, int id, ns1__PipelineParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PipelineParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PipelineParameter ** SOAP_FMAC4 soap_in_PointerTons1__PipelineParameter(struct soap *soap, const char *tag, ns1__PipelineParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PipelineParameter **)soap_malloc(soap, sizeof(ns1__PipelineParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PipelineParameter *)soap_instantiate_ns1__PipelineParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PipelineParameter ** p = (ns1__PipelineParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PipelineParameter, sizeof(ns1__PipelineParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PipelineParameter(struct soap *soap, ns1__PipelineParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PipelineParameter);
	if (soap_out_PointerTons1__PipelineParameter(soap, tag?tag:"ns1:PipelineParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PipelineParameter ** SOAP_FMAC4 soap_get_PointerTons1__PipelineParameter(struct soap *soap, ns1__PipelineParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PipelineParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StringKeyParameterValuePair(struct soap *soap, ns1__StringKeyParameterValuePair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StringKeyParameterValuePair))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StringKeyParameterValuePair(struct soap *soap, const char *tag, int id, ns1__StringKeyParameterValuePair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StringKeyParameterValuePair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__StringKeyParameterValuePair ** SOAP_FMAC4 soap_in_PointerTons1__StringKeyParameterValuePair(struct soap *soap, const char *tag, ns1__StringKeyParameterValuePair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StringKeyParameterValuePair **)soap_malloc(soap, sizeof(ns1__StringKeyParameterValuePair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StringKeyParameterValuePair *)soap_instantiate_ns1__StringKeyParameterValuePair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__StringKeyParameterValuePair ** p = (ns1__StringKeyParameterValuePair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StringKeyParameterValuePair, sizeof(ns1__StringKeyParameterValuePair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StringKeyParameterValuePair(struct soap *soap, ns1__StringKeyParameterValuePair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__StringKeyParameterValuePair);
	if (soap_out_PointerTons1__StringKeyParameterValuePair(soap, tag?tag:"ns1:StringKeyParameterValuePair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StringKeyParameterValuePair ** SOAP_FMAC4 soap_get_PointerTons1__StringKeyParameterValuePair(struct soap *soap, ns1__StringKeyParameterValuePair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StringKeyParameterValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StringKeyValuePair(struct soap *soap, ns1__StringKeyValuePair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StringKeyValuePair))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StringKeyValuePair(struct soap *soap, const char *tag, int id, ns1__StringKeyValuePair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StringKeyValuePair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__StringKeyValuePair ** SOAP_FMAC4 soap_in_PointerTons1__StringKeyValuePair(struct soap *soap, const char *tag, ns1__StringKeyValuePair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StringKeyValuePair **)soap_malloc(soap, sizeof(ns1__StringKeyValuePair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StringKeyValuePair *)soap_instantiate_ns1__StringKeyValuePair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__StringKeyValuePair ** p = (ns1__StringKeyValuePair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StringKeyValuePair, sizeof(ns1__StringKeyValuePair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StringKeyValuePair(struct soap *soap, ns1__StringKeyValuePair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__StringKeyValuePair);
	if (soap_out_PointerTons1__StringKeyValuePair(soap, tag?tag:"ns1:StringKeyValuePair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StringKeyValuePair ** SOAP_FMAC4 soap_get_PointerTons1__StringKeyValuePair(struct soap *soap, ns1__StringKeyValuePair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StringKeyValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ParameterTypedValue(struct soap *soap, ns1__ParameterTypedValue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ParameterTypedValue))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ParameterTypedValue(struct soap *soap, const char *tag, int id, ns1__ParameterTypedValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ParameterTypedValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ParameterTypedValue ** SOAP_FMAC4 soap_in_PointerTons1__ParameterTypedValue(struct soap *soap, const char *tag, ns1__ParameterTypedValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ParameterTypedValue **)soap_malloc(soap, sizeof(ns1__ParameterTypedValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ParameterTypedValue *)soap_instantiate_ns1__ParameterTypedValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ParameterTypedValue ** p = (ns1__ParameterTypedValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ParameterTypedValue, sizeof(ns1__ParameterTypedValue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ParameterTypedValue(struct soap *soap, ns1__ParameterTypedValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ParameterTypedValue);
	if (soap_out_PointerTons1__ParameterTypedValue(soap, tag?tag:"ns1:ParameterTypedValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ParameterTypedValue ** SOAP_FMAC4 soap_get_PointerTons1__ParameterTypedValue(struct soap *soap, ns1__ParameterTypedValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ParameterTypedValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, std::vector<ns1__PipelineKeyBooleanValuePair * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair))
		soap_serialize_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, int id, std::vector<ns1__PipelineKeyBooleanValuePair * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<ns1__PipelineKeyBooleanValuePair * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, std::vector<ns1__PipelineKeyBooleanValuePair * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<ns1__PipelineKeyBooleanValuePair * >**)soap_malloc(soap, sizeof(std::vector<ns1__PipelineKeyBooleanValuePair * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, std::vector<ns1__PipelineKeyBooleanValuePair * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair);
	if (soap_out_PointerTostd__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<ns1__PipelineKeyBooleanValuePair * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, std::vector<ns1__PipelineKeyBooleanValuePair * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, ns1__PipelineKeyBooleanValuePair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PipelineKeyBooleanValuePair))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, int id, ns1__PipelineKeyBooleanValuePair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PipelineKeyBooleanValuePair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PipelineKeyBooleanValuePair ** SOAP_FMAC4 soap_in_PointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, ns1__PipelineKeyBooleanValuePair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PipelineKeyBooleanValuePair **)soap_malloc(soap, sizeof(ns1__PipelineKeyBooleanValuePair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PipelineKeyBooleanValuePair *)soap_instantiate_ns1__PipelineKeyBooleanValuePair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PipelineKeyBooleanValuePair ** p = (ns1__PipelineKeyBooleanValuePair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PipelineKeyBooleanValuePair, sizeof(ns1__PipelineKeyBooleanValuePair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, ns1__PipelineKeyBooleanValuePair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PipelineKeyBooleanValuePair);
	if (soap_out_PointerTons1__PipelineKeyBooleanValuePair(soap, tag?tag:"ns1:PipelineKeyBooleanValuePair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PipelineKeyBooleanValuePair ** SOAP_FMAC4 soap_get_PointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, ns1__PipelineKeyBooleanValuePair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PipelineKeyBooleanValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ExecutionStatus(struct soap *soap, enum ns1__ExecutionStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__ExecutionStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ExecutionStatus(struct soap *soap, const char *tag, int id, enum ns1__ExecutionStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ExecutionStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ExecutionStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__ExecutionStatus ** SOAP_FMAC4 soap_in_PointerTons1__ExecutionStatus(struct soap *soap, const char *tag, enum ns1__ExecutionStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__ExecutionStatus **)soap_malloc(soap, sizeof(enum ns1__ExecutionStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ExecutionStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__ExecutionStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ExecutionStatus, sizeof(enum ns1__ExecutionStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ExecutionStatus(struct soap *soap, enum ns1__ExecutionStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ExecutionStatus);
	if (soap_out_PointerTons1__ExecutionStatus(soap, tag?tag:"ns1:ExecutionStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ExecutionStatus ** SOAP_FMAC4 soap_get_PointerTons1__ExecutionStatus(struct soap *soap, enum ns1__ExecutionStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ExecutionStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfPipelines(struct soap *soap, std::vector<ns1__ArrayOfPipelines * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfPipelines))
		soap_serialize_std__vectorTemplateOfPointerTons1__ArrayOfPipelines(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfPipelines(struct soap *soap, const char *tag, int id, std::vector<ns1__ArrayOfPipelines * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTons1__ArrayOfPipelines(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<ns1__ArrayOfPipelines * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfPipelines(struct soap *soap, const char *tag, std::vector<ns1__ArrayOfPipelines * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<ns1__ArrayOfPipelines * >**)soap_malloc(soap, sizeof(std::vector<ns1__ArrayOfPipelines * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__ArrayOfPipelines(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfPipelines(struct soap *soap, std::vector<ns1__ArrayOfPipelines * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfPipelines);
	if (soap_out_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfPipelines(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<ns1__ArrayOfPipelines * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfPipelines(struct soap *soap, std::vector<ns1__ArrayOfPipelines * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfPipelines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPipelines(struct soap *soap, ns1__ArrayOfPipelines *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPipelines))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPipelines(struct soap *soap, const char *tag, int id, ns1__ArrayOfPipelines *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPipelines);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfPipelines ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPipelines(struct soap *soap, const char *tag, ns1__ArrayOfPipelines **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfPipelines **)soap_malloc(soap, sizeof(ns1__ArrayOfPipelines *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfPipelines *)soap_instantiate_ns1__ArrayOfPipelines(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfPipelines ** p = (ns1__ArrayOfPipelines **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPipelines, sizeof(ns1__ArrayOfPipelines), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPipelines(struct soap *soap, ns1__ArrayOfPipelines *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPipelines);
	if (soap_out_PointerTons1__ArrayOfPipelines(soap, tag?tag:"ns1:ArrayOfPipelines", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfPipelines ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPipelines(struct soap *soap, ns1__ArrayOfPipelines **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPipelines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfExecutions(struct soap *soap, std::vector<ns1__ArrayOfExecutions * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfExecutions))
		soap_serialize_std__vectorTemplateOfPointerTons1__ArrayOfExecutions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfExecutions(struct soap *soap, const char *tag, int id, std::vector<ns1__ArrayOfExecutions * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTons1__ArrayOfExecutions(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<ns1__ArrayOfExecutions * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfExecutions(struct soap *soap, const char *tag, std::vector<ns1__ArrayOfExecutions * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<ns1__ArrayOfExecutions * >**)soap_malloc(soap, sizeof(std::vector<ns1__ArrayOfExecutions * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__ArrayOfExecutions(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfExecutions(struct soap *soap, std::vector<ns1__ArrayOfExecutions * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfExecutions);
	if (soap_out_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfExecutions(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<ns1__ArrayOfExecutions * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfExecutions(struct soap *soap, std::vector<ns1__ArrayOfExecutions * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfExecutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfExecutions(struct soap *soap, ns1__ArrayOfExecutions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfExecutions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfExecutions(struct soap *soap, const char *tag, int id, ns1__ArrayOfExecutions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfExecutions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfExecutions ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfExecutions(struct soap *soap, const char *tag, ns1__ArrayOfExecutions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfExecutions **)soap_malloc(soap, sizeof(ns1__ArrayOfExecutions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfExecutions *)soap_instantiate_ns1__ArrayOfExecutions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfExecutions ** p = (ns1__ArrayOfExecutions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfExecutions, sizeof(ns1__ArrayOfExecutions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfExecutions(struct soap *soap, ns1__ArrayOfExecutions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfExecutions);
	if (soap_out_PointerTons1__ArrayOfExecutions(soap, tag?tag:"ns1:ArrayOfExecutions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfExecutions ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfExecutions(struct soap *soap, ns1__ArrayOfExecutions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfExecutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfStrings(struct soap *soap, std::vector<ns1__ArrayOfStrings * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfStrings))
		soap_serialize_std__vectorTemplateOfPointerTons1__ArrayOfStrings(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfStrings(struct soap *soap, const char *tag, int id, std::vector<ns1__ArrayOfStrings * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTons1__ArrayOfStrings(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<ns1__ArrayOfStrings * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfStrings(struct soap *soap, const char *tag, std::vector<ns1__ArrayOfStrings * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<ns1__ArrayOfStrings * >**)soap_malloc(soap, sizeof(std::vector<ns1__ArrayOfStrings * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__ArrayOfStrings(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfStrings(struct soap *soap, std::vector<ns1__ArrayOfStrings * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfStrings);
	if (soap_out_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfStrings(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<ns1__ArrayOfStrings * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfStrings(struct soap *soap, std::vector<ns1__ArrayOfStrings * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__ArrayOfStrings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfStrings(struct soap *soap, ns1__ArrayOfStrings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfStrings))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfStrings(struct soap *soap, const char *tag, int id, ns1__ArrayOfStrings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfStrings);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfStrings ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfStrings(struct soap *soap, const char *tag, ns1__ArrayOfStrings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfStrings **)soap_malloc(soap, sizeof(ns1__ArrayOfStrings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfStrings *)soap_instantiate_ns1__ArrayOfStrings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfStrings ** p = (ns1__ArrayOfStrings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfStrings, sizeof(ns1__ArrayOfStrings), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfStrings(struct soap *soap, ns1__ArrayOfStrings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfStrings);
	if (soap_out_PointerTons1__ArrayOfStrings(soap, tag?tag:"ns1:ArrayOfStrings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfStrings ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfStrings(struct soap *soap, ns1__ArrayOfStrings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfStrings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfstd__string))
		soap_serialize_std__vectorTemplateOfstd__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, std::vector<std::string >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfstd__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<std::string >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<std::string >**)soap_malloc(soap, sizeof(std::vector<std::string >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfstd__string(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfstd__string);
	if (soap_out_PointerTostd__vectorTemplateOfstd__string(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<std::string >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfstd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GlobalProperties(struct soap *soap, ns1__GlobalProperties *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GlobalProperties))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GlobalProperties(struct soap *soap, const char *tag, int id, ns1__GlobalProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GlobalProperties);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__GlobalProperties ** SOAP_FMAC4 soap_in_PointerTons1__GlobalProperties(struct soap *soap, const char *tag, ns1__GlobalProperties **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GlobalProperties **)soap_malloc(soap, sizeof(ns1__GlobalProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GlobalProperties *)soap_instantiate_ns1__GlobalProperties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__GlobalProperties ** p = (ns1__GlobalProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GlobalProperties, sizeof(ns1__GlobalProperties), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GlobalProperties(struct soap *soap, ns1__GlobalProperties *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__GlobalProperties);
	if (soap_out_PointerTons1__GlobalProperties(soap, tag?tag:"ns1:GlobalProperties", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GlobalProperties ** SOAP_FMAC4 soap_get_PointerTons1__GlobalProperties(struct soap *soap, ns1__GlobalProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GlobalProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Execution(struct soap *soap, ns1__Execution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Execution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Execution(struct soap *soap, const char *tag, int id, ns1__Execution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Execution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Execution ** SOAP_FMAC4 soap_in_PointerTons1__Execution(struct soap *soap, const char *tag, ns1__Execution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Execution **)soap_malloc(soap, sizeof(ns1__Execution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Execution *)soap_instantiate_ns1__Execution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Execution ** p = (ns1__Execution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Execution, sizeof(ns1__Execution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Execution(struct soap *soap, ns1__Execution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Execution);
	if (soap_out_PointerTons1__Execution(soap, tag?tag:"ns1:Execution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Execution ** SOAP_FMAC4 soap_get_PointerTons1__Execution(struct soap *soap, ns1__Execution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Execution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTons1__Pipeline(struct soap *soap, std::vector<ns1__Pipeline * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Pipeline))
		soap_serialize_std__vectorTemplateOfPointerTons1__Pipeline(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTons1__Pipeline(struct soap *soap, const char *tag, int id, std::vector<ns1__Pipeline * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTons1__Pipeline(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<ns1__Pipeline * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTons1__Pipeline(struct soap *soap, const char *tag, std::vector<ns1__Pipeline * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<ns1__Pipeline * >**)soap_malloc(soap, sizeof(std::vector<ns1__Pipeline * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTons1__Pipeline(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTons1__Pipeline(struct soap *soap, std::vector<ns1__Pipeline * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTons1__Pipeline);
	if (soap_out_PointerTostd__vectorTemplateOfPointerTons1__Pipeline(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<ns1__Pipeline * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTons1__Pipeline(struct soap *soap, std::vector<ns1__Pipeline * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTons1__Pipeline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Pipeline(struct soap *soap, ns1__Pipeline *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Pipeline))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Pipeline(struct soap *soap, const char *tag, int id, ns1__Pipeline *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Pipeline);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Pipeline ** SOAP_FMAC4 soap_in_PointerTons1__Pipeline(struct soap *soap, const char *tag, ns1__Pipeline **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Pipeline **)soap_malloc(soap, sizeof(ns1__Pipeline *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Pipeline *)soap_instantiate_ns1__Pipeline(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Pipeline ** p = (ns1__Pipeline **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Pipeline, sizeof(ns1__Pipeline), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Pipeline(struct soap *soap, ns1__Pipeline *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Pipeline);
	if (soap_out_PointerTons1__Pipeline(soap, tag?tag:"ns1:Pipeline", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Pipeline ** SOAP_FMAC4 soap_get_PointerTons1__Pipeline(struct soap *soap, ns1__Pipeline **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Pipeline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Response(struct soap *soap, ns1__Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Response(struct soap *soap, const char *tag, int id, ns1__Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Response ** SOAP_FMAC4 soap_in_PointerTons1__Response(struct soap *soap, const char *tag, ns1__Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Response **)soap_malloc(soap, sizeof(ns1__Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Response *)soap_instantiate_ns1__Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Response ** p = (ns1__Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Response, sizeof(ns1__Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Response(struct soap *soap, ns1__Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Response);
	if (soap_out_PointerTons1__Response(soap, tag?tag:"ns1:Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Response ** SOAP_FMAC4 soap_get_PointerTons1__Response(struct soap *soap, ns1__Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__Module(struct soap *soap, std::vector<enum ns1__Module >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__Module(struct soap *soap, const std::vector<enum ns1__Module >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__Module(struct soap *soap, const char *tag, int id, const std::vector<enum ns1__Module >*a, const char *type)
{
	for (std::vector<enum ns1__Module >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__Module(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns1__Module >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__Module(struct soap *soap, const char *tag, std::vector<enum ns1__Module >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfns1__Module(soap, -1)))
		return NULL;
	enum ns1__Module n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_ns1__Module(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__Module, SOAP_TYPE_std__vectorTemplateOfns1__Module, sizeof(enum ns1__Module), 0))
				break;
			if (!soap_in_ns1__Module(soap, tag, NULL, "ns1:Module"))
				break;
		}
		else
		{
			if (!soap_in_ns1__Module(soap, tag, &n, "ns1:Module"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns1__Module > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns1__Module(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__Module(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns1__Module, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns1__Module >);
		if (size)
			*size = sizeof(std::vector<enum ns1__Module >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns1__Module >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum ns1__Module >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ns1__Module >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns1__Module(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ns1__Module > %p -> %p\n", q, p));
	*(std::vector<enum ns1__Module >*)p = *(std::vector<enum ns1__Module >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(struct soap *soap, std::vector<ns1__IntKeyStringValuePair * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(struct soap *soap, const std::vector<ns1__IntKeyStringValuePair * >*a)
{
	for (std::vector<ns1__IntKeyStringValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__IntKeyStringValuePair(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(struct soap *soap, const char *tag, int id, const std::vector<ns1__IntKeyStringValuePair * >*a, const char *type)
{
	for (std::vector<ns1__IntKeyStringValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__IntKeyStringValuePair(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__IntKeyStringValuePair * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(struct soap *soap, const char *tag, std::vector<ns1__IntKeyStringValuePair * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(soap, -1)))
		return NULL;
	ns1__IntKeyStringValuePair *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__IntKeyStringValuePair, SOAP_TYPE_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair, sizeof(ns1__IntKeyStringValuePair), 1))
				break;
			if (!soap_in_PointerTons1__IntKeyStringValuePair(soap, tag, NULL, "ns1:IntKeyStringValuePair"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__IntKeyStringValuePair(soap, tag, &n, "ns1:IntKeyStringValuePair"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__IntKeyStringValuePair * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__IntKeyStringValuePair * >);
		if (size)
			*size = sizeof(std::vector<ns1__IntKeyStringValuePair * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__IntKeyStringValuePair * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__IntKeyStringValuePair * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__IntKeyStringValuePair * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__IntKeyStringValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__IntKeyStringValuePair * > %p -> %p\n", q, p));
	*(std::vector<ns1__IntKeyStringValuePair * >*)p = *(std::vector<ns1__IntKeyStringValuePair * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__PipelineParameter(struct soap *soap, std::vector<ns1__PipelineParameter * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__PipelineParameter(struct soap *soap, const std::vector<ns1__PipelineParameter * >*a)
{
	for (std::vector<ns1__PipelineParameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__PipelineParameter(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__PipelineParameter(struct soap *soap, const char *tag, int id, const std::vector<ns1__PipelineParameter * >*a, const char *type)
{
	for (std::vector<ns1__PipelineParameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__PipelineParameter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__PipelineParameter * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__PipelineParameter(struct soap *soap, const char *tag, std::vector<ns1__PipelineParameter * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__PipelineParameter(soap, -1)))
		return NULL;
	ns1__PipelineParameter *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__PipelineParameter, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PipelineParameter, sizeof(ns1__PipelineParameter), 1))
				break;
			if (!soap_in_PointerTons1__PipelineParameter(soap, tag, NULL, "ns1:PipelineParameter"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__PipelineParameter(soap, tag, &n, "ns1:PipelineParameter"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__PipelineParameter * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__PipelineParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__PipelineParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PipelineParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__PipelineParameter * >);
		if (size)
			*size = sizeof(std::vector<ns1__PipelineParameter * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__PipelineParameter * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__PipelineParameter * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__PipelineParameter * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__PipelineParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__PipelineParameter * > %p -> %p\n", q, p));
	*(std::vector<ns1__PipelineParameter * >*)p = *(std::vector<ns1__PipelineParameter * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(struct soap *soap, std::vector<ns1__StringKeyParameterValuePair * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(struct soap *soap, const std::vector<ns1__StringKeyParameterValuePair * >*a)
{
	for (std::vector<ns1__StringKeyParameterValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__StringKeyParameterValuePair(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(struct soap *soap, const char *tag, int id, const std::vector<ns1__StringKeyParameterValuePair * >*a, const char *type)
{
	for (std::vector<ns1__StringKeyParameterValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__StringKeyParameterValuePair(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__StringKeyParameterValuePair * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(struct soap *soap, const char *tag, std::vector<ns1__StringKeyParameterValuePair * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(soap, -1)))
		return NULL;
	ns1__StringKeyParameterValuePair *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__StringKeyParameterValuePair, SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair, sizeof(ns1__StringKeyParameterValuePair), 1))
				break;
			if (!soap_in_PointerTons1__StringKeyParameterValuePair(soap, tag, NULL, "ns1:StringKeyParameterValuePair"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__StringKeyParameterValuePair(soap, tag, &n, "ns1:StringKeyParameterValuePair"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__StringKeyParameterValuePair * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__StringKeyParameterValuePair * >);
		if (size)
			*size = sizeof(std::vector<ns1__StringKeyParameterValuePair * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__StringKeyParameterValuePair * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__StringKeyParameterValuePair * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__StringKeyParameterValuePair * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__StringKeyParameterValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__StringKeyParameterValuePair * > %p -> %p\n", q, p));
	*(std::vector<ns1__StringKeyParameterValuePair * >*)p = *(std::vector<ns1__StringKeyParameterValuePair * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__StringKeyValuePair(struct soap *soap, std::vector<ns1__StringKeyValuePair * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__StringKeyValuePair(struct soap *soap, const std::vector<ns1__StringKeyValuePair * >*a)
{
	for (std::vector<ns1__StringKeyValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__StringKeyValuePair(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__StringKeyValuePair(struct soap *soap, const char *tag, int id, const std::vector<ns1__StringKeyValuePair * >*a, const char *type)
{
	for (std::vector<ns1__StringKeyValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__StringKeyValuePair(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__StringKeyValuePair * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__StringKeyValuePair(struct soap *soap, const char *tag, std::vector<ns1__StringKeyValuePair * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__StringKeyValuePair(soap, -1)))
		return NULL;
	ns1__StringKeyValuePair *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__StringKeyValuePair, SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringKeyValuePair, sizeof(ns1__StringKeyValuePair), 1))
				break;
			if (!soap_in_PointerTons1__StringKeyValuePair(soap, tag, NULL, "ns1:StringKeyValuePair"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__StringKeyValuePair(soap, tag, &n, "ns1:StringKeyValuePair"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__StringKeyValuePair * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__StringKeyValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__StringKeyValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringKeyValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__StringKeyValuePair * >);
		if (size)
			*size = sizeof(std::vector<ns1__StringKeyValuePair * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__StringKeyValuePair * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__StringKeyValuePair * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__StringKeyValuePair * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__StringKeyValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__StringKeyValuePair * > %p -> %p\n", q, p));
	*(std::vector<ns1__StringKeyValuePair * >*)p = *(std::vector<ns1__StringKeyValuePair * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Execution(struct soap *soap, std::vector<ns1__Execution * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Execution(struct soap *soap, const std::vector<ns1__Execution * >*a)
{
	for (std::vector<ns1__Execution * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Execution(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Execution(struct soap *soap, const char *tag, int id, const std::vector<ns1__Execution * >*a, const char *type)
{
	for (std::vector<ns1__Execution * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Execution(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Execution * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Execution(struct soap *soap, const char *tag, std::vector<ns1__Execution * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Execution(soap, -1)))
		return NULL;
	ns1__Execution *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__Execution, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Execution, sizeof(ns1__Execution), 1))
				break;
			if (!soap_in_PointerTons1__Execution(soap, tag, NULL, "ns1:Execution"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__Execution(soap, tag, &n, "ns1:Execution"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Execution * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Execution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Execution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Execution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__Execution * >);
		if (size)
			*size = sizeof(std::vector<ns1__Execution * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__Execution * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__Execution * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__Execution * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__Execution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__Execution * > %p -> %p\n", q, p));
	*(std::vector<ns1__Execution * >*)p = *(std::vector<ns1__Execution * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, std::vector<ns1__PipelineKeyBooleanValuePair * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, const std::vector<ns1__PipelineKeyBooleanValuePair * >*a)
{
	for (std::vector<ns1__PipelineKeyBooleanValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__PipelineKeyBooleanValuePair(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, int id, const std::vector<ns1__PipelineKeyBooleanValuePair * >*a, const char *type)
{
	for (std::vector<ns1__PipelineKeyBooleanValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__PipelineKeyBooleanValuePair(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__PipelineKeyBooleanValuePair * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, std::vector<ns1__PipelineKeyBooleanValuePair * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(soap, -1)))
		return NULL;
	ns1__PipelineKeyBooleanValuePair *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__PipelineKeyBooleanValuePair, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair, sizeof(ns1__PipelineKeyBooleanValuePair), 1))
				break;
			if (!soap_in_PointerTons1__PipelineKeyBooleanValuePair(soap, tag, NULL, "ns1:PipelineKeyBooleanValuePair"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__PipelineKeyBooleanValuePair(soap, tag, &n, "ns1:PipelineKeyBooleanValuePair"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__PipelineKeyBooleanValuePair * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__PipelineKeyBooleanValuePair * >);
		if (size)
			*size = sizeof(std::vector<ns1__PipelineKeyBooleanValuePair * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__PipelineKeyBooleanValuePair * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__PipelineKeyBooleanValuePair * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__PipelineKeyBooleanValuePair * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__PipelineKeyBooleanValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__PipelineKeyBooleanValuePair * > %p -> %p\n", q, p));
	*(std::vector<ns1__PipelineKeyBooleanValuePair * >*)p = *(std::vector<ns1__PipelineKeyBooleanValuePair * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ArrayOfPipelines(struct soap *soap, std::vector<ns1__ArrayOfPipelines * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ArrayOfPipelines(struct soap *soap, const std::vector<ns1__ArrayOfPipelines * >*a)
{
	for (std::vector<ns1__ArrayOfPipelines * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ArrayOfPipelines(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ArrayOfPipelines(struct soap *soap, const char *tag, int id, const std::vector<ns1__ArrayOfPipelines * >*a, const char *type)
{
	for (std::vector<ns1__ArrayOfPipelines * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ArrayOfPipelines(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ArrayOfPipelines * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ArrayOfPipelines(struct soap *soap, const char *tag, std::vector<ns1__ArrayOfPipelines * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ArrayOfPipelines(soap, -1)))
		return NULL;
	ns1__ArrayOfPipelines *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__ArrayOfPipelines, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfPipelines, sizeof(ns1__ArrayOfPipelines), 1))
				break;
			if (!soap_in_PointerTons1__ArrayOfPipelines(soap, tag, NULL, "ns1:ArrayOfPipelines"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__ArrayOfPipelines(soap, tag, &n, "ns1:ArrayOfPipelines"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ArrayOfPipelines * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ArrayOfPipelines(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ArrayOfPipelines(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfPipelines, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__ArrayOfPipelines * >);
		if (size)
			*size = sizeof(std::vector<ns1__ArrayOfPipelines * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__ArrayOfPipelines * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__ArrayOfPipelines * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__ArrayOfPipelines * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__ArrayOfPipelines(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__ArrayOfPipelines * > %p -> %p\n", q, p));
	*(std::vector<ns1__ArrayOfPipelines * >*)p = *(std::vector<ns1__ArrayOfPipelines * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ArrayOfExecutions(struct soap *soap, std::vector<ns1__ArrayOfExecutions * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ArrayOfExecutions(struct soap *soap, const std::vector<ns1__ArrayOfExecutions * >*a)
{
	for (std::vector<ns1__ArrayOfExecutions * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ArrayOfExecutions(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ArrayOfExecutions(struct soap *soap, const char *tag, int id, const std::vector<ns1__ArrayOfExecutions * >*a, const char *type)
{
	for (std::vector<ns1__ArrayOfExecutions * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ArrayOfExecutions(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ArrayOfExecutions * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ArrayOfExecutions(struct soap *soap, const char *tag, std::vector<ns1__ArrayOfExecutions * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ArrayOfExecutions(soap, -1)))
		return NULL;
	ns1__ArrayOfExecutions *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__ArrayOfExecutions, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfExecutions, sizeof(ns1__ArrayOfExecutions), 1))
				break;
			if (!soap_in_PointerTons1__ArrayOfExecutions(soap, tag, NULL, "ns1:ArrayOfExecutions"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__ArrayOfExecutions(soap, tag, &n, "ns1:ArrayOfExecutions"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ArrayOfExecutions * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ArrayOfExecutions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ArrayOfExecutions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfExecutions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__ArrayOfExecutions * >);
		if (size)
			*size = sizeof(std::vector<ns1__ArrayOfExecutions * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__ArrayOfExecutions * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__ArrayOfExecutions * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__ArrayOfExecutions * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__ArrayOfExecutions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__ArrayOfExecutions * > %p -> %p\n", q, p));
	*(std::vector<ns1__ArrayOfExecutions * >*)p = *(std::vector<ns1__ArrayOfExecutions * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ArrayOfStrings(struct soap *soap, std::vector<ns1__ArrayOfStrings * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ArrayOfStrings(struct soap *soap, const std::vector<ns1__ArrayOfStrings * >*a)
{
	for (std::vector<ns1__ArrayOfStrings * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ArrayOfStrings(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ArrayOfStrings(struct soap *soap, const char *tag, int id, const std::vector<ns1__ArrayOfStrings * >*a, const char *type)
{
	for (std::vector<ns1__ArrayOfStrings * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ArrayOfStrings(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ArrayOfStrings * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ArrayOfStrings(struct soap *soap, const char *tag, std::vector<ns1__ArrayOfStrings * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ArrayOfStrings(soap, -1)))
		return NULL;
	ns1__ArrayOfStrings *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__ArrayOfStrings, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfStrings, sizeof(ns1__ArrayOfStrings), 1))
				break;
			if (!soap_in_PointerTons1__ArrayOfStrings(soap, tag, NULL, "ns1:ArrayOfStrings"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__ArrayOfStrings(soap, tag, &n, "ns1:ArrayOfStrings"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ArrayOfStrings * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ArrayOfStrings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ArrayOfStrings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ArrayOfStrings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__ArrayOfStrings * >);
		if (size)
			*size = sizeof(std::vector<ns1__ArrayOfStrings * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__ArrayOfStrings * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__ArrayOfStrings * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__ArrayOfStrings * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__ArrayOfStrings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__ArrayOfStrings * > %p -> %p\n", q, p));
	*(std::vector<ns1__ArrayOfStrings * >*)p = *(std::vector<ns1__ArrayOfStrings * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Pipeline(struct soap *soap, std::vector<ns1__Pipeline * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Pipeline(struct soap *soap, const std::vector<ns1__Pipeline * >*a)
{
	for (std::vector<ns1__Pipeline * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Pipeline(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Pipeline(struct soap *soap, const char *tag, int id, const std::vector<ns1__Pipeline * >*a, const char *type)
{
	for (std::vector<ns1__Pipeline * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Pipeline(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Pipeline * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Pipeline(struct soap *soap, const char *tag, std::vector<ns1__Pipeline * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Pipeline(soap, -1)))
		return NULL;
	ns1__Pipeline *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__Pipeline, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Pipeline, sizeof(ns1__Pipeline), 1))
				break;
			if (!soap_in_PointerTons1__Pipeline(soap, tag, NULL, "ns1:Pipeline"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__Pipeline(soap, tag, &n, "ns1:Pipeline"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Pipeline * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Pipeline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Pipeline(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Pipeline, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__Pipeline * >);
		if (size)
			*size = sizeof(std::vector<ns1__Pipeline * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__Pipeline * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__Pipeline * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__Pipeline * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__Pipeline(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__Pipeline * > %p -> %p\n", q, p));
	*(std::vector<ns1__Pipeline * >*)p = *(std::vector<ns1__Pipeline * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
