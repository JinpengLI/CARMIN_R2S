/* soapC.cpp
   Generated by gSOAP 2.7.17 from api.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.17 2016-03-11 10:04:49 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_api__Module:
		return soap_in_api__Module(soap, NULL, NULL, "api:Module");
	case SOAP_TYPE_api__ExecutionStatus:
		return soap_in_api__ExecutionStatus(soap, NULL, NULL, "api:ExecutionStatus");
	case SOAP_TYPE_api__ParameterType:
		return soap_in_api__ParameterType(soap, NULL, NULL, "api:ParameterType");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_api__listExecutionsResponse:
		return soap_in_api__listExecutionsResponse(soap, NULL, NULL, "api:listExecutionsResponse");
	case SOAP_TYPE_api__listExecutions:
		return soap_in_api__listExecutions(soap, NULL, NULL, "api:listExecutions");
	case SOAP_TYPE_api__listPipelinesResponse:
		return soap_in_api__listPipelinesResponse(soap, NULL, NULL, "api:listPipelinesResponse");
	case SOAP_TYPE_api__listPipelines:
		return soap_in_api__listPipelines(soap, NULL, NULL, "api:listPipelines");
	case SOAP_TYPE_api__playExecutionResponse:
		return soap_in_api__playExecutionResponse(soap, NULL, NULL, "api:playExecutionResponse");
	case SOAP_TYPE_api__playExecution:
		return soap_in_api__playExecution(soap, NULL, NULL, "api:playExecution");
	case SOAP_TYPE_api__getExecutionResponse:
		return soap_in_api__getExecutionResponse(soap, NULL, NULL, "api:getExecutionResponse");
	case SOAP_TYPE_api__getExecution:
		return soap_in_api__getExecution(soap, NULL, NULL, "api:getExecution");
	case SOAP_TYPE_api__killExecutionResponse:
		return soap_in_api__killExecutionResponse(soap, NULL, NULL, "api:killExecutionResponse");
	case SOAP_TYPE_api__getStdErrResponse:
		return soap_in_api__getStdErrResponse(soap, NULL, NULL, "api:getStdErrResponse");
	case SOAP_TYPE_api__getStdErr:
		return soap_in_api__getStdErr(soap, NULL, NULL, "api:getStdErr");
	case SOAP_TYPE_api__getStdOutResponse:
		return soap_in_api__getStdOutResponse(soap, NULL, NULL, "api:getStdOutResponse");
	case SOAP_TYPE_api__getStdOut:
		return soap_in_api__getStdOut(soap, NULL, NULL, "api:getStdOut");
	case SOAP_TYPE_api__killExecution:
		return soap_in_api__killExecution(soap, NULL, NULL, "api:killExecution");
	case SOAP_TYPE_api__getExecutionResultsResponse:
		return soap_in_api__getExecutionResultsResponse(soap, NULL, NULL, "api:getExecutionResultsResponse");
	case SOAP_TYPE_api__getExecutionResults:
		return soap_in_api__getExecutionResults(soap, NULL, NULL, "api:getExecutionResults");
	case SOAP_TYPE_api__initExecutionResponse:
		return soap_in_api__initExecutionResponse(soap, NULL, NULL, "api:initExecutionResponse");
	case SOAP_TYPE_api__initExecution:
		return soap_in_api__initExecution(soap, NULL, NULL, "api:initExecution");
	case SOAP_TYPE_api__getGlobalPropertiesResponse:
		return soap_in_api__getGlobalPropertiesResponse(soap, NULL, NULL, "api:getGlobalPropertiesResponse");
	case SOAP_TYPE_api__getGlobalProperties:
		return soap_in_api__getGlobalProperties(soap, NULL, NULL, "api:getGlobalProperties");
	case SOAP_TYPE_api__updateExecutionResponse:
		return soap_in_api__updateExecutionResponse(soap, NULL, NULL, "api:updateExecutionResponse");
	case SOAP_TYPE_api__StringKeyValuePair:
		return soap_in_api__StringKeyValuePair(soap, NULL, NULL, "api:StringKeyValuePair");
	case SOAP_TYPE_api__updateExecution:
		return soap_in_api__updateExecution(soap, NULL, NULL, "api:updateExecution");
	case SOAP_TYPE_api__logoutResponse:
		return soap_in_api__logoutResponse(soap, NULL, NULL, "api:logoutResponse");
	case SOAP_TYPE_api__logout:
		return soap_in_api__logout(soap, NULL, NULL, "api:logout");
	case SOAP_TYPE_api__authenticateHTTPResponse:
		return soap_in_api__authenticateHTTPResponse(soap, NULL, NULL, "api:authenticateHTTPResponse");
	case SOAP_TYPE_api__authenticateHTTP:
		return soap_in_api__authenticateHTTP(soap, NULL, NULL, "api:authenticateHTTP");
	case SOAP_TYPE_api__getPipelineResponse:
		return soap_in_api__getPipelineResponse(soap, NULL, NULL, "api:getPipelineResponse");
	case SOAP_TYPE_api__getPipeline:
		return soap_in_api__getPipeline(soap, NULL, NULL, "api:getPipeline");
	case SOAP_TYPE_api__deleteExecutionResponse:
		return soap_in_api__deleteExecutionResponse(soap, NULL, NULL, "api:deleteExecutionResponse");
	case SOAP_TYPE_api__deleteExecution:
		return soap_in_api__deleteExecution(soap, NULL, NULL, "api:deleteExecution");
	case SOAP_TYPE_api__PipelineKeyBooleanValuePair:
		return soap_in_api__PipelineKeyBooleanValuePair(soap, NULL, NULL, "api:PipelineKeyBooleanValuePair");
	case SOAP_TYPE_api__GlobalProperties:
		return soap_in_api__GlobalProperties(soap, NULL, NULL, "api:GlobalProperties");
	case SOAP_TYPE_api__StringKeyParameterValuePair:
		return soap_in_api__StringKeyParameterValuePair(soap, NULL, NULL, "api:StringKeyParameterValuePair");
	case SOAP_TYPE_api__Execution:
		return soap_in_api__Execution(soap, NULL, NULL, "api:Execution");
	case SOAP_TYPE_api__IntKeyStringValuePair:
		return soap_in_api__IntKeyStringValuePair(soap, NULL, NULL, "api:IntKeyStringValuePair");
	case SOAP_TYPE_api__ParameterTypedValue:
		return soap_in_api__ParameterTypedValue(soap, NULL, NULL, "api:ParameterTypedValue");
	case SOAP_TYPE_api__PipelineParameter:
		return soap_in_api__PipelineParameter(soap, NULL, NULL, "api:PipelineParameter");
	case SOAP_TYPE_api__ArrayOfExecutions:
		return soap_in_api__ArrayOfExecutions(soap, NULL, NULL, "api:ArrayOfExecutions");
	case SOAP_TYPE_api__ArrayOfPipelines:
		return soap_in_api__ArrayOfPipelines(soap, NULL, NULL, "api:ArrayOfPipelines");
	case SOAP_TYPE_api__ArrayOfStrings:
		return soap_in_api__ArrayOfStrings(soap, NULL, NULL, "api:ArrayOfStrings");
	case SOAP_TYPE_api__Object:
		return soap_in_api__Object(soap, NULL, NULL, "api:Object");
	case SOAP_TYPE_api__Pipeline:
		return soap_in_api__Pipeline(soap, NULL, NULL, "api:Pipeline");
	case SOAP_TYPE_api__Response:
		return soap_in_api__Response(soap, NULL, NULL, "api:Response");
	case SOAP_TYPE_api__authenticateSessionResponse:
		return soap_in_api__authenticateSessionResponse(soap, NULL, NULL, "api:authenticateSessionResponse");
	case SOAP_TYPE_api__authenticateSession:
		return soap_in_api__authenticateSession(soap, NULL, NULL, "api:authenticateSession");
	case SOAP_TYPE_PointerToapi__listExecutionsResponse:
		return soap_in_PointerToapi__listExecutionsResponse(soap, NULL, NULL, "api:listExecutionsResponse");
	case SOAP_TYPE_PointerToapi__listExecutions:
		return soap_in_PointerToapi__listExecutions(soap, NULL, NULL, "api:listExecutions");
	case SOAP_TYPE_PointerToapi__listPipelinesResponse:
		return soap_in_PointerToapi__listPipelinesResponse(soap, NULL, NULL, "api:listPipelinesResponse");
	case SOAP_TYPE_PointerToapi__listPipelines:
		return soap_in_PointerToapi__listPipelines(soap, NULL, NULL, "api:listPipelines");
	case SOAP_TYPE_PointerToapi__playExecutionResponse:
		return soap_in_PointerToapi__playExecutionResponse(soap, NULL, NULL, "api:playExecutionResponse");
	case SOAP_TYPE_PointerToapi__playExecution:
		return soap_in_PointerToapi__playExecution(soap, NULL, NULL, "api:playExecution");
	case SOAP_TYPE_PointerToapi__getExecutionResponse:
		return soap_in_PointerToapi__getExecutionResponse(soap, NULL, NULL, "api:getExecutionResponse");
	case SOAP_TYPE_PointerToapi__getExecution:
		return soap_in_PointerToapi__getExecution(soap, NULL, NULL, "api:getExecution");
	case SOAP_TYPE_PointerToapi__killExecutionResponse:
		return soap_in_PointerToapi__killExecutionResponse(soap, NULL, NULL, "api:killExecutionResponse");
	case SOAP_TYPE_PointerToapi__killExecution:
		return soap_in_PointerToapi__killExecution(soap, NULL, NULL, "api:killExecution");
	case SOAP_TYPE_PointerToapi__getExecutionResultsResponse:
		return soap_in_PointerToapi__getExecutionResultsResponse(soap, NULL, NULL, "api:getExecutionResultsResponse");
	case SOAP_TYPE_PointerToapi__getExecutionResults:
		return soap_in_PointerToapi__getExecutionResults(soap, NULL, NULL, "api:getExecutionResults");
	case SOAP_TYPE_PointerToapi__getStdErrResponse:
		return soap_in_PointerToapi__getStdErrResponse(soap, NULL, NULL, "api:getStdErrResponse");
	case SOAP_TYPE_PointerToapi__getStdErr:
		return soap_in_PointerToapi__getStdErr(soap, NULL, NULL, "api:getStdErr");
	case SOAP_TYPE_PointerToapi__getStdOutResponse:
		return soap_in_PointerToapi__getStdOutResponse(soap, NULL, NULL, "api:getStdOutResponse");
	case SOAP_TYPE_PointerToapi__getStdOut:
		return soap_in_PointerToapi__getStdOut(soap, NULL, NULL, "api:getStdOut");
	case SOAP_TYPE_PointerToapi__initExecutionResponse:
		return soap_in_PointerToapi__initExecutionResponse(soap, NULL, NULL, "api:initExecutionResponse");
	case SOAP_TYPE_PointerToapi__initExecution:
		return soap_in_PointerToapi__initExecution(soap, NULL, NULL, "api:initExecution");
	case SOAP_TYPE_PointerToapi__getGlobalPropertiesResponse:
		return soap_in_PointerToapi__getGlobalPropertiesResponse(soap, NULL, NULL, "api:getGlobalPropertiesResponse");
	case SOAP_TYPE_PointerToapi__getGlobalProperties:
		return soap_in_PointerToapi__getGlobalProperties(soap, NULL, NULL, "api:getGlobalProperties");
	case SOAP_TYPE_PointerToapi__updateExecutionResponse:
		return soap_in_PointerToapi__updateExecutionResponse(soap, NULL, NULL, "api:updateExecutionResponse");
	case SOAP_TYPE_PointerToapi__updateExecution:
		return soap_in_PointerToapi__updateExecution(soap, NULL, NULL, "api:updateExecution");
	case SOAP_TYPE_PointerToapi__logoutResponse:
		return soap_in_PointerToapi__logoutResponse(soap, NULL, NULL, "api:logoutResponse");
	case SOAP_TYPE_PointerToapi__logout:
		return soap_in_PointerToapi__logout(soap, NULL, NULL, "api:logout");
	case SOAP_TYPE_PointerToapi__authenticateHTTPResponse:
		return soap_in_PointerToapi__authenticateHTTPResponse(soap, NULL, NULL, "api:authenticateHTTPResponse");
	case SOAP_TYPE_PointerToapi__authenticateHTTP:
		return soap_in_PointerToapi__authenticateHTTP(soap, NULL, NULL, "api:authenticateHTTP");
	case SOAP_TYPE_PointerToapi__getPipelineResponse:
		return soap_in_PointerToapi__getPipelineResponse(soap, NULL, NULL, "api:getPipelineResponse");
	case SOAP_TYPE_PointerToapi__getPipeline:
		return soap_in_PointerToapi__getPipeline(soap, NULL, NULL, "api:getPipeline");
	case SOAP_TYPE_PointerToapi__deleteExecutionResponse:
		return soap_in_PointerToapi__deleteExecutionResponse(soap, NULL, NULL, "api:deleteExecutionResponse");
	case SOAP_TYPE_PointerToapi__deleteExecution:
		return soap_in_PointerToapi__deleteExecution(soap, NULL, NULL, "api:deleteExecution");
	case SOAP_TYPE_PointerToapi__authenticateSessionResponse:
		return soap_in_PointerToapi__authenticateSessionResponse(soap, NULL, NULL, "api:authenticateSessionResponse");
	case SOAP_TYPE_PointerToapi__authenticateSession:
		return soap_in_PointerToapi__authenticateSession(soap, NULL, NULL, "api:authenticateSession");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerToapi__IntKeyStringValuePair:
		return soap_in_PointerToapi__IntKeyStringValuePair(soap, NULL, NULL, "api:IntKeyStringValuePair");
	case SOAP_TYPE_PointerToapi__PipelineParameter:
		return soap_in_PointerToapi__PipelineParameter(soap, NULL, NULL, "api:PipelineParameter");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToapi__StringKeyParameterValuePair:
		return soap_in_PointerToapi__StringKeyParameterValuePair(soap, NULL, NULL, "api:StringKeyParameterValuePair");
	case SOAP_TYPE_PointerToapi__StringKeyValuePair:
		return soap_in_PointerToapi__StringKeyValuePair(soap, NULL, NULL, "api:StringKeyValuePair");
	case SOAP_TYPE_PointerToapi__ParameterTypedValue:
		return soap_in_PointerToapi__ParameterTypedValue(soap, NULL, NULL, "api:ParameterTypedValue");
	case SOAP_TYPE_PointerToapi__PipelineKeyBooleanValuePair:
		return soap_in_PointerToapi__PipelineKeyBooleanValuePair(soap, NULL, NULL, "api:PipelineKeyBooleanValuePair");
	case SOAP_TYPE_PointerToapi__ExecutionStatus:
		return soap_in_PointerToapi__ExecutionStatus(soap, NULL, NULL, "api:ExecutionStatus");
	case SOAP_TYPE_PointerToapi__ArrayOfPipelines:
		return soap_in_PointerToapi__ArrayOfPipelines(soap, NULL, NULL, "api:ArrayOfPipelines");
	case SOAP_TYPE_PointerToapi__ArrayOfExecutions:
		return soap_in_PointerToapi__ArrayOfExecutions(soap, NULL, NULL, "api:ArrayOfExecutions");
	case SOAP_TYPE_PointerToapi__ArrayOfStrings:
		return soap_in_PointerToapi__ArrayOfStrings(soap, NULL, NULL, "api:ArrayOfStrings");
	case SOAP_TYPE_PointerToapi__GlobalProperties:
		return soap_in_PointerToapi__GlobalProperties(soap, NULL, NULL, "api:GlobalProperties");
	case SOAP_TYPE_PointerToapi__Execution:
		return soap_in_PointerToapi__Execution(soap, NULL, NULL, "api:Execution");
	case SOAP_TYPE_PointerToapi__Pipeline:
		return soap_in_PointerToapi__Pipeline(soap, NULL, NULL, "api:Pipeline");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToapi__Response:
		return soap_in_PointerToapi__Response(soap, NULL, NULL, "api:Response");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:listExecutionsResponse"))
		{	*type = SOAP_TYPE_api__listExecutionsResponse;
			return soap_in_api__listExecutionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:listExecutions"))
		{	*type = SOAP_TYPE_api__listExecutions;
			return soap_in_api__listExecutions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:listPipelinesResponse"))
		{	*type = SOAP_TYPE_api__listPipelinesResponse;
			return soap_in_api__listPipelinesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:listPipelines"))
		{	*type = SOAP_TYPE_api__listPipelines;
			return soap_in_api__listPipelines(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:playExecutionResponse"))
		{	*type = SOAP_TYPE_api__playExecutionResponse;
			return soap_in_api__playExecutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:playExecution"))
		{	*type = SOAP_TYPE_api__playExecution;
			return soap_in_api__playExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:getExecutionResponse"))
		{	*type = SOAP_TYPE_api__getExecutionResponse;
			return soap_in_api__getExecutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:getExecution"))
		{	*type = SOAP_TYPE_api__getExecution;
			return soap_in_api__getExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:killExecutionResponse"))
		{	*type = SOAP_TYPE_api__killExecutionResponse;
			return soap_in_api__killExecutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:getStdErrResponse"))
		{	*type = SOAP_TYPE_api__getStdErrResponse;
			return soap_in_api__getStdErrResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:getStdErr"))
		{	*type = SOAP_TYPE_api__getStdErr;
			return soap_in_api__getStdErr(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:getStdOutResponse"))
		{	*type = SOAP_TYPE_api__getStdOutResponse;
			return soap_in_api__getStdOutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:getStdOut"))
		{	*type = SOAP_TYPE_api__getStdOut;
			return soap_in_api__getStdOut(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:killExecution"))
		{	*type = SOAP_TYPE_api__killExecution;
			return soap_in_api__killExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:getExecutionResultsResponse"))
		{	*type = SOAP_TYPE_api__getExecutionResultsResponse;
			return soap_in_api__getExecutionResultsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:getExecutionResults"))
		{	*type = SOAP_TYPE_api__getExecutionResults;
			return soap_in_api__getExecutionResults(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:initExecutionResponse"))
		{	*type = SOAP_TYPE_api__initExecutionResponse;
			return soap_in_api__initExecutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:initExecution"))
		{	*type = SOAP_TYPE_api__initExecution;
			return soap_in_api__initExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:getGlobalPropertiesResponse"))
		{	*type = SOAP_TYPE_api__getGlobalPropertiesResponse;
			return soap_in_api__getGlobalPropertiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:getGlobalProperties"))
		{	*type = SOAP_TYPE_api__getGlobalProperties;
			return soap_in_api__getGlobalProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:updateExecutionResponse"))
		{	*type = SOAP_TYPE_api__updateExecutionResponse;
			return soap_in_api__updateExecutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:StringKeyValuePair"))
		{	*type = SOAP_TYPE_api__StringKeyValuePair;
			return soap_in_api__StringKeyValuePair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:updateExecution"))
		{	*type = SOAP_TYPE_api__updateExecution;
			return soap_in_api__updateExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:logoutResponse"))
		{	*type = SOAP_TYPE_api__logoutResponse;
			return soap_in_api__logoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:logout"))
		{	*type = SOAP_TYPE_api__logout;
			return soap_in_api__logout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:authenticateHTTPResponse"))
		{	*type = SOAP_TYPE_api__authenticateHTTPResponse;
			return soap_in_api__authenticateHTTPResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:authenticateHTTP"))
		{	*type = SOAP_TYPE_api__authenticateHTTP;
			return soap_in_api__authenticateHTTP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:getPipelineResponse"))
		{	*type = SOAP_TYPE_api__getPipelineResponse;
			return soap_in_api__getPipelineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:getPipeline"))
		{	*type = SOAP_TYPE_api__getPipeline;
			return soap_in_api__getPipeline(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:deleteExecutionResponse"))
		{	*type = SOAP_TYPE_api__deleteExecutionResponse;
			return soap_in_api__deleteExecutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:deleteExecution"))
		{	*type = SOAP_TYPE_api__deleteExecution;
			return soap_in_api__deleteExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:PipelineKeyBooleanValuePair"))
		{	*type = SOAP_TYPE_api__PipelineKeyBooleanValuePair;
			return soap_in_api__PipelineKeyBooleanValuePair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:GlobalProperties"))
		{	*type = SOAP_TYPE_api__GlobalProperties;
			return soap_in_api__GlobalProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:StringKeyParameterValuePair"))
		{	*type = SOAP_TYPE_api__StringKeyParameterValuePair;
			return soap_in_api__StringKeyParameterValuePair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:Execution"))
		{	*type = SOAP_TYPE_api__Execution;
			return soap_in_api__Execution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:IntKeyStringValuePair"))
		{	*type = SOAP_TYPE_api__IntKeyStringValuePair;
			return soap_in_api__IntKeyStringValuePair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:ParameterTypedValue"))
		{	*type = SOAP_TYPE_api__ParameterTypedValue;
			return soap_in_api__ParameterTypedValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:PipelineParameter"))
		{	*type = SOAP_TYPE_api__PipelineParameter;
			return soap_in_api__PipelineParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:ArrayOfExecutions"))
		{	*type = SOAP_TYPE_api__ArrayOfExecutions;
			return soap_in_api__ArrayOfExecutions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:ArrayOfPipelines"))
		{	*type = SOAP_TYPE_api__ArrayOfPipelines;
			return soap_in_api__ArrayOfPipelines(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:ArrayOfStrings"))
		{	*type = SOAP_TYPE_api__ArrayOfStrings;
			return soap_in_api__ArrayOfStrings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:Object"))
		{	*type = SOAP_TYPE_api__Object;
			return soap_in_api__Object(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:Pipeline"))
		{	*type = SOAP_TYPE_api__Pipeline;
			return soap_in_api__Pipeline(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:Response"))
		{	*type = SOAP_TYPE_api__Response;
			return soap_in_api__Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:authenticateSessionResponse"))
		{	*type = SOAP_TYPE_api__authenticateSessionResponse;
			return soap_in_api__authenticateSessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:authenticateSession"))
		{	*type = SOAP_TYPE_api__authenticateSession;
			return soap_in_api__authenticateSession(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:Module"))
		{	*type = SOAP_TYPE_api__Module;
			return soap_in_api__Module(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:ExecutionStatus"))
		{	*type = SOAP_TYPE_api__ExecutionStatus;
			return soap_in_api__ExecutionStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "api:ParameterType"))
		{	*type = SOAP_TYPE_api__ParameterType;
			return soap_in_api__ParameterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_api__Module:
		return soap_out_api__Module(soap, tag, id, (const enum api__Module *)ptr, "api:Module");
	case SOAP_TYPE_api__ExecutionStatus:
		return soap_out_api__ExecutionStatus(soap, tag, id, (const enum api__ExecutionStatus *)ptr, "api:ExecutionStatus");
	case SOAP_TYPE_api__ParameterType:
		return soap_out_api__ParameterType(soap, tag, id, (const enum api__ParameterType *)ptr, "api:ParameterType");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_api__listExecutionsResponse:
		return ((api__listExecutionsResponse *)ptr)->soap_out(soap, tag, id, "api:listExecutionsResponse");
	case SOAP_TYPE_api__listExecutions:
		return ((api__listExecutions *)ptr)->soap_out(soap, tag, id, "api:listExecutions");
	case SOAP_TYPE_api__listPipelinesResponse:
		return ((api__listPipelinesResponse *)ptr)->soap_out(soap, tag, id, "api:listPipelinesResponse");
	case SOAP_TYPE_api__listPipelines:
		return ((api__listPipelines *)ptr)->soap_out(soap, tag, id, "api:listPipelines");
	case SOAP_TYPE_api__playExecutionResponse:
		return ((api__playExecutionResponse *)ptr)->soap_out(soap, tag, id, "api:playExecutionResponse");
	case SOAP_TYPE_api__playExecution:
		return ((api__playExecution *)ptr)->soap_out(soap, tag, id, "api:playExecution");
	case SOAP_TYPE_api__getExecutionResponse:
		return ((api__getExecutionResponse *)ptr)->soap_out(soap, tag, id, "api:getExecutionResponse");
	case SOAP_TYPE_api__getExecution:
		return ((api__getExecution *)ptr)->soap_out(soap, tag, id, "api:getExecution");
	case SOAP_TYPE_api__killExecutionResponse:
		return ((api__killExecutionResponse *)ptr)->soap_out(soap, tag, id, "api:killExecutionResponse");
	case SOAP_TYPE_api__getStdErrResponse:
		return ((api__getStdErrResponse *)ptr)->soap_out(soap, tag, id, "api:getStdErrResponse");
	case SOAP_TYPE_api__getStdErr:
		return ((api__getStdErr *)ptr)->soap_out(soap, tag, id, "api:getStdErr");
	case SOAP_TYPE_api__getStdOutResponse:
		return ((api__getStdOutResponse *)ptr)->soap_out(soap, tag, id, "api:getStdOutResponse");
	case SOAP_TYPE_api__getStdOut:
		return ((api__getStdOut *)ptr)->soap_out(soap, tag, id, "api:getStdOut");
	case SOAP_TYPE_api__killExecution:
		return ((api__killExecution *)ptr)->soap_out(soap, tag, id, "api:killExecution");
	case SOAP_TYPE_api__getExecutionResultsResponse:
		return ((api__getExecutionResultsResponse *)ptr)->soap_out(soap, tag, id, "api:getExecutionResultsResponse");
	case SOAP_TYPE_api__getExecutionResults:
		return ((api__getExecutionResults *)ptr)->soap_out(soap, tag, id, "api:getExecutionResults");
	case SOAP_TYPE_api__initExecutionResponse:
		return ((api__initExecutionResponse *)ptr)->soap_out(soap, tag, id, "api:initExecutionResponse");
	case SOAP_TYPE_api__initExecution:
		return ((api__initExecution *)ptr)->soap_out(soap, tag, id, "api:initExecution");
	case SOAP_TYPE_api__getGlobalPropertiesResponse:
		return ((api__getGlobalPropertiesResponse *)ptr)->soap_out(soap, tag, id, "api:getGlobalPropertiesResponse");
	case SOAP_TYPE_api__getGlobalProperties:
		return ((api__getGlobalProperties *)ptr)->soap_out(soap, tag, id, "api:getGlobalProperties");
	case SOAP_TYPE_api__updateExecutionResponse:
		return ((api__updateExecutionResponse *)ptr)->soap_out(soap, tag, id, "api:updateExecutionResponse");
	case SOAP_TYPE_api__StringKeyValuePair:
		return ((api__StringKeyValuePair *)ptr)->soap_out(soap, tag, id, "api:StringKeyValuePair");
	case SOAP_TYPE_api__updateExecution:
		return ((api__updateExecution *)ptr)->soap_out(soap, tag, id, "api:updateExecution");
	case SOAP_TYPE_api__logoutResponse:
		return ((api__logoutResponse *)ptr)->soap_out(soap, tag, id, "api:logoutResponse");
	case SOAP_TYPE_api__logout:
		return ((api__logout *)ptr)->soap_out(soap, tag, id, "api:logout");
	case SOAP_TYPE_api__authenticateHTTPResponse:
		return ((api__authenticateHTTPResponse *)ptr)->soap_out(soap, tag, id, "api:authenticateHTTPResponse");
	case SOAP_TYPE_api__authenticateHTTP:
		return ((api__authenticateHTTP *)ptr)->soap_out(soap, tag, id, "api:authenticateHTTP");
	case SOAP_TYPE_api__getPipelineResponse:
		return ((api__getPipelineResponse *)ptr)->soap_out(soap, tag, id, "api:getPipelineResponse");
	case SOAP_TYPE_api__getPipeline:
		return ((api__getPipeline *)ptr)->soap_out(soap, tag, id, "api:getPipeline");
	case SOAP_TYPE_api__deleteExecutionResponse:
		return ((api__deleteExecutionResponse *)ptr)->soap_out(soap, tag, id, "api:deleteExecutionResponse");
	case SOAP_TYPE_api__deleteExecution:
		return ((api__deleteExecution *)ptr)->soap_out(soap, tag, id, "api:deleteExecution");
	case SOAP_TYPE_api__PipelineKeyBooleanValuePair:
		return ((api__PipelineKeyBooleanValuePair *)ptr)->soap_out(soap, tag, id, "api:PipelineKeyBooleanValuePair");
	case SOAP_TYPE_api__GlobalProperties:
		return ((api__GlobalProperties *)ptr)->soap_out(soap, tag, id, "api:GlobalProperties");
	case SOAP_TYPE_api__StringKeyParameterValuePair:
		return ((api__StringKeyParameterValuePair *)ptr)->soap_out(soap, tag, id, "api:StringKeyParameterValuePair");
	case SOAP_TYPE_api__Execution:
		return ((api__Execution *)ptr)->soap_out(soap, tag, id, "api:Execution");
	case SOAP_TYPE_api__IntKeyStringValuePair:
		return ((api__IntKeyStringValuePair *)ptr)->soap_out(soap, tag, id, "api:IntKeyStringValuePair");
	case SOAP_TYPE_api__ParameterTypedValue:
		return ((api__ParameterTypedValue *)ptr)->soap_out(soap, tag, id, "api:ParameterTypedValue");
	case SOAP_TYPE_api__PipelineParameter:
		return ((api__PipelineParameter *)ptr)->soap_out(soap, tag, id, "api:PipelineParameter");
	case SOAP_TYPE_api__ArrayOfExecutions:
		return ((api__ArrayOfExecutions *)ptr)->soap_out(soap, tag, id, "api:ArrayOfExecutions");
	case SOAP_TYPE_api__ArrayOfPipelines:
		return ((api__ArrayOfPipelines *)ptr)->soap_out(soap, tag, id, "api:ArrayOfPipelines");
	case SOAP_TYPE_api__ArrayOfStrings:
		return ((api__ArrayOfStrings *)ptr)->soap_out(soap, tag, id, "api:ArrayOfStrings");
	case SOAP_TYPE_api__Object:
		return ((api__Object *)ptr)->soap_out(soap, tag, id, "api:Object");
	case SOAP_TYPE_api__Pipeline:
		return ((api__Pipeline *)ptr)->soap_out(soap, tag, id, "api:Pipeline");
	case SOAP_TYPE_api__Response:
		return ((api__Response *)ptr)->soap_out(soap, tag, id, "api:Response");
	case SOAP_TYPE_api__authenticateSessionResponse:
		return ((api__authenticateSessionResponse *)ptr)->soap_out(soap, tag, id, "api:authenticateSessionResponse");
	case SOAP_TYPE_api__authenticateSession:
		return ((api__authenticateSession *)ptr)->soap_out(soap, tag, id, "api:authenticateSession");
	case SOAP_TYPE_PointerToapi__listExecutionsResponse:
		return soap_out_PointerToapi__listExecutionsResponse(soap, tag, id, (api__listExecutionsResponse *const*)ptr, "api:listExecutionsResponse");
	case SOAP_TYPE_PointerToapi__listExecutions:
		return soap_out_PointerToapi__listExecutions(soap, tag, id, (api__listExecutions *const*)ptr, "api:listExecutions");
	case SOAP_TYPE_PointerToapi__listPipelinesResponse:
		return soap_out_PointerToapi__listPipelinesResponse(soap, tag, id, (api__listPipelinesResponse *const*)ptr, "api:listPipelinesResponse");
	case SOAP_TYPE_PointerToapi__listPipelines:
		return soap_out_PointerToapi__listPipelines(soap, tag, id, (api__listPipelines *const*)ptr, "api:listPipelines");
	case SOAP_TYPE_PointerToapi__playExecutionResponse:
		return soap_out_PointerToapi__playExecutionResponse(soap, tag, id, (api__playExecutionResponse *const*)ptr, "api:playExecutionResponse");
	case SOAP_TYPE_PointerToapi__playExecution:
		return soap_out_PointerToapi__playExecution(soap, tag, id, (api__playExecution *const*)ptr, "api:playExecution");
	case SOAP_TYPE_PointerToapi__getExecutionResponse:
		return soap_out_PointerToapi__getExecutionResponse(soap, tag, id, (api__getExecutionResponse *const*)ptr, "api:getExecutionResponse");
	case SOAP_TYPE_PointerToapi__getExecution:
		return soap_out_PointerToapi__getExecution(soap, tag, id, (api__getExecution *const*)ptr, "api:getExecution");
	case SOAP_TYPE_PointerToapi__killExecutionResponse:
		return soap_out_PointerToapi__killExecutionResponse(soap, tag, id, (api__killExecutionResponse *const*)ptr, "api:killExecutionResponse");
	case SOAP_TYPE_PointerToapi__killExecution:
		return soap_out_PointerToapi__killExecution(soap, tag, id, (api__killExecution *const*)ptr, "api:killExecution");
	case SOAP_TYPE_PointerToapi__getExecutionResultsResponse:
		return soap_out_PointerToapi__getExecutionResultsResponse(soap, tag, id, (api__getExecutionResultsResponse *const*)ptr, "api:getExecutionResultsResponse");
	case SOAP_TYPE_PointerToapi__getExecutionResults:
		return soap_out_PointerToapi__getExecutionResults(soap, tag, id, (api__getExecutionResults *const*)ptr, "api:getExecutionResults");
	case SOAP_TYPE_PointerToapi__getStdErrResponse:
		return soap_out_PointerToapi__getStdErrResponse(soap, tag, id, (api__getStdErrResponse *const*)ptr, "api:getStdErrResponse");
	case SOAP_TYPE_PointerToapi__getStdErr:
		return soap_out_PointerToapi__getStdErr(soap, tag, id, (api__getStdErr *const*)ptr, "api:getStdErr");
	case SOAP_TYPE_PointerToapi__getStdOutResponse:
		return soap_out_PointerToapi__getStdOutResponse(soap, tag, id, (api__getStdOutResponse *const*)ptr, "api:getStdOutResponse");
	case SOAP_TYPE_PointerToapi__getStdOut:
		return soap_out_PointerToapi__getStdOut(soap, tag, id, (api__getStdOut *const*)ptr, "api:getStdOut");
	case SOAP_TYPE_PointerToapi__initExecutionResponse:
		return soap_out_PointerToapi__initExecutionResponse(soap, tag, id, (api__initExecutionResponse *const*)ptr, "api:initExecutionResponse");
	case SOAP_TYPE_PointerToapi__initExecution:
		return soap_out_PointerToapi__initExecution(soap, tag, id, (api__initExecution *const*)ptr, "api:initExecution");
	case SOAP_TYPE_PointerToapi__getGlobalPropertiesResponse:
		return soap_out_PointerToapi__getGlobalPropertiesResponse(soap, tag, id, (api__getGlobalPropertiesResponse *const*)ptr, "api:getGlobalPropertiesResponse");
	case SOAP_TYPE_PointerToapi__getGlobalProperties:
		return soap_out_PointerToapi__getGlobalProperties(soap, tag, id, (api__getGlobalProperties *const*)ptr, "api:getGlobalProperties");
	case SOAP_TYPE_PointerToapi__updateExecutionResponse:
		return soap_out_PointerToapi__updateExecutionResponse(soap, tag, id, (api__updateExecutionResponse *const*)ptr, "api:updateExecutionResponse");
	case SOAP_TYPE_PointerToapi__updateExecution:
		return soap_out_PointerToapi__updateExecution(soap, tag, id, (api__updateExecution *const*)ptr, "api:updateExecution");
	case SOAP_TYPE_PointerToapi__logoutResponse:
		return soap_out_PointerToapi__logoutResponse(soap, tag, id, (api__logoutResponse *const*)ptr, "api:logoutResponse");
	case SOAP_TYPE_PointerToapi__logout:
		return soap_out_PointerToapi__logout(soap, tag, id, (api__logout *const*)ptr, "api:logout");
	case SOAP_TYPE_PointerToapi__authenticateHTTPResponse:
		return soap_out_PointerToapi__authenticateHTTPResponse(soap, tag, id, (api__authenticateHTTPResponse *const*)ptr, "api:authenticateHTTPResponse");
	case SOAP_TYPE_PointerToapi__authenticateHTTP:
		return soap_out_PointerToapi__authenticateHTTP(soap, tag, id, (api__authenticateHTTP *const*)ptr, "api:authenticateHTTP");
	case SOAP_TYPE_PointerToapi__getPipelineResponse:
		return soap_out_PointerToapi__getPipelineResponse(soap, tag, id, (api__getPipelineResponse *const*)ptr, "api:getPipelineResponse");
	case SOAP_TYPE_PointerToapi__getPipeline:
		return soap_out_PointerToapi__getPipeline(soap, tag, id, (api__getPipeline *const*)ptr, "api:getPipeline");
	case SOAP_TYPE_PointerToapi__deleteExecutionResponse:
		return soap_out_PointerToapi__deleteExecutionResponse(soap, tag, id, (api__deleteExecutionResponse *const*)ptr, "api:deleteExecutionResponse");
	case SOAP_TYPE_PointerToapi__deleteExecution:
		return soap_out_PointerToapi__deleteExecution(soap, tag, id, (api__deleteExecution *const*)ptr, "api:deleteExecution");
	case SOAP_TYPE_PointerToapi__authenticateSessionResponse:
		return soap_out_PointerToapi__authenticateSessionResponse(soap, tag, id, (api__authenticateSessionResponse *const*)ptr, "api:authenticateSessionResponse");
	case SOAP_TYPE_PointerToapi__authenticateSession:
		return soap_out_PointerToapi__authenticateSession(soap, tag, id, (api__authenticateSession *const*)ptr, "api:authenticateSession");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerToapi__IntKeyStringValuePair:
		return soap_out_PointerToapi__IntKeyStringValuePair(soap, tag, id, (api__IntKeyStringValuePair *const*)ptr, "api:IntKeyStringValuePair");
	case SOAP_TYPE_PointerToapi__PipelineParameter:
		return soap_out_PointerToapi__PipelineParameter(soap, tag, id, (api__PipelineParameter *const*)ptr, "api:PipelineParameter");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToapi__StringKeyParameterValuePair:
		return soap_out_PointerToapi__StringKeyParameterValuePair(soap, tag, id, (api__StringKeyParameterValuePair *const*)ptr, "api:StringKeyParameterValuePair");
	case SOAP_TYPE_PointerToapi__StringKeyValuePair:
		return soap_out_PointerToapi__StringKeyValuePair(soap, tag, id, (api__StringKeyValuePair *const*)ptr, "api:StringKeyValuePair");
	case SOAP_TYPE_PointerToapi__ParameterTypedValue:
		return soap_out_PointerToapi__ParameterTypedValue(soap, tag, id, (api__ParameterTypedValue *const*)ptr, "api:ParameterTypedValue");
	case SOAP_TYPE_PointerToapi__PipelineKeyBooleanValuePair:
		return soap_out_PointerToapi__PipelineKeyBooleanValuePair(soap, tag, id, (api__PipelineKeyBooleanValuePair *const*)ptr, "api:PipelineKeyBooleanValuePair");
	case SOAP_TYPE_PointerToapi__ExecutionStatus:
		return soap_out_PointerToapi__ExecutionStatus(soap, tag, id, (enum api__ExecutionStatus *const*)ptr, "api:ExecutionStatus");
	case SOAP_TYPE_PointerToapi__ArrayOfPipelines:
		return soap_out_PointerToapi__ArrayOfPipelines(soap, tag, id, (api__ArrayOfPipelines *const*)ptr, "api:ArrayOfPipelines");
	case SOAP_TYPE_PointerToapi__ArrayOfExecutions:
		return soap_out_PointerToapi__ArrayOfExecutions(soap, tag, id, (api__ArrayOfExecutions *const*)ptr, "api:ArrayOfExecutions");
	case SOAP_TYPE_PointerToapi__ArrayOfStrings:
		return soap_out_PointerToapi__ArrayOfStrings(soap, tag, id, (api__ArrayOfStrings *const*)ptr, "api:ArrayOfStrings");
	case SOAP_TYPE_PointerToapi__GlobalProperties:
		return soap_out_PointerToapi__GlobalProperties(soap, tag, id, (api__GlobalProperties *const*)ptr, "api:GlobalProperties");
	case SOAP_TYPE_PointerToapi__Execution:
		return soap_out_PointerToapi__Execution(soap, tag, id, (api__Execution *const*)ptr, "api:Execution");
	case SOAP_TYPE_PointerToapi__Pipeline:
		return soap_out_PointerToapi__Pipeline(soap, tag, id, (api__Pipeline *const*)ptr, "api:Pipeline");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToapi__Response:
		return soap_out_PointerToapi__Response(soap, tag, id, (api__Response *const*)ptr, "api:Response");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_api__listExecutionsResponse:
		((api__listExecutionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__listExecutions:
		((api__listExecutions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__listPipelinesResponse:
		((api__listPipelinesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__listPipelines:
		((api__listPipelines *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__playExecutionResponse:
		((api__playExecutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__playExecution:
		((api__playExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__getExecutionResponse:
		((api__getExecutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__getExecution:
		((api__getExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__killExecutionResponse:
		((api__killExecutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__getStdErrResponse:
		((api__getStdErrResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__getStdErr:
		((api__getStdErr *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__getStdOutResponse:
		((api__getStdOutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__getStdOut:
		((api__getStdOut *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__killExecution:
		((api__killExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__getExecutionResultsResponse:
		((api__getExecutionResultsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__getExecutionResults:
		((api__getExecutionResults *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__initExecutionResponse:
		((api__initExecutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__initExecution:
		((api__initExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__getGlobalPropertiesResponse:
		((api__getGlobalPropertiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__getGlobalProperties:
		((api__getGlobalProperties *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__updateExecutionResponse:
		((api__updateExecutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__StringKeyValuePair:
		((api__StringKeyValuePair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__updateExecution:
		((api__updateExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__logoutResponse:
		((api__logoutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__logout:
		((api__logout *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__authenticateHTTPResponse:
		((api__authenticateHTTPResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__authenticateHTTP:
		((api__authenticateHTTP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__getPipelineResponse:
		((api__getPipelineResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__getPipeline:
		((api__getPipeline *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__deleteExecutionResponse:
		((api__deleteExecutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__deleteExecution:
		((api__deleteExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__PipelineKeyBooleanValuePair:
		((api__PipelineKeyBooleanValuePair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__GlobalProperties:
		((api__GlobalProperties *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__StringKeyParameterValuePair:
		((api__StringKeyParameterValuePair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__Execution:
		((api__Execution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__IntKeyStringValuePair:
		((api__IntKeyStringValuePair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__ParameterTypedValue:
		((api__ParameterTypedValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__PipelineParameter:
		((api__PipelineParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__ArrayOfExecutions:
		((api__ArrayOfExecutions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__ArrayOfPipelines:
		((api__ArrayOfPipelines *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__ArrayOfStrings:
		((api__ArrayOfStrings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__Object:
		((api__Object *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__Pipeline:
		((api__Pipeline *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__Response:
		((api__Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__authenticateSessionResponse:
		((api__authenticateSessionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_api__authenticateSession:
		((api__authenticateSession *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___api__listExecutions:
		soap_serialize___api__listExecutions(soap, (const struct __api__listExecutions *)ptr);
		break;
	case SOAP_TYPE___api__listPipelines:
		soap_serialize___api__listPipelines(soap, (const struct __api__listPipelines *)ptr);
		break;
	case SOAP_TYPE___api__playExecution:
		soap_serialize___api__playExecution(soap, (const struct __api__playExecution *)ptr);
		break;
	case SOAP_TYPE___api__getExecution:
		soap_serialize___api__getExecution(soap, (const struct __api__getExecution *)ptr);
		break;
	case SOAP_TYPE___api__killExecution:
		soap_serialize___api__killExecution(soap, (const struct __api__killExecution *)ptr);
		break;
	case SOAP_TYPE___api__getExecutionResults:
		soap_serialize___api__getExecutionResults(soap, (const struct __api__getExecutionResults *)ptr);
		break;
	case SOAP_TYPE___api__getStdErr:
		soap_serialize___api__getStdErr(soap, (const struct __api__getStdErr *)ptr);
		break;
	case SOAP_TYPE___api__getStdOut:
		soap_serialize___api__getStdOut(soap, (const struct __api__getStdOut *)ptr);
		break;
	case SOAP_TYPE___api__initExecution:
		soap_serialize___api__initExecution(soap, (const struct __api__initExecution *)ptr);
		break;
	case SOAP_TYPE___api__getGlobalProperties:
		soap_serialize___api__getGlobalProperties(soap, (const struct __api__getGlobalProperties *)ptr);
		break;
	case SOAP_TYPE___api__updateExecution:
		soap_serialize___api__updateExecution(soap, (const struct __api__updateExecution *)ptr);
		break;
	case SOAP_TYPE___api__logout:
		soap_serialize___api__logout(soap, (const struct __api__logout *)ptr);
		break;
	case SOAP_TYPE___api__authenticateHTTP:
		soap_serialize___api__authenticateHTTP(soap, (const struct __api__authenticateHTTP *)ptr);
		break;
	case SOAP_TYPE___api__getPipeline:
		soap_serialize___api__getPipeline(soap, (const struct __api__getPipeline *)ptr);
		break;
	case SOAP_TYPE___api__deleteExecution:
		soap_serialize___api__deleteExecution(soap, (const struct __api__deleteExecution *)ptr);
		break;
	case SOAP_TYPE___api__authenticateSession:
		soap_serialize___api__authenticateSession(soap, (const struct __api__authenticateSession *)ptr);
		break;
	case SOAP_TYPE_PointerToapi__listExecutionsResponse:
		soap_serialize_PointerToapi__listExecutionsResponse(soap, (api__listExecutionsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__listExecutions:
		soap_serialize_PointerToapi__listExecutions(soap, (api__listExecutions *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__listPipelinesResponse:
		soap_serialize_PointerToapi__listPipelinesResponse(soap, (api__listPipelinesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__listPipelines:
		soap_serialize_PointerToapi__listPipelines(soap, (api__listPipelines *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__playExecutionResponse:
		soap_serialize_PointerToapi__playExecutionResponse(soap, (api__playExecutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__playExecution:
		soap_serialize_PointerToapi__playExecution(soap, (api__playExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__getExecutionResponse:
		soap_serialize_PointerToapi__getExecutionResponse(soap, (api__getExecutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__getExecution:
		soap_serialize_PointerToapi__getExecution(soap, (api__getExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__killExecutionResponse:
		soap_serialize_PointerToapi__killExecutionResponse(soap, (api__killExecutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__killExecution:
		soap_serialize_PointerToapi__killExecution(soap, (api__killExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__getExecutionResultsResponse:
		soap_serialize_PointerToapi__getExecutionResultsResponse(soap, (api__getExecutionResultsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__getExecutionResults:
		soap_serialize_PointerToapi__getExecutionResults(soap, (api__getExecutionResults *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__getStdErrResponse:
		soap_serialize_PointerToapi__getStdErrResponse(soap, (api__getStdErrResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__getStdErr:
		soap_serialize_PointerToapi__getStdErr(soap, (api__getStdErr *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__getStdOutResponse:
		soap_serialize_PointerToapi__getStdOutResponse(soap, (api__getStdOutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__getStdOut:
		soap_serialize_PointerToapi__getStdOut(soap, (api__getStdOut *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__initExecutionResponse:
		soap_serialize_PointerToapi__initExecutionResponse(soap, (api__initExecutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__initExecution:
		soap_serialize_PointerToapi__initExecution(soap, (api__initExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__getGlobalPropertiesResponse:
		soap_serialize_PointerToapi__getGlobalPropertiesResponse(soap, (api__getGlobalPropertiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__getGlobalProperties:
		soap_serialize_PointerToapi__getGlobalProperties(soap, (api__getGlobalProperties *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__updateExecutionResponse:
		soap_serialize_PointerToapi__updateExecutionResponse(soap, (api__updateExecutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__updateExecution:
		soap_serialize_PointerToapi__updateExecution(soap, (api__updateExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__logoutResponse:
		soap_serialize_PointerToapi__logoutResponse(soap, (api__logoutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__logout:
		soap_serialize_PointerToapi__logout(soap, (api__logout *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__authenticateHTTPResponse:
		soap_serialize_PointerToapi__authenticateHTTPResponse(soap, (api__authenticateHTTPResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__authenticateHTTP:
		soap_serialize_PointerToapi__authenticateHTTP(soap, (api__authenticateHTTP *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__getPipelineResponse:
		soap_serialize_PointerToapi__getPipelineResponse(soap, (api__getPipelineResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__getPipeline:
		soap_serialize_PointerToapi__getPipeline(soap, (api__getPipeline *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__deleteExecutionResponse:
		soap_serialize_PointerToapi__deleteExecutionResponse(soap, (api__deleteExecutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__deleteExecution:
		soap_serialize_PointerToapi__deleteExecution(soap, (api__deleteExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__authenticateSessionResponse:
		soap_serialize_PointerToapi__authenticateSessionResponse(soap, (api__authenticateSessionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__authenticateSession:
		soap_serialize_PointerToapi__authenticateSession(soap, (api__authenticateSession *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__IntKeyStringValuePair:
		soap_serialize_PointerToapi__IntKeyStringValuePair(soap, (api__IntKeyStringValuePair *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__PipelineParameter:
		soap_serialize_PointerToapi__PipelineParameter(soap, (api__PipelineParameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__StringKeyParameterValuePair:
		soap_serialize_PointerToapi__StringKeyParameterValuePair(soap, (api__StringKeyParameterValuePair *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__StringKeyValuePair:
		soap_serialize_PointerToapi__StringKeyValuePair(soap, (api__StringKeyValuePair *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__ParameterTypedValue:
		soap_serialize_PointerToapi__ParameterTypedValue(soap, (api__ParameterTypedValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__PipelineKeyBooleanValuePair:
		soap_serialize_PointerToapi__PipelineKeyBooleanValuePair(soap, (api__PipelineKeyBooleanValuePair *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__ExecutionStatus:
		soap_serialize_PointerToapi__ExecutionStatus(soap, (enum api__ExecutionStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__ArrayOfPipelines:
		soap_serialize_PointerToapi__ArrayOfPipelines(soap, (api__ArrayOfPipelines *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__ArrayOfExecutions:
		soap_serialize_PointerToapi__ArrayOfExecutions(soap, (api__ArrayOfExecutions *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__ArrayOfStrings:
		soap_serialize_PointerToapi__ArrayOfStrings(soap, (api__ArrayOfStrings *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__GlobalProperties:
		soap_serialize_PointerToapi__GlobalProperties(soap, (api__GlobalProperties *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__Execution:
		soap_serialize_PointerToapi__Execution(soap, (api__Execution *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__Pipeline:
		soap_serialize_PointerToapi__Pipeline(soap, (api__Pipeline *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapi__Response:
		soap_serialize_PointerToapi__Response(soap, (api__Response *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__authenticateSession:
		return (void*)soap_instantiate_api__authenticateSession(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__authenticateSessionResponse:
		return (void*)soap_instantiate_api__authenticateSessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__Response:
		return (void*)soap_instantiate_api__Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__Object:
		return (void*)soap_instantiate_api__Object(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__ArrayOfStrings:
		return (void*)soap_instantiate_api__ArrayOfStrings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__ArrayOfPipelines:
		return (void*)soap_instantiate_api__ArrayOfPipelines(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__ArrayOfExecutions:
		return (void*)soap_instantiate_api__ArrayOfExecutions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__PipelineParameter:
		return (void*)soap_instantiate_api__PipelineParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__ParameterTypedValue:
		return (void*)soap_instantiate_api__ParameterTypedValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__IntKeyStringValuePair:
		return (void*)soap_instantiate_api__IntKeyStringValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__StringKeyParameterValuePair:
		return (void*)soap_instantiate_api__StringKeyParameterValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__PipelineKeyBooleanValuePair:
		return (void*)soap_instantiate_api__PipelineKeyBooleanValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__deleteExecution:
		return (void*)soap_instantiate_api__deleteExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__deleteExecutionResponse:
		return (void*)soap_instantiate_api__deleteExecutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__getPipeline:
		return (void*)soap_instantiate_api__getPipeline(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__getPipelineResponse:
		return (void*)soap_instantiate_api__getPipelineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__authenticateHTTP:
		return (void*)soap_instantiate_api__authenticateHTTP(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__authenticateHTTPResponse:
		return (void*)soap_instantiate_api__authenticateHTTPResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__logout:
		return (void*)soap_instantiate_api__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__logoutResponse:
		return (void*)soap_instantiate_api__logoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__updateExecution:
		return (void*)soap_instantiate_api__updateExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__StringKeyValuePair:
		return (void*)soap_instantiate_api__StringKeyValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__updateExecutionResponse:
		return (void*)soap_instantiate_api__updateExecutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__getGlobalProperties:
		return (void*)soap_instantiate_api__getGlobalProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__getGlobalPropertiesResponse:
		return (void*)soap_instantiate_api__getGlobalPropertiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__initExecution:
		return (void*)soap_instantiate_api__initExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__initExecutionResponse:
		return (void*)soap_instantiate_api__initExecutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__getExecutionResults:
		return (void*)soap_instantiate_api__getExecutionResults(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__getExecutionResultsResponse:
		return (void*)soap_instantiate_api__getExecutionResultsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__killExecution:
		return (void*)soap_instantiate_api__killExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__getStdOut:
		return (void*)soap_instantiate_api__getStdOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__getStdOutResponse:
		return (void*)soap_instantiate_api__getStdOutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__getStdErr:
		return (void*)soap_instantiate_api__getStdErr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__getStdErrResponse:
		return (void*)soap_instantiate_api__getStdErrResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__killExecutionResponse:
		return (void*)soap_instantiate_api__killExecutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__getExecution:
		return (void*)soap_instantiate_api__getExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__getExecutionResponse:
		return (void*)soap_instantiate_api__getExecutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__playExecution:
		return (void*)soap_instantiate_api__playExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__playExecutionResponse:
		return (void*)soap_instantiate_api__playExecutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__listPipelines:
		return (void*)soap_instantiate_api__listPipelines(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__listPipelinesResponse:
		return (void*)soap_instantiate_api__listPipelinesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__listExecutions:
		return (void*)soap_instantiate_api__listExecutions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__listExecutionsResponse:
		return (void*)soap_instantiate_api__listExecutionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__Pipeline:
		return (void*)soap_instantiate_api__Pipeline(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__Execution:
		return (void*)soap_instantiate_api__Execution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_api__GlobalProperties:
		return (void*)soap_instantiate_api__GlobalProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__authenticateSession:
		return (void*)soap_instantiate___api__authenticateSession(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__deleteExecution:
		return (void*)soap_instantiate___api__deleteExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__getPipeline:
		return (void*)soap_instantiate___api__getPipeline(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__authenticateHTTP:
		return (void*)soap_instantiate___api__authenticateHTTP(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__logout:
		return (void*)soap_instantiate___api__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__updateExecution:
		return (void*)soap_instantiate___api__updateExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__getGlobalProperties:
		return (void*)soap_instantiate___api__getGlobalProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__initExecution:
		return (void*)soap_instantiate___api__initExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__getStdOut:
		return (void*)soap_instantiate___api__getStdOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__getStdErr:
		return (void*)soap_instantiate___api__getStdErr(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__getExecutionResults:
		return (void*)soap_instantiate___api__getExecutionResults(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__killExecution:
		return (void*)soap_instantiate___api__killExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__getExecution:
		return (void*)soap_instantiate___api__getExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__playExecution:
		return (void*)soap_instantiate___api__playExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__listPipelines:
		return (void*)soap_instantiate___api__listPipelines(soap, -1, type, arrayType, n);
	case SOAP_TYPE___api__listExecutions:
		return (void*)soap_instantiate___api__listExecutions(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfapi__Module:
		return (void*)soap_instantiate_std__vectorTemplateOfapi__Module(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__PipelineParameter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToapi__PipelineParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__StringKeyValuePair:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToapi__StringKeyValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__Execution:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToapi__Execution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfPipelines:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToapi__ArrayOfPipelines(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfExecutions:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToapi__ArrayOfExecutions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfStrings:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToapi__ArrayOfStrings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__Pipeline:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToapi__Pipeline(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_api__authenticateSession:
		if (p->size < 0)
			SOAP_DELETE((api__authenticateSession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__authenticateSession*)p->ptr);
		break;
	case SOAP_TYPE_api__authenticateSessionResponse:
		if (p->size < 0)
			SOAP_DELETE((api__authenticateSessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__authenticateSessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__Response:
		if (p->size < 0)
			SOAP_DELETE((api__Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__Response*)p->ptr);
		break;
	case SOAP_TYPE_api__Object:
		if (p->size < 0)
			SOAP_DELETE((api__Object*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__Object*)p->ptr);
		break;
	case SOAP_TYPE_api__ArrayOfStrings:
		if (p->size < 0)
			SOAP_DELETE((api__ArrayOfStrings*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__ArrayOfStrings*)p->ptr);
		break;
	case SOAP_TYPE_api__ArrayOfPipelines:
		if (p->size < 0)
			SOAP_DELETE((api__ArrayOfPipelines*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__ArrayOfPipelines*)p->ptr);
		break;
	case SOAP_TYPE_api__ArrayOfExecutions:
		if (p->size < 0)
			SOAP_DELETE((api__ArrayOfExecutions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__ArrayOfExecutions*)p->ptr);
		break;
	case SOAP_TYPE_api__PipelineParameter:
		if (p->size < 0)
			SOAP_DELETE((api__PipelineParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__PipelineParameter*)p->ptr);
		break;
	case SOAP_TYPE_api__ParameterTypedValue:
		if (p->size < 0)
			SOAP_DELETE((api__ParameterTypedValue*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__ParameterTypedValue*)p->ptr);
		break;
	case SOAP_TYPE_api__IntKeyStringValuePair:
		if (p->size < 0)
			SOAP_DELETE((api__IntKeyStringValuePair*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__IntKeyStringValuePair*)p->ptr);
		break;
	case SOAP_TYPE_api__StringKeyParameterValuePair:
		if (p->size < 0)
			SOAP_DELETE((api__StringKeyParameterValuePair*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__StringKeyParameterValuePair*)p->ptr);
		break;
	case SOAP_TYPE_api__PipelineKeyBooleanValuePair:
		if (p->size < 0)
			SOAP_DELETE((api__PipelineKeyBooleanValuePair*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__PipelineKeyBooleanValuePair*)p->ptr);
		break;
	case SOAP_TYPE_api__deleteExecution:
		if (p->size < 0)
			SOAP_DELETE((api__deleteExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__deleteExecution*)p->ptr);
		break;
	case SOAP_TYPE_api__deleteExecutionResponse:
		if (p->size < 0)
			SOAP_DELETE((api__deleteExecutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__deleteExecutionResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__getPipeline:
		if (p->size < 0)
			SOAP_DELETE((api__getPipeline*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__getPipeline*)p->ptr);
		break;
	case SOAP_TYPE_api__getPipelineResponse:
		if (p->size < 0)
			SOAP_DELETE((api__getPipelineResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__getPipelineResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__authenticateHTTP:
		if (p->size < 0)
			SOAP_DELETE((api__authenticateHTTP*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__authenticateHTTP*)p->ptr);
		break;
	case SOAP_TYPE_api__authenticateHTTPResponse:
		if (p->size < 0)
			SOAP_DELETE((api__authenticateHTTPResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__authenticateHTTPResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__logout:
		if (p->size < 0)
			SOAP_DELETE((api__logout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__logout*)p->ptr);
		break;
	case SOAP_TYPE_api__logoutResponse:
		if (p->size < 0)
			SOAP_DELETE((api__logoutResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__logoutResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__updateExecution:
		if (p->size < 0)
			SOAP_DELETE((api__updateExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__updateExecution*)p->ptr);
		break;
	case SOAP_TYPE_api__StringKeyValuePair:
		if (p->size < 0)
			SOAP_DELETE((api__StringKeyValuePair*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__StringKeyValuePair*)p->ptr);
		break;
	case SOAP_TYPE_api__updateExecutionResponse:
		if (p->size < 0)
			SOAP_DELETE((api__updateExecutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__updateExecutionResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__getGlobalProperties:
		if (p->size < 0)
			SOAP_DELETE((api__getGlobalProperties*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__getGlobalProperties*)p->ptr);
		break;
	case SOAP_TYPE_api__getGlobalPropertiesResponse:
		if (p->size < 0)
			SOAP_DELETE((api__getGlobalPropertiesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__getGlobalPropertiesResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__initExecution:
		if (p->size < 0)
			SOAP_DELETE((api__initExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__initExecution*)p->ptr);
		break;
	case SOAP_TYPE_api__initExecutionResponse:
		if (p->size < 0)
			SOAP_DELETE((api__initExecutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__initExecutionResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__getExecutionResults:
		if (p->size < 0)
			SOAP_DELETE((api__getExecutionResults*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__getExecutionResults*)p->ptr);
		break;
	case SOAP_TYPE_api__getExecutionResultsResponse:
		if (p->size < 0)
			SOAP_DELETE((api__getExecutionResultsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__getExecutionResultsResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__killExecution:
		if (p->size < 0)
			SOAP_DELETE((api__killExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__killExecution*)p->ptr);
		break;
	case SOAP_TYPE_api__getStdOut:
		if (p->size < 0)
			SOAP_DELETE((api__getStdOut*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__getStdOut*)p->ptr);
		break;
	case SOAP_TYPE_api__getStdOutResponse:
		if (p->size < 0)
			SOAP_DELETE((api__getStdOutResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__getStdOutResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__getStdErr:
		if (p->size < 0)
			SOAP_DELETE((api__getStdErr*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__getStdErr*)p->ptr);
		break;
	case SOAP_TYPE_api__getStdErrResponse:
		if (p->size < 0)
			SOAP_DELETE((api__getStdErrResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__getStdErrResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__killExecutionResponse:
		if (p->size < 0)
			SOAP_DELETE((api__killExecutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__killExecutionResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__getExecution:
		if (p->size < 0)
			SOAP_DELETE((api__getExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__getExecution*)p->ptr);
		break;
	case SOAP_TYPE_api__getExecutionResponse:
		if (p->size < 0)
			SOAP_DELETE((api__getExecutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__getExecutionResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__playExecution:
		if (p->size < 0)
			SOAP_DELETE((api__playExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__playExecution*)p->ptr);
		break;
	case SOAP_TYPE_api__playExecutionResponse:
		if (p->size < 0)
			SOAP_DELETE((api__playExecutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__playExecutionResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__listPipelines:
		if (p->size < 0)
			SOAP_DELETE((api__listPipelines*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__listPipelines*)p->ptr);
		break;
	case SOAP_TYPE_api__listPipelinesResponse:
		if (p->size < 0)
			SOAP_DELETE((api__listPipelinesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__listPipelinesResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__listExecutions:
		if (p->size < 0)
			SOAP_DELETE((api__listExecutions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__listExecutions*)p->ptr);
		break;
	case SOAP_TYPE_api__listExecutionsResponse:
		if (p->size < 0)
			SOAP_DELETE((api__listExecutionsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__listExecutionsResponse*)p->ptr);
		break;
	case SOAP_TYPE_api__Pipeline:
		if (p->size < 0)
			SOAP_DELETE((api__Pipeline*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__Pipeline*)p->ptr);
		break;
	case SOAP_TYPE_api__Execution:
		if (p->size < 0)
			SOAP_DELETE((api__Execution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__Execution*)p->ptr);
		break;
	case SOAP_TYPE_api__GlobalProperties:
		if (p->size < 0)
			SOAP_DELETE((api__GlobalProperties*)p->ptr);
		else
			SOAP_DELETE_ARRAY((api__GlobalProperties*)p->ptr);
		break;
	case SOAP_TYPE___api__authenticateSession:
		if (p->size < 0)
			SOAP_DELETE((struct __api__authenticateSession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__authenticateSession*)p->ptr);
		break;
	case SOAP_TYPE___api__deleteExecution:
		if (p->size < 0)
			SOAP_DELETE((struct __api__deleteExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__deleteExecution*)p->ptr);
		break;
	case SOAP_TYPE___api__getPipeline:
		if (p->size < 0)
			SOAP_DELETE((struct __api__getPipeline*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__getPipeline*)p->ptr);
		break;
	case SOAP_TYPE___api__authenticateHTTP:
		if (p->size < 0)
			SOAP_DELETE((struct __api__authenticateHTTP*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__authenticateHTTP*)p->ptr);
		break;
	case SOAP_TYPE___api__logout:
		if (p->size < 0)
			SOAP_DELETE((struct __api__logout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__logout*)p->ptr);
		break;
	case SOAP_TYPE___api__updateExecution:
		if (p->size < 0)
			SOAP_DELETE((struct __api__updateExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__updateExecution*)p->ptr);
		break;
	case SOAP_TYPE___api__getGlobalProperties:
		if (p->size < 0)
			SOAP_DELETE((struct __api__getGlobalProperties*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__getGlobalProperties*)p->ptr);
		break;
	case SOAP_TYPE___api__initExecution:
		if (p->size < 0)
			SOAP_DELETE((struct __api__initExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__initExecution*)p->ptr);
		break;
	case SOAP_TYPE___api__getStdOut:
		if (p->size < 0)
			SOAP_DELETE((struct __api__getStdOut*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__getStdOut*)p->ptr);
		break;
	case SOAP_TYPE___api__getStdErr:
		if (p->size < 0)
			SOAP_DELETE((struct __api__getStdErr*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__getStdErr*)p->ptr);
		break;
	case SOAP_TYPE___api__getExecutionResults:
		if (p->size < 0)
			SOAP_DELETE((struct __api__getExecutionResults*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__getExecutionResults*)p->ptr);
		break;
	case SOAP_TYPE___api__killExecution:
		if (p->size < 0)
			SOAP_DELETE((struct __api__killExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__killExecution*)p->ptr);
		break;
	case SOAP_TYPE___api__getExecution:
		if (p->size < 0)
			SOAP_DELETE((struct __api__getExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__getExecution*)p->ptr);
		break;
	case SOAP_TYPE___api__playExecution:
		if (p->size < 0)
			SOAP_DELETE((struct __api__playExecution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__playExecution*)p->ptr);
		break;
	case SOAP_TYPE___api__listPipelines:
		if (p->size < 0)
			SOAP_DELETE((struct __api__listPipelines*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__listPipelines*)p->ptr);
		break;
	case SOAP_TYPE___api__listExecutions:
		if (p->size < 0)
			SOAP_DELETE((struct __api__listExecutions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __api__listExecutions*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfapi__Module:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum api__Module >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum api__Module >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair:
		if (p->size < 0)
			SOAP_DELETE((std::vector<api__IntKeyStringValuePair * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<api__IntKeyStringValuePair * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__PipelineParameter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<api__PipelineParameter * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<api__PipelineParameter * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair:
		if (p->size < 0)
			SOAP_DELETE((std::vector<api__StringKeyParameterValuePair * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<api__StringKeyParameterValuePair * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__StringKeyValuePair:
		if (p->size < 0)
			SOAP_DELETE((std::vector<api__StringKeyValuePair * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<api__StringKeyValuePair * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__Execution:
		if (p->size < 0)
			SOAP_DELETE((std::vector<api__Execution * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<api__Execution * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair:
		if (p->size < 0)
			SOAP_DELETE((std::vector<api__PipelineKeyBooleanValuePair * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<api__PipelineKeyBooleanValuePair * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfPipelines:
		if (p->size < 0)
			SOAP_DELETE((std::vector<api__ArrayOfPipelines * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<api__ArrayOfPipelines * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfExecutions:
		if (p->size < 0)
			SOAP_DELETE((std::vector<api__ArrayOfExecutions * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<api__ArrayOfExecutions * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfStrings:
		if (p->size < 0)
			SOAP_DELETE((std::vector<api__ArrayOfStrings * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<api__ArrayOfStrings * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__Pipeline:
		if (p->size < 0)
			SOAP_DELETE((std::vector<api__Pipeline * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<api__Pipeline * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfapi__Module:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum api__Module >*)p)[len] = *(enum api__Module *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<api__IntKeyStringValuePair * >*)p)[len] = *(api__IntKeyStringValuePair **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__PipelineParameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<api__PipelineParameter * >*)p)[len] = *(api__PipelineParameter **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<api__StringKeyParameterValuePair * >*)p)[len] = *(api__StringKeyParameterValuePair **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__StringKeyValuePair:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<api__StringKeyValuePair * >*)p)[len] = *(api__StringKeyValuePair **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__Execution:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<api__Execution * >*)p)[len] = *(api__Execution **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<api__PipelineKeyBooleanValuePair * >*)p)[len] = *(api__PipelineKeyBooleanValuePair **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfPipelines:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<api__ArrayOfPipelines * >*)p)[len] = *(api__ArrayOfPipelines **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfExecutions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<api__ArrayOfExecutions * >*)p)[len] = *(api__ArrayOfExecutions **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfStrings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<api__ArrayOfStrings * >*)p)[len] = *(api__ArrayOfStrings **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToapi__Pipeline:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<api__Pipeline * >*)p)[len] = *(api__Pipeline **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_api__Module(struct soap *soap, enum api__Module *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_api__Module
	*a = SOAP_DEFAULT_api__Module;
#else
	*a = (enum api__Module)0;
#endif
}

static const struct soap_code_map soap_codes_api__Module[] =
{	{ (long)api__Module__Processing, "Processing" },
	{ (long)api__Module__Data, "Data" },
	{ (long)api__Module__Management, "Management" },
	{ (long)api__Module__Commercial, "Commercial" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_api__Module2s(struct soap *soap, enum api__Module n)
{	const char *s = soap_code_str(soap_codes_api__Module, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__Module(struct soap *soap, const char *tag, int id, const enum api__Module *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__Module), type) || soap_send(soap, soap_api__Module2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2api__Module(struct soap *soap, const char *s, enum api__Module *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_api__Module, s);
	if (map)
		*a = (enum api__Module)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum api__Module)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum api__Module * SOAP_FMAC4 soap_in_api__Module(struct soap *soap, const char *tag, enum api__Module *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum api__Module *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_api__Module, sizeof(enum api__Module), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2api__Module(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum api__Module *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__Module, 0, sizeof(enum api__Module), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_api__Module(struct soap *soap, const enum api__Module *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_api__Module);
	if (soap_out_api__Module(soap, tag?tag:"api:Module", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum api__Module * SOAP_FMAC4 soap_get_api__Module(struct soap *soap, enum api__Module *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__Module(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_api__ExecutionStatus(struct soap *soap, enum api__ExecutionStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_api__ExecutionStatus
	*a = SOAP_DEFAULT_api__ExecutionStatus;
#else
	*a = (enum api__ExecutionStatus)0;
#endif
}

static const struct soap_code_map soap_codes_api__ExecutionStatus[] =
{	{ (long)api__ExecutionStatus__Initializing, "Initializing" },
	{ (long)api__ExecutionStatus__Ready, "Ready" },
	{ (long)api__ExecutionStatus__Running, "Running" },
	{ (long)api__ExecutionStatus__Finished, "Finished" },
	{ (long)api__ExecutionStatus__InitializationFailed, "InitializationFailed" },
	{ (long)api__ExecutionStatus__ExecutionFailed, "ExecutionFailed" },
	{ (long)api__ExecutionStatus__Unknown, "Unknown" },
	{ (long)api__ExecutionStatus__Killed, "Killed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_api__ExecutionStatus2s(struct soap *soap, enum api__ExecutionStatus n)
{	const char *s = soap_code_str(soap_codes_api__ExecutionStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__ExecutionStatus(struct soap *soap, const char *tag, int id, const enum api__ExecutionStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__ExecutionStatus), type) || soap_send(soap, soap_api__ExecutionStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2api__ExecutionStatus(struct soap *soap, const char *s, enum api__ExecutionStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_api__ExecutionStatus, s);
	if (map)
		*a = (enum api__ExecutionStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum api__ExecutionStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum api__ExecutionStatus * SOAP_FMAC4 soap_in_api__ExecutionStatus(struct soap *soap, const char *tag, enum api__ExecutionStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum api__ExecutionStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_api__ExecutionStatus, sizeof(enum api__ExecutionStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2api__ExecutionStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum api__ExecutionStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__ExecutionStatus, 0, sizeof(enum api__ExecutionStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_api__ExecutionStatus(struct soap *soap, const enum api__ExecutionStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_api__ExecutionStatus);
	if (soap_out_api__ExecutionStatus(soap, tag?tag:"api:ExecutionStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum api__ExecutionStatus * SOAP_FMAC4 soap_get_api__ExecutionStatus(struct soap *soap, enum api__ExecutionStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__ExecutionStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_api__ParameterType(struct soap *soap, enum api__ParameterType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_api__ParameterType
	*a = SOAP_DEFAULT_api__ParameterType;
#else
	*a = (enum api__ParameterType)0;
#endif
}

static const struct soap_code_map soap_codes_api__ParameterType[] =
{	{ (long)api__ParameterType__File, "File" },
	{ (long)api__ParameterType__String, "String" },
	{ (long)api__ParameterType__Boolean, "Boolean" },
	{ (long)api__ParameterType__Int64, "Int64" },
	{ (long)api__ParameterType__Double, "Double" },
	{ (long)api__ParameterType__List, "List" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_api__ParameterType2s(struct soap *soap, enum api__ParameterType n)
{	const char *s = soap_code_str(soap_codes_api__ParameterType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__ParameterType(struct soap *soap, const char *tag, int id, const enum api__ParameterType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__ParameterType), type) || soap_send(soap, soap_api__ParameterType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2api__ParameterType(struct soap *soap, const char *s, enum api__ParameterType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_api__ParameterType, s);
	if (map)
		*a = (enum api__ParameterType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum api__ParameterType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum api__ParameterType * SOAP_FMAC4 soap_in_api__ParameterType(struct soap *soap, const char *tag, enum api__ParameterType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum api__ParameterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_api__ParameterType, sizeof(enum api__ParameterType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2api__ParameterType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum api__ParameterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__ParameterType, 0, sizeof(enum api__ParameterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_api__ParameterType(struct soap *soap, const enum api__ParameterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_api__ParameterType);
	if (soap_out_api__ParameterType(soap, tag?tag:"api:ParameterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum api__ParameterType * SOAP_FMAC4 soap_get_api__ParameterType(struct soap *soap, enum api__ParameterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__ParameterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void api__listExecutionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__listExecutionsResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__listExecutionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__listExecutionsResponse::return_);
	/* transient soap skipped */
}

int api__listExecutionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__listExecutionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__listExecutionsResponse(struct soap *soap, const char *tag, int id, const api__listExecutionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__listExecutionsResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__listExecutionsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__listExecutionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__listExecutionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__listExecutionsResponse * SOAP_FMAC4 soap_in_api__listExecutionsResponse(struct soap *soap, const char *tag, api__listExecutionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__listExecutionsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__listExecutionsResponse, sizeof(api__listExecutionsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__listExecutionsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__listExecutionsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__listExecutionsResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__listExecutionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__listExecutionsResponse, 0, sizeof(api__listExecutionsResponse), 0, soap_copy_api__listExecutionsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__listExecutionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__listExecutionsResponse);
	if (this->soap_out(soap, tag?tag:"api:listExecutionsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__listExecutionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__listExecutionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__listExecutionsResponse * SOAP_FMAC4 soap_get_api__listExecutionsResponse(struct soap *soap, api__listExecutionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__listExecutionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__listExecutionsResponse * SOAP_FMAC2 soap_instantiate_api__listExecutionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__listExecutionsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__listExecutionsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__listExecutionsResponse);
		if (size)
			*size = sizeof(api__listExecutionsResponse);
		((api__listExecutionsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__listExecutionsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__listExecutionsResponse);
		for (int i = 0; i < n; i++)
			((api__listExecutionsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__listExecutionsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__listExecutionsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__listExecutionsResponse %p -> %p\n", q, p));
	*(api__listExecutionsResponse*)p = *(api__listExecutionsResponse*)q;
}

void api__listExecutions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__listExecutions::studyIdentifier);
	/* transient soap skipped */
}

void api__listExecutions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__listExecutions::studyIdentifier, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__listExecutions::studyIdentifier);
	/* transient soap skipped */
}

int api__listExecutions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__listExecutions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__listExecutions(struct soap *soap, const char *tag, int id, const api__listExecutions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__listExecutions), type))
		return soap->error;
	if (soap_out_std__string(soap, "studyIdentifier", -1, &(a->api__listExecutions::studyIdentifier), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__listExecutions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__listExecutions(soap, tag, this, type);
}

SOAP_FMAC3 api__listExecutions * SOAP_FMAC4 soap_in_api__listExecutions(struct soap *soap, const char *tag, api__listExecutions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__listExecutions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__listExecutions, sizeof(api__listExecutions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__listExecutions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__listExecutions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_studyIdentifier1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_studyIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "studyIdentifier", &(a->api__listExecutions::studyIdentifier), "xsd:string"))
				{	soap_flag_studyIdentifier1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__listExecutions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__listExecutions, 0, sizeof(api__listExecutions), 0, soap_copy_api__listExecutions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_studyIdentifier1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__listExecutions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__listExecutions);
	if (this->soap_out(soap, tag?tag:"api:listExecutions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__listExecutions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__listExecutions(soap, this, tag, type);
}

SOAP_FMAC3 api__listExecutions * SOAP_FMAC4 soap_get_api__listExecutions(struct soap *soap, api__listExecutions *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__listExecutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__listExecutions * SOAP_FMAC2 soap_instantiate_api__listExecutions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__listExecutions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__listExecutions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__listExecutions);
		if (size)
			*size = sizeof(api__listExecutions);
		((api__listExecutions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__listExecutions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__listExecutions);
		for (int i = 0; i < n; i++)
			((api__listExecutions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__listExecutions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__listExecutions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__listExecutions %p -> %p\n", q, p));
	*(api__listExecutions*)p = *(api__listExecutions*)q;
}

void api__listPipelinesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__listPipelinesResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__listPipelinesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__listPipelinesResponse::return_);
	/* transient soap skipped */
}

int api__listPipelinesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__listPipelinesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__listPipelinesResponse(struct soap *soap, const char *tag, int id, const api__listPipelinesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__listPipelinesResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__listPipelinesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__listPipelinesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__listPipelinesResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__listPipelinesResponse * SOAP_FMAC4 soap_in_api__listPipelinesResponse(struct soap *soap, const char *tag, api__listPipelinesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__listPipelinesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__listPipelinesResponse, sizeof(api__listPipelinesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__listPipelinesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__listPipelinesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__listPipelinesResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__listPipelinesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__listPipelinesResponse, 0, sizeof(api__listPipelinesResponse), 0, soap_copy_api__listPipelinesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__listPipelinesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__listPipelinesResponse);
	if (this->soap_out(soap, tag?tag:"api:listPipelinesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__listPipelinesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__listPipelinesResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__listPipelinesResponse * SOAP_FMAC4 soap_get_api__listPipelinesResponse(struct soap *soap, api__listPipelinesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__listPipelinesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__listPipelinesResponse * SOAP_FMAC2 soap_instantiate_api__listPipelinesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__listPipelinesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__listPipelinesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__listPipelinesResponse);
		if (size)
			*size = sizeof(api__listPipelinesResponse);
		((api__listPipelinesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__listPipelinesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__listPipelinesResponse);
		for (int i = 0; i < n; i++)
			((api__listPipelinesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__listPipelinesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__listPipelinesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__listPipelinesResponse %p -> %p\n", q, p));
	*(api__listPipelinesResponse*)p = *(api__listPipelinesResponse*)q;
}

void api__listPipelines::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__listPipelines::studyIdentifier);
	/* transient soap skipped */
}

void api__listPipelines::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__listPipelines::studyIdentifier, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__listPipelines::studyIdentifier);
	/* transient soap skipped */
}

int api__listPipelines::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__listPipelines(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__listPipelines(struct soap *soap, const char *tag, int id, const api__listPipelines *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__listPipelines), type))
		return soap->error;
	if (soap_out_std__string(soap, "studyIdentifier", -1, &(a->api__listPipelines::studyIdentifier), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__listPipelines::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__listPipelines(soap, tag, this, type);
}

SOAP_FMAC3 api__listPipelines * SOAP_FMAC4 soap_in_api__listPipelines(struct soap *soap, const char *tag, api__listPipelines *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__listPipelines *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__listPipelines, sizeof(api__listPipelines), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__listPipelines)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__listPipelines *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_studyIdentifier1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_studyIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "studyIdentifier", &(a->api__listPipelines::studyIdentifier), "xsd:string"))
				{	soap_flag_studyIdentifier1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__listPipelines *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__listPipelines, 0, sizeof(api__listPipelines), 0, soap_copy_api__listPipelines);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_studyIdentifier1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__listPipelines::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__listPipelines);
	if (this->soap_out(soap, tag?tag:"api:listPipelines", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__listPipelines::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__listPipelines(soap, this, tag, type);
}

SOAP_FMAC3 api__listPipelines * SOAP_FMAC4 soap_get_api__listPipelines(struct soap *soap, api__listPipelines *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__listPipelines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__listPipelines * SOAP_FMAC2 soap_instantiate_api__listPipelines(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__listPipelines(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__listPipelines, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__listPipelines);
		if (size)
			*size = sizeof(api__listPipelines);
		((api__listPipelines*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__listPipelines[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__listPipelines);
		for (int i = 0; i < n; i++)
			((api__listPipelines*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__listPipelines*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__listPipelines(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__listPipelines %p -> %p\n", q, p));
	*(api__listPipelines*)p = *(api__listPipelines*)q;
}

void api__playExecutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__playExecutionResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__playExecutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__playExecutionResponse::return_);
	/* transient soap skipped */
}

int api__playExecutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__playExecutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__playExecutionResponse(struct soap *soap, const char *tag, int id, const api__playExecutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__playExecutionResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__playExecutionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__playExecutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__playExecutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__playExecutionResponse * SOAP_FMAC4 soap_in_api__playExecutionResponse(struct soap *soap, const char *tag, api__playExecutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__playExecutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__playExecutionResponse, sizeof(api__playExecutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__playExecutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__playExecutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__playExecutionResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__playExecutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__playExecutionResponse, 0, sizeof(api__playExecutionResponse), 0, soap_copy_api__playExecutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__playExecutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__playExecutionResponse);
	if (this->soap_out(soap, tag?tag:"api:playExecutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__playExecutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__playExecutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__playExecutionResponse * SOAP_FMAC4 soap_get_api__playExecutionResponse(struct soap *soap, api__playExecutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__playExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__playExecutionResponse * SOAP_FMAC2 soap_instantiate_api__playExecutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__playExecutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__playExecutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__playExecutionResponse);
		if (size)
			*size = sizeof(api__playExecutionResponse);
		((api__playExecutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__playExecutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__playExecutionResponse);
		for (int i = 0; i < n; i++)
			((api__playExecutionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__playExecutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__playExecutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__playExecutionResponse %p -> %p\n", q, p));
	*(api__playExecutionResponse*)p = *(api__playExecutionResponse*)q;
}

void api__playExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__playExecution::executionId);
	/* transient soap skipped */
}

void api__playExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__playExecution::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__playExecution::executionId);
	/* transient soap skipped */
}

int api__playExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__playExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__playExecution(struct soap *soap, const char *tag, int id, const api__playExecution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__playExecution), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->api__playExecution::executionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__playExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__playExecution(soap, tag, this, type);
}

SOAP_FMAC3 api__playExecution * SOAP_FMAC4 soap_in_api__playExecution(struct soap *soap, const char *tag, api__playExecution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__playExecution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__playExecution, sizeof(api__playExecution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__playExecution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__playExecution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->api__playExecution::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__playExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__playExecution, 0, sizeof(api__playExecution), 0, soap_copy_api__playExecution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__playExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__playExecution);
	if (this->soap_out(soap, tag?tag:"api:playExecution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__playExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__playExecution(soap, this, tag, type);
}

SOAP_FMAC3 api__playExecution * SOAP_FMAC4 soap_get_api__playExecution(struct soap *soap, api__playExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__playExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__playExecution * SOAP_FMAC2 soap_instantiate_api__playExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__playExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__playExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__playExecution);
		if (size)
			*size = sizeof(api__playExecution);
		((api__playExecution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__playExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__playExecution);
		for (int i = 0; i < n; i++)
			((api__playExecution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__playExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__playExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__playExecution %p -> %p\n", q, p));
	*(api__playExecution*)p = *(api__playExecution*)q;
}

void api__getExecutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__getExecutionResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__getExecutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__getExecutionResponse::return_);
	/* transient soap skipped */
}

int api__getExecutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__getExecutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__getExecutionResponse(struct soap *soap, const char *tag, int id, const api__getExecutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__getExecutionResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__getExecutionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__getExecutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__getExecutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__getExecutionResponse * SOAP_FMAC4 soap_in_api__getExecutionResponse(struct soap *soap, const char *tag, api__getExecutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__getExecutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__getExecutionResponse, sizeof(api__getExecutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__getExecutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__getExecutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__getExecutionResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__getExecutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__getExecutionResponse, 0, sizeof(api__getExecutionResponse), 0, soap_copy_api__getExecutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__getExecutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__getExecutionResponse);
	if (this->soap_out(soap, tag?tag:"api:getExecutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__getExecutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__getExecutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__getExecutionResponse * SOAP_FMAC4 soap_get_api__getExecutionResponse(struct soap *soap, api__getExecutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__getExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__getExecutionResponse * SOAP_FMAC2 soap_instantiate_api__getExecutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__getExecutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__getExecutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__getExecutionResponse);
		if (size)
			*size = sizeof(api__getExecutionResponse);
		((api__getExecutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__getExecutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__getExecutionResponse);
		for (int i = 0; i < n; i++)
			((api__getExecutionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__getExecutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__getExecutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__getExecutionResponse %p -> %p\n", q, p));
	*(api__getExecutionResponse*)p = *(api__getExecutionResponse*)q;
}

void api__getExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__getExecution::executionId);
	/* transient soap skipped */
}

void api__getExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__getExecution::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__getExecution::executionId);
	/* transient soap skipped */
}

int api__getExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__getExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__getExecution(struct soap *soap, const char *tag, int id, const api__getExecution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__getExecution), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->api__getExecution::executionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__getExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__getExecution(soap, tag, this, type);
}

SOAP_FMAC3 api__getExecution * SOAP_FMAC4 soap_in_api__getExecution(struct soap *soap, const char *tag, api__getExecution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__getExecution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__getExecution, sizeof(api__getExecution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__getExecution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__getExecution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->api__getExecution::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__getExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__getExecution, 0, sizeof(api__getExecution), 0, soap_copy_api__getExecution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__getExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__getExecution);
	if (this->soap_out(soap, tag?tag:"api:getExecution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__getExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__getExecution(soap, this, tag, type);
}

SOAP_FMAC3 api__getExecution * SOAP_FMAC4 soap_get_api__getExecution(struct soap *soap, api__getExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__getExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__getExecution * SOAP_FMAC2 soap_instantiate_api__getExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__getExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__getExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__getExecution);
		if (size)
			*size = sizeof(api__getExecution);
		((api__getExecution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__getExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__getExecution);
		for (int i = 0; i < n; i++)
			((api__getExecution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__getExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__getExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__getExecution %p -> %p\n", q, p));
	*(api__getExecution*)p = *(api__getExecution*)q;
}

void api__killExecutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__killExecutionResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__killExecutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__killExecutionResponse::return_);
	/* transient soap skipped */
}

int api__killExecutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__killExecutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__killExecutionResponse(struct soap *soap, const char *tag, int id, const api__killExecutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__killExecutionResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__killExecutionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__killExecutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__killExecutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__killExecutionResponse * SOAP_FMAC4 soap_in_api__killExecutionResponse(struct soap *soap, const char *tag, api__killExecutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__killExecutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__killExecutionResponse, sizeof(api__killExecutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__killExecutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__killExecutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__killExecutionResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__killExecutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__killExecutionResponse, 0, sizeof(api__killExecutionResponse), 0, soap_copy_api__killExecutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__killExecutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__killExecutionResponse);
	if (this->soap_out(soap, tag?tag:"api:killExecutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__killExecutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__killExecutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__killExecutionResponse * SOAP_FMAC4 soap_get_api__killExecutionResponse(struct soap *soap, api__killExecutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__killExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__killExecutionResponse * SOAP_FMAC2 soap_instantiate_api__killExecutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__killExecutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__killExecutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__killExecutionResponse);
		if (size)
			*size = sizeof(api__killExecutionResponse);
		((api__killExecutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__killExecutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__killExecutionResponse);
		for (int i = 0; i < n; i++)
			((api__killExecutionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__killExecutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__killExecutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__killExecutionResponse %p -> %p\n", q, p));
	*(api__killExecutionResponse*)p = *(api__killExecutionResponse*)q;
}

void api__getStdErrResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__getStdErrResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__getStdErrResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__getStdErrResponse::return_);
	/* transient soap skipped */
}

int api__getStdErrResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__getStdErrResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__getStdErrResponse(struct soap *soap, const char *tag, int id, const api__getStdErrResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__getStdErrResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__getStdErrResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__getStdErrResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__getStdErrResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__getStdErrResponse * SOAP_FMAC4 soap_in_api__getStdErrResponse(struct soap *soap, const char *tag, api__getStdErrResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__getStdErrResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__getStdErrResponse, sizeof(api__getStdErrResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__getStdErrResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__getStdErrResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__getStdErrResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__getStdErrResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__getStdErrResponse, 0, sizeof(api__getStdErrResponse), 0, soap_copy_api__getStdErrResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__getStdErrResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__getStdErrResponse);
	if (this->soap_out(soap, tag?tag:"api:getStdErrResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__getStdErrResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__getStdErrResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__getStdErrResponse * SOAP_FMAC4 soap_get_api__getStdErrResponse(struct soap *soap, api__getStdErrResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__getStdErrResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__getStdErrResponse * SOAP_FMAC2 soap_instantiate_api__getStdErrResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__getStdErrResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__getStdErrResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__getStdErrResponse);
		if (size)
			*size = sizeof(api__getStdErrResponse);
		((api__getStdErrResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__getStdErrResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__getStdErrResponse);
		for (int i = 0; i < n; i++)
			((api__getStdErrResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__getStdErrResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__getStdErrResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__getStdErrResponse %p -> %p\n", q, p));
	*(api__getStdErrResponse*)p = *(api__getStdErrResponse*)q;
}

void api__getStdErr::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__getStdErr::executionId);
	/* transient soap skipped */
}

void api__getStdErr::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__getStdErr::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__getStdErr::executionId);
	/* transient soap skipped */
}

int api__getStdErr::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__getStdErr(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__getStdErr(struct soap *soap, const char *tag, int id, const api__getStdErr *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__getStdErr), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->api__getStdErr::executionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__getStdErr::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__getStdErr(soap, tag, this, type);
}

SOAP_FMAC3 api__getStdErr * SOAP_FMAC4 soap_in_api__getStdErr(struct soap *soap, const char *tag, api__getStdErr *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__getStdErr *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__getStdErr, sizeof(api__getStdErr), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__getStdErr)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__getStdErr *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->api__getStdErr::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__getStdErr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__getStdErr, 0, sizeof(api__getStdErr), 0, soap_copy_api__getStdErr);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__getStdErr::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__getStdErr);
	if (this->soap_out(soap, tag?tag:"api:getStdErr", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__getStdErr::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__getStdErr(soap, this, tag, type);
}

SOAP_FMAC3 api__getStdErr * SOAP_FMAC4 soap_get_api__getStdErr(struct soap *soap, api__getStdErr *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__getStdErr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__getStdErr * SOAP_FMAC2 soap_instantiate_api__getStdErr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__getStdErr(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__getStdErr, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__getStdErr);
		if (size)
			*size = sizeof(api__getStdErr);
		((api__getStdErr*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__getStdErr[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__getStdErr);
		for (int i = 0; i < n; i++)
			((api__getStdErr*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__getStdErr*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__getStdErr(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__getStdErr %p -> %p\n", q, p));
	*(api__getStdErr*)p = *(api__getStdErr*)q;
}

void api__getStdOutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__getStdOutResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__getStdOutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__getStdOutResponse::return_);
	/* transient soap skipped */
}

int api__getStdOutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__getStdOutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__getStdOutResponse(struct soap *soap, const char *tag, int id, const api__getStdOutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__getStdOutResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__getStdOutResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__getStdOutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__getStdOutResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__getStdOutResponse * SOAP_FMAC4 soap_in_api__getStdOutResponse(struct soap *soap, const char *tag, api__getStdOutResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__getStdOutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__getStdOutResponse, sizeof(api__getStdOutResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__getStdOutResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__getStdOutResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__getStdOutResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__getStdOutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__getStdOutResponse, 0, sizeof(api__getStdOutResponse), 0, soap_copy_api__getStdOutResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__getStdOutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__getStdOutResponse);
	if (this->soap_out(soap, tag?tag:"api:getStdOutResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__getStdOutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__getStdOutResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__getStdOutResponse * SOAP_FMAC4 soap_get_api__getStdOutResponse(struct soap *soap, api__getStdOutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__getStdOutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__getStdOutResponse * SOAP_FMAC2 soap_instantiate_api__getStdOutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__getStdOutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__getStdOutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__getStdOutResponse);
		if (size)
			*size = sizeof(api__getStdOutResponse);
		((api__getStdOutResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__getStdOutResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__getStdOutResponse);
		for (int i = 0; i < n; i++)
			((api__getStdOutResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__getStdOutResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__getStdOutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__getStdOutResponse %p -> %p\n", q, p));
	*(api__getStdOutResponse*)p = *(api__getStdOutResponse*)q;
}

void api__getStdOut::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__getStdOut::executionId);
	/* transient soap skipped */
}

void api__getStdOut::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__getStdOut::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__getStdOut::executionId);
	/* transient soap skipped */
}

int api__getStdOut::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__getStdOut(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__getStdOut(struct soap *soap, const char *tag, int id, const api__getStdOut *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__getStdOut), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->api__getStdOut::executionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__getStdOut::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__getStdOut(soap, tag, this, type);
}

SOAP_FMAC3 api__getStdOut * SOAP_FMAC4 soap_in_api__getStdOut(struct soap *soap, const char *tag, api__getStdOut *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__getStdOut *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__getStdOut, sizeof(api__getStdOut), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__getStdOut)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__getStdOut *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->api__getStdOut::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__getStdOut *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__getStdOut, 0, sizeof(api__getStdOut), 0, soap_copy_api__getStdOut);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__getStdOut::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__getStdOut);
	if (this->soap_out(soap, tag?tag:"api:getStdOut", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__getStdOut::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__getStdOut(soap, this, tag, type);
}

SOAP_FMAC3 api__getStdOut * SOAP_FMAC4 soap_get_api__getStdOut(struct soap *soap, api__getStdOut *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__getStdOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__getStdOut * SOAP_FMAC2 soap_instantiate_api__getStdOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__getStdOut(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__getStdOut, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__getStdOut);
		if (size)
			*size = sizeof(api__getStdOut);
		((api__getStdOut*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__getStdOut[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__getStdOut);
		for (int i = 0; i < n; i++)
			((api__getStdOut*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__getStdOut*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__getStdOut(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__getStdOut %p -> %p\n", q, p));
	*(api__getStdOut*)p = *(api__getStdOut*)q;
}

void api__killExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__killExecution::executionId);
	/* transient soap skipped */
}

void api__killExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__killExecution::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__killExecution::executionId);
	/* transient soap skipped */
}

int api__killExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__killExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__killExecution(struct soap *soap, const char *tag, int id, const api__killExecution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__killExecution), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->api__killExecution::executionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__killExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__killExecution(soap, tag, this, type);
}

SOAP_FMAC3 api__killExecution * SOAP_FMAC4 soap_in_api__killExecution(struct soap *soap, const char *tag, api__killExecution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__killExecution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__killExecution, sizeof(api__killExecution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__killExecution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__killExecution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->api__killExecution::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__killExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__killExecution, 0, sizeof(api__killExecution), 0, soap_copy_api__killExecution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__killExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__killExecution);
	if (this->soap_out(soap, tag?tag:"api:killExecution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__killExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__killExecution(soap, this, tag, type);
}

SOAP_FMAC3 api__killExecution * SOAP_FMAC4 soap_get_api__killExecution(struct soap *soap, api__killExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__killExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__killExecution * SOAP_FMAC2 soap_instantiate_api__killExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__killExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__killExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__killExecution);
		if (size)
			*size = sizeof(api__killExecution);
		((api__killExecution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__killExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__killExecution);
		for (int i = 0; i < n; i++)
			((api__killExecution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__killExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__killExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__killExecution %p -> %p\n", q, p));
	*(api__killExecution*)p = *(api__killExecution*)q;
}

void api__getExecutionResultsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__getExecutionResultsResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__getExecutionResultsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__getExecutionResultsResponse::return_);
	/* transient soap skipped */
}

int api__getExecutionResultsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__getExecutionResultsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__getExecutionResultsResponse(struct soap *soap, const char *tag, int id, const api__getExecutionResultsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__getExecutionResultsResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__getExecutionResultsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__getExecutionResultsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__getExecutionResultsResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__getExecutionResultsResponse * SOAP_FMAC4 soap_in_api__getExecutionResultsResponse(struct soap *soap, const char *tag, api__getExecutionResultsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__getExecutionResultsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__getExecutionResultsResponse, sizeof(api__getExecutionResultsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__getExecutionResultsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__getExecutionResultsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__getExecutionResultsResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__getExecutionResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__getExecutionResultsResponse, 0, sizeof(api__getExecutionResultsResponse), 0, soap_copy_api__getExecutionResultsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__getExecutionResultsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__getExecutionResultsResponse);
	if (this->soap_out(soap, tag?tag:"api:getExecutionResultsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__getExecutionResultsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__getExecutionResultsResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__getExecutionResultsResponse * SOAP_FMAC4 soap_get_api__getExecutionResultsResponse(struct soap *soap, api__getExecutionResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__getExecutionResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__getExecutionResultsResponse * SOAP_FMAC2 soap_instantiate_api__getExecutionResultsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__getExecutionResultsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__getExecutionResultsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__getExecutionResultsResponse);
		if (size)
			*size = sizeof(api__getExecutionResultsResponse);
		((api__getExecutionResultsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__getExecutionResultsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__getExecutionResultsResponse);
		for (int i = 0; i < n; i++)
			((api__getExecutionResultsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__getExecutionResultsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__getExecutionResultsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__getExecutionResultsResponse %p -> %p\n", q, p));
	*(api__getExecutionResultsResponse*)p = *(api__getExecutionResultsResponse*)q;
}

void api__getExecutionResults::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__getExecutionResults::executionId);
	/* transient soap skipped */
}

void api__getExecutionResults::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__getExecutionResults::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__getExecutionResults::executionId);
	/* transient soap skipped */
}

int api__getExecutionResults::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__getExecutionResults(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__getExecutionResults(struct soap *soap, const char *tag, int id, const api__getExecutionResults *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__getExecutionResults), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->api__getExecutionResults::executionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__getExecutionResults::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__getExecutionResults(soap, tag, this, type);
}

SOAP_FMAC3 api__getExecutionResults * SOAP_FMAC4 soap_in_api__getExecutionResults(struct soap *soap, const char *tag, api__getExecutionResults *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__getExecutionResults *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__getExecutionResults, sizeof(api__getExecutionResults), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__getExecutionResults)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__getExecutionResults *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->api__getExecutionResults::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__getExecutionResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__getExecutionResults, 0, sizeof(api__getExecutionResults), 0, soap_copy_api__getExecutionResults);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__getExecutionResults::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__getExecutionResults);
	if (this->soap_out(soap, tag?tag:"api:getExecutionResults", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__getExecutionResults::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__getExecutionResults(soap, this, tag, type);
}

SOAP_FMAC3 api__getExecutionResults * SOAP_FMAC4 soap_get_api__getExecutionResults(struct soap *soap, api__getExecutionResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__getExecutionResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__getExecutionResults * SOAP_FMAC2 soap_instantiate_api__getExecutionResults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__getExecutionResults(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__getExecutionResults, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__getExecutionResults);
		if (size)
			*size = sizeof(api__getExecutionResults);
		((api__getExecutionResults*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__getExecutionResults[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__getExecutionResults);
		for (int i = 0; i < n; i++)
			((api__getExecutionResults*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__getExecutionResults*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__getExecutionResults(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__getExecutionResults %p -> %p\n", q, p));
	*(api__getExecutionResults*)p = *(api__getExecutionResults*)q;
}

void api__initExecutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__initExecutionResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__initExecutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__initExecutionResponse::return_);
	/* transient soap skipped */
}

int api__initExecutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__initExecutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__initExecutionResponse(struct soap *soap, const char *tag, int id, const api__initExecutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__initExecutionResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__initExecutionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__initExecutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__initExecutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__initExecutionResponse * SOAP_FMAC4 soap_in_api__initExecutionResponse(struct soap *soap, const char *tag, api__initExecutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__initExecutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__initExecutionResponse, sizeof(api__initExecutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__initExecutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__initExecutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__initExecutionResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__initExecutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__initExecutionResponse, 0, sizeof(api__initExecutionResponse), 0, soap_copy_api__initExecutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__initExecutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__initExecutionResponse);
	if (this->soap_out(soap, tag?tag:"api:initExecutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__initExecutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__initExecutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__initExecutionResponse * SOAP_FMAC4 soap_get_api__initExecutionResponse(struct soap *soap, api__initExecutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__initExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__initExecutionResponse * SOAP_FMAC2 soap_instantiate_api__initExecutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__initExecutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__initExecutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__initExecutionResponse);
		if (size)
			*size = sizeof(api__initExecutionResponse);
		((api__initExecutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__initExecutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__initExecutionResponse);
		for (int i = 0; i < n; i++)
			((api__initExecutionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__initExecutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__initExecutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__initExecutionResponse %p -> %p\n", q, p));
	*(api__initExecutionResponse*)p = *(api__initExecutionResponse*)q;
}

void api__initExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__initExecution::pipelineId);
	soap_default_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, &this->api__initExecution::inputValue);
	this->api__initExecution::timeout = NULL;
	this->api__initExecution::executionName = NULL;
	this->api__initExecution::studyId = NULL;
	this->api__initExecution::playExecution = NULL;
	/* transient soap skipped */
}

void api__initExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__initExecution::pipelineId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__initExecution::pipelineId);
	soap_serialize_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, &this->api__initExecution::inputValue);
	soap_serialize_PointerToint(soap, &this->api__initExecution::timeout);
	soap_serialize_PointerTostd__string(soap, &this->api__initExecution::executionName);
	soap_serialize_PointerTostd__string(soap, &this->api__initExecution::studyId);
	soap_serialize_PointerTobool(soap, &this->api__initExecution::playExecution);
	/* transient soap skipped */
}

int api__initExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__initExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__initExecution(struct soap *soap, const char *tag, int id, const api__initExecution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__initExecution), type))
		return soap->error;
	if (soap_out_std__string(soap, "pipelineId", -1, &(a->api__initExecution::pipelineId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, "inputValue", -1, &(a->api__initExecution::inputValue), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "timeout", -1, &(a->api__initExecution::timeout), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "executionName", -1, &(a->api__initExecution::executionName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "studyId", -1, &(a->api__initExecution::studyId), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "playExecution", -1, &(a->api__initExecution::playExecution), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__initExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__initExecution(soap, tag, this, type);
}

SOAP_FMAC3 api__initExecution * SOAP_FMAC4 soap_in_api__initExecution(struct soap *soap, const char *tag, api__initExecution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__initExecution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__initExecution, sizeof(api__initExecution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__initExecution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__initExecution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_pipelineId1 = 1;
	size_t soap_flag_timeout1 = 1;
	size_t soap_flag_executionName1 = 1;
	size_t soap_flag_studyId1 = 1;
	size_t soap_flag_playExecution1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pipelineId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pipelineId", &(a->api__initExecution::pipelineId), "xsd:string"))
				{	soap_flag_pipelineId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, "inputValue", &(a->api__initExecution::inputValue), "api:StringKeyParameterValuePair"))
					continue;
			if (soap_flag_timeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "timeout", &(a->api__initExecution::timeout), "xsd:int"))
				{	soap_flag_timeout1--;
					continue;
				}
			if (soap_flag_executionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "executionName", &(a->api__initExecution::executionName), "xsd:string"))
				{	soap_flag_executionName1--;
					continue;
				}
			if (soap_flag_studyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "studyId", &(a->api__initExecution::studyId), "xsd:string"))
				{	soap_flag_studyId1--;
					continue;
				}
			if (soap_flag_playExecution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "playExecution", &(a->api__initExecution::playExecution), "xsd:boolean"))
				{	soap_flag_playExecution1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__initExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__initExecution, 0, sizeof(api__initExecution), 0, soap_copy_api__initExecution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pipelineId1 > 0 || a->api__initExecution::inputValue.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__initExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__initExecution);
	if (this->soap_out(soap, tag?tag:"api:initExecution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__initExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__initExecution(soap, this, tag, type);
}

SOAP_FMAC3 api__initExecution * SOAP_FMAC4 soap_get_api__initExecution(struct soap *soap, api__initExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__initExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__initExecution * SOAP_FMAC2 soap_instantiate_api__initExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__initExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__initExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__initExecution);
		if (size)
			*size = sizeof(api__initExecution);
		((api__initExecution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__initExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__initExecution);
		for (int i = 0; i < n; i++)
			((api__initExecution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__initExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__initExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__initExecution %p -> %p\n", q, p));
	*(api__initExecution*)p = *(api__initExecution*)q;
}

void api__getGlobalPropertiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__getGlobalPropertiesResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__getGlobalPropertiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__getGlobalPropertiesResponse::return_);
	/* transient soap skipped */
}

int api__getGlobalPropertiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__getGlobalPropertiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__getGlobalPropertiesResponse(struct soap *soap, const char *tag, int id, const api__getGlobalPropertiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__getGlobalPropertiesResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__getGlobalPropertiesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__getGlobalPropertiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__getGlobalPropertiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__getGlobalPropertiesResponse * SOAP_FMAC4 soap_in_api__getGlobalPropertiesResponse(struct soap *soap, const char *tag, api__getGlobalPropertiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__getGlobalPropertiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__getGlobalPropertiesResponse, sizeof(api__getGlobalPropertiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__getGlobalPropertiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__getGlobalPropertiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__getGlobalPropertiesResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__getGlobalPropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__getGlobalPropertiesResponse, 0, sizeof(api__getGlobalPropertiesResponse), 0, soap_copy_api__getGlobalPropertiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__getGlobalPropertiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__getGlobalPropertiesResponse);
	if (this->soap_out(soap, tag?tag:"api:getGlobalPropertiesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__getGlobalPropertiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__getGlobalPropertiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__getGlobalPropertiesResponse * SOAP_FMAC4 soap_get_api__getGlobalPropertiesResponse(struct soap *soap, api__getGlobalPropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__getGlobalPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__getGlobalPropertiesResponse * SOAP_FMAC2 soap_instantiate_api__getGlobalPropertiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__getGlobalPropertiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__getGlobalPropertiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__getGlobalPropertiesResponse);
		if (size)
			*size = sizeof(api__getGlobalPropertiesResponse);
		((api__getGlobalPropertiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__getGlobalPropertiesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__getGlobalPropertiesResponse);
		for (int i = 0; i < n; i++)
			((api__getGlobalPropertiesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__getGlobalPropertiesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__getGlobalPropertiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__getGlobalPropertiesResponse %p -> %p\n", q, p));
	*(api__getGlobalPropertiesResponse*)p = *(api__getGlobalPropertiesResponse*)q;
}

void api__getGlobalProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void api__getGlobalProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int api__getGlobalProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__getGlobalProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__getGlobalProperties(struct soap *soap, const char *tag, int id, const api__getGlobalProperties *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__getGlobalProperties), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__getGlobalProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__getGlobalProperties(soap, tag, this, type);
}

SOAP_FMAC3 api__getGlobalProperties * SOAP_FMAC4 soap_in_api__getGlobalProperties(struct soap *soap, const char *tag, api__getGlobalProperties *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__getGlobalProperties *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__getGlobalProperties, sizeof(api__getGlobalProperties), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__getGlobalProperties)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__getGlobalProperties *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__getGlobalProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__getGlobalProperties, 0, sizeof(api__getGlobalProperties), 0, soap_copy_api__getGlobalProperties);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int api__getGlobalProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__getGlobalProperties);
	if (this->soap_out(soap, tag?tag:"api:getGlobalProperties", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__getGlobalProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__getGlobalProperties(soap, this, tag, type);
}

SOAP_FMAC3 api__getGlobalProperties * SOAP_FMAC4 soap_get_api__getGlobalProperties(struct soap *soap, api__getGlobalProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__getGlobalProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__getGlobalProperties * SOAP_FMAC2 soap_instantiate_api__getGlobalProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__getGlobalProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__getGlobalProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__getGlobalProperties);
		if (size)
			*size = sizeof(api__getGlobalProperties);
		((api__getGlobalProperties*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__getGlobalProperties[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__getGlobalProperties);
		for (int i = 0; i < n; i++)
			((api__getGlobalProperties*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__getGlobalProperties*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__getGlobalProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__getGlobalProperties %p -> %p\n", q, p));
	*(api__getGlobalProperties*)p = *(api__getGlobalProperties*)q;
}

void api__updateExecutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__updateExecutionResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__updateExecutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__updateExecutionResponse::return_);
	/* transient soap skipped */
}

int api__updateExecutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__updateExecutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__updateExecutionResponse(struct soap *soap, const char *tag, int id, const api__updateExecutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__updateExecutionResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__updateExecutionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__updateExecutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__updateExecutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__updateExecutionResponse * SOAP_FMAC4 soap_in_api__updateExecutionResponse(struct soap *soap, const char *tag, api__updateExecutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__updateExecutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__updateExecutionResponse, sizeof(api__updateExecutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__updateExecutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__updateExecutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__updateExecutionResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__updateExecutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__updateExecutionResponse, 0, sizeof(api__updateExecutionResponse), 0, soap_copy_api__updateExecutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__updateExecutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__updateExecutionResponse);
	if (this->soap_out(soap, tag?tag:"api:updateExecutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__updateExecutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__updateExecutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__updateExecutionResponse * SOAP_FMAC4 soap_get_api__updateExecutionResponse(struct soap *soap, api__updateExecutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__updateExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__updateExecutionResponse * SOAP_FMAC2 soap_instantiate_api__updateExecutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__updateExecutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__updateExecutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__updateExecutionResponse);
		if (size)
			*size = sizeof(api__updateExecutionResponse);
		((api__updateExecutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__updateExecutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__updateExecutionResponse);
		for (int i = 0; i < n; i++)
			((api__updateExecutionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__updateExecutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__updateExecutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__updateExecutionResponse %p -> %p\n", q, p));
	*(api__updateExecutionResponse*)p = *(api__updateExecutionResponse*)q;
}

void api__StringKeyValuePair::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__StringKeyValuePair::name);
	this->api__StringKeyValuePair::__union_StringKeyValuePair = 0;
	/* transient soap skipped */
}

void api__StringKeyValuePair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__StringKeyValuePair::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__StringKeyValuePair::name);
	soap_serialize__api__union_StringKeyValuePair(soap, this->api__StringKeyValuePair::__union_StringKeyValuePair, &this->api__StringKeyValuePair::union_StringKeyValuePair);
	/* transient soap skipped */
}

int api__StringKeyValuePair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__StringKeyValuePair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__StringKeyValuePair(struct soap *soap, const char *tag, int id, const api__StringKeyValuePair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__StringKeyValuePair), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->api__StringKeyValuePair::name), ""))
		return soap->error;
	if (soap_out__api__union_StringKeyValuePair(soap, a->api__StringKeyValuePair::__union_StringKeyValuePair, &a->api__StringKeyValuePair::union_StringKeyValuePair))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__StringKeyValuePair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__StringKeyValuePair(soap, tag, this, type);
}

SOAP_FMAC3 api__StringKeyValuePair * SOAP_FMAC4 soap_in_api__StringKeyValuePair(struct soap *soap, const char *tag, api__StringKeyValuePair *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__StringKeyValuePair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__StringKeyValuePair, sizeof(api__StringKeyValuePair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__StringKeyValuePair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__StringKeyValuePair *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_union_StringKeyValuePair1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->api__StringKeyValuePair::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_union_StringKeyValuePair1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__api__union_StringKeyValuePair(soap, &a->api__StringKeyValuePair::__union_StringKeyValuePair, &a->api__StringKeyValuePair::union_StringKeyValuePair))
				{	soap_flag_union_StringKeyValuePair1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__StringKeyValuePair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__StringKeyValuePair, 0, sizeof(api__StringKeyValuePair), 0, soap_copy_api__StringKeyValuePair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_union_StringKeyValuePair1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__StringKeyValuePair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__StringKeyValuePair);
	if (this->soap_out(soap, tag?tag:"api:StringKeyValuePair", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__StringKeyValuePair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__StringKeyValuePair(soap, this, tag, type);
}

SOAP_FMAC3 api__StringKeyValuePair * SOAP_FMAC4 soap_get_api__StringKeyValuePair(struct soap *soap, api__StringKeyValuePair *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__StringKeyValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__StringKeyValuePair * SOAP_FMAC2 soap_instantiate_api__StringKeyValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__StringKeyValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__StringKeyValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__StringKeyValuePair);
		if (size)
			*size = sizeof(api__StringKeyValuePair);
		((api__StringKeyValuePair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__StringKeyValuePair[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__StringKeyValuePair);
		for (int i = 0; i < n; i++)
			((api__StringKeyValuePair*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__StringKeyValuePair*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__StringKeyValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__StringKeyValuePair %p -> %p\n", q, p));
	*(api__StringKeyValuePair*)p = *(api__StringKeyValuePair*)q;
}

void api__updateExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__updateExecution::executionId);
	soap_default_std__vectorTemplateOfPointerToapi__StringKeyValuePair(soap, &this->api__updateExecution::keyValuePair);
	/* transient soap skipped */
}

void api__updateExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__updateExecution::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__updateExecution::executionId);
	soap_serialize_std__vectorTemplateOfPointerToapi__StringKeyValuePair(soap, &this->api__updateExecution::keyValuePair);
	/* transient soap skipped */
}

int api__updateExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__updateExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__updateExecution(struct soap *soap, const char *tag, int id, const api__updateExecution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__updateExecution), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->api__updateExecution::executionId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToapi__StringKeyValuePair(soap, "keyValuePair", -1, &(a->api__updateExecution::keyValuePair), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__updateExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__updateExecution(soap, tag, this, type);
}

SOAP_FMAC3 api__updateExecution * SOAP_FMAC4 soap_in_api__updateExecution(struct soap *soap, const char *tag, api__updateExecution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__updateExecution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__updateExecution, sizeof(api__updateExecution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__updateExecution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__updateExecution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->api__updateExecution::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToapi__StringKeyValuePair(soap, "keyValuePair", &(a->api__updateExecution::keyValuePair), "api:StringKeyValuePair"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__updateExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__updateExecution, 0, sizeof(api__updateExecution), 0, soap_copy_api__updateExecution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0 || a->api__updateExecution::keyValuePair.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__updateExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__updateExecution);
	if (this->soap_out(soap, tag?tag:"api:updateExecution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__updateExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__updateExecution(soap, this, tag, type);
}

SOAP_FMAC3 api__updateExecution * SOAP_FMAC4 soap_get_api__updateExecution(struct soap *soap, api__updateExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__updateExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__updateExecution * SOAP_FMAC2 soap_instantiate_api__updateExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__updateExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__updateExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__updateExecution);
		if (size)
			*size = sizeof(api__updateExecution);
		((api__updateExecution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__updateExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__updateExecution);
		for (int i = 0; i < n; i++)
			((api__updateExecution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__updateExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__updateExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__updateExecution %p -> %p\n", q, p));
	*(api__updateExecution*)p = *(api__updateExecution*)q;
}

void api__logoutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__logoutResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__logoutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__logoutResponse::return_);
	/* transient soap skipped */
}

int api__logoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__logoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__logoutResponse(struct soap *soap, const char *tag, int id, const api__logoutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__logoutResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__logoutResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__logoutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__logoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__logoutResponse * SOAP_FMAC4 soap_in_api__logoutResponse(struct soap *soap, const char *tag, api__logoutResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__logoutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__logoutResponse, sizeof(api__logoutResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__logoutResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__logoutResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__logoutResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__logoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__logoutResponse, 0, sizeof(api__logoutResponse), 0, soap_copy_api__logoutResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__logoutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__logoutResponse);
	if (this->soap_out(soap, tag?tag:"api:logoutResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__logoutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__logoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__logoutResponse * SOAP_FMAC4 soap_get_api__logoutResponse(struct soap *soap, api__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__logoutResponse * SOAP_FMAC2 soap_instantiate_api__logoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__logoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__logoutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__logoutResponse);
		if (size)
			*size = sizeof(api__logoutResponse);
		((api__logoutResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__logoutResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__logoutResponse);
		for (int i = 0; i < n; i++)
			((api__logoutResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__logoutResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__logoutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__logoutResponse %p -> %p\n", q, p));
	*(api__logoutResponse*)p = *(api__logoutResponse*)q;
}

void api__logout::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void api__logout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int api__logout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__logout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__logout(struct soap *soap, const char *tag, int id, const api__logout *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__logout), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__logout::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__logout(soap, tag, this, type);
}

SOAP_FMAC3 api__logout * SOAP_FMAC4 soap_in_api__logout(struct soap *soap, const char *tag, api__logout *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__logout *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__logout, sizeof(api__logout), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__logout)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__logout *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__logout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__logout, 0, sizeof(api__logout), 0, soap_copy_api__logout);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int api__logout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__logout);
	if (this->soap_out(soap, tag?tag:"api:logout", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__logout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__logout(soap, this, tag, type);
}

SOAP_FMAC3 api__logout * SOAP_FMAC4 soap_get_api__logout(struct soap *soap, api__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__logout * SOAP_FMAC2 soap_instantiate_api__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__logout);
		if (size)
			*size = sizeof(api__logout);
		((api__logout*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__logout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__logout);
		for (int i = 0; i < n; i++)
			((api__logout*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__logout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__logout %p -> %p\n", q, p));
	*(api__logout*)p = *(api__logout*)q;
}

void api__authenticateHTTPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__authenticateHTTPResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__authenticateHTTPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__authenticateHTTPResponse::return_);
	/* transient soap skipped */
}

int api__authenticateHTTPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__authenticateHTTPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__authenticateHTTPResponse(struct soap *soap, const char *tag, int id, const api__authenticateHTTPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__authenticateHTTPResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__authenticateHTTPResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__authenticateHTTPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__authenticateHTTPResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__authenticateHTTPResponse * SOAP_FMAC4 soap_in_api__authenticateHTTPResponse(struct soap *soap, const char *tag, api__authenticateHTTPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__authenticateHTTPResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__authenticateHTTPResponse, sizeof(api__authenticateHTTPResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__authenticateHTTPResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__authenticateHTTPResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__authenticateHTTPResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__authenticateHTTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__authenticateHTTPResponse, 0, sizeof(api__authenticateHTTPResponse), 0, soap_copy_api__authenticateHTTPResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__authenticateHTTPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__authenticateHTTPResponse);
	if (this->soap_out(soap, tag?tag:"api:authenticateHTTPResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__authenticateHTTPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__authenticateHTTPResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__authenticateHTTPResponse * SOAP_FMAC4 soap_get_api__authenticateHTTPResponse(struct soap *soap, api__authenticateHTTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__authenticateHTTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__authenticateHTTPResponse * SOAP_FMAC2 soap_instantiate_api__authenticateHTTPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__authenticateHTTPResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__authenticateHTTPResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__authenticateHTTPResponse);
		if (size)
			*size = sizeof(api__authenticateHTTPResponse);
		((api__authenticateHTTPResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__authenticateHTTPResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__authenticateHTTPResponse);
		for (int i = 0; i < n; i++)
			((api__authenticateHTTPResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__authenticateHTTPResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__authenticateHTTPResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__authenticateHTTPResponse %p -> %p\n", q, p));
	*(api__authenticateHTTPResponse*)p = *(api__authenticateHTTPResponse*)q;
}

void api__authenticateHTTP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__authenticateHTTP::userName);
	/* transient soap skipped */
}

void api__authenticateHTTP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__authenticateHTTP::userName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__authenticateHTTP::userName);
	/* transient soap skipped */
}

int api__authenticateHTTP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__authenticateHTTP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__authenticateHTTP(struct soap *soap, const char *tag, int id, const api__authenticateHTTP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__authenticateHTTP), type))
		return soap->error;
	if (soap_out_std__string(soap, "userName", -1, &(a->api__authenticateHTTP::userName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__authenticateHTTP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__authenticateHTTP(soap, tag, this, type);
}

SOAP_FMAC3 api__authenticateHTTP * SOAP_FMAC4 soap_in_api__authenticateHTTP(struct soap *soap, const char *tag, api__authenticateHTTP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__authenticateHTTP *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__authenticateHTTP, sizeof(api__authenticateHTTP), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__authenticateHTTP)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__authenticateHTTP *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userName", &(a->api__authenticateHTTP::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__authenticateHTTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__authenticateHTTP, 0, sizeof(api__authenticateHTTP), 0, soap_copy_api__authenticateHTTP);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__authenticateHTTP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__authenticateHTTP);
	if (this->soap_out(soap, tag?tag:"api:authenticateHTTP", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__authenticateHTTP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__authenticateHTTP(soap, this, tag, type);
}

SOAP_FMAC3 api__authenticateHTTP * SOAP_FMAC4 soap_get_api__authenticateHTTP(struct soap *soap, api__authenticateHTTP *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__authenticateHTTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__authenticateHTTP * SOAP_FMAC2 soap_instantiate_api__authenticateHTTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__authenticateHTTP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__authenticateHTTP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__authenticateHTTP);
		if (size)
			*size = sizeof(api__authenticateHTTP);
		((api__authenticateHTTP*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__authenticateHTTP[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__authenticateHTTP);
		for (int i = 0; i < n; i++)
			((api__authenticateHTTP*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__authenticateHTTP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__authenticateHTTP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__authenticateHTTP %p -> %p\n", q, p));
	*(api__authenticateHTTP*)p = *(api__authenticateHTTP*)q;
}

void api__getPipelineResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__getPipelineResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__getPipelineResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__getPipelineResponse::return_);
	/* transient soap skipped */
}

int api__getPipelineResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__getPipelineResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__getPipelineResponse(struct soap *soap, const char *tag, int id, const api__getPipelineResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__getPipelineResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__getPipelineResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__getPipelineResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__getPipelineResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__getPipelineResponse * SOAP_FMAC4 soap_in_api__getPipelineResponse(struct soap *soap, const char *tag, api__getPipelineResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__getPipelineResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__getPipelineResponse, sizeof(api__getPipelineResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__getPipelineResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__getPipelineResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__getPipelineResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__getPipelineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__getPipelineResponse, 0, sizeof(api__getPipelineResponse), 0, soap_copy_api__getPipelineResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__getPipelineResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__getPipelineResponse);
	if (this->soap_out(soap, tag?tag:"api:getPipelineResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__getPipelineResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__getPipelineResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__getPipelineResponse * SOAP_FMAC4 soap_get_api__getPipelineResponse(struct soap *soap, api__getPipelineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__getPipelineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__getPipelineResponse * SOAP_FMAC2 soap_instantiate_api__getPipelineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__getPipelineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__getPipelineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__getPipelineResponse);
		if (size)
			*size = sizeof(api__getPipelineResponse);
		((api__getPipelineResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__getPipelineResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__getPipelineResponse);
		for (int i = 0; i < n; i++)
			((api__getPipelineResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__getPipelineResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__getPipelineResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__getPipelineResponse %p -> %p\n", q, p));
	*(api__getPipelineResponse*)p = *(api__getPipelineResponse*)q;
}

void api__getPipeline::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__getPipeline::pipelineId);
	/* transient soap skipped */
}

void api__getPipeline::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__getPipeline::pipelineId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__getPipeline::pipelineId);
	/* transient soap skipped */
}

int api__getPipeline::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__getPipeline(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__getPipeline(struct soap *soap, const char *tag, int id, const api__getPipeline *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__getPipeline), type))
		return soap->error;
	if (soap_out_std__string(soap, "pipelineId", -1, &(a->api__getPipeline::pipelineId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__getPipeline::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__getPipeline(soap, tag, this, type);
}

SOAP_FMAC3 api__getPipeline * SOAP_FMAC4 soap_in_api__getPipeline(struct soap *soap, const char *tag, api__getPipeline *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__getPipeline *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__getPipeline, sizeof(api__getPipeline), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__getPipeline)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__getPipeline *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_pipelineId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pipelineId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pipelineId", &(a->api__getPipeline::pipelineId), "xsd:string"))
				{	soap_flag_pipelineId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__getPipeline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__getPipeline, 0, sizeof(api__getPipeline), 0, soap_copy_api__getPipeline);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pipelineId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__getPipeline::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__getPipeline);
	if (this->soap_out(soap, tag?tag:"api:getPipeline", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__getPipeline::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__getPipeline(soap, this, tag, type);
}

SOAP_FMAC3 api__getPipeline * SOAP_FMAC4 soap_get_api__getPipeline(struct soap *soap, api__getPipeline *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__getPipeline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__getPipeline * SOAP_FMAC2 soap_instantiate_api__getPipeline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__getPipeline(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__getPipeline, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__getPipeline);
		if (size)
			*size = sizeof(api__getPipeline);
		((api__getPipeline*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__getPipeline[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__getPipeline);
		for (int i = 0; i < n; i++)
			((api__getPipeline*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__getPipeline*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__getPipeline(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__getPipeline %p -> %p\n", q, p));
	*(api__getPipeline*)p = *(api__getPipeline*)q;
}

void api__deleteExecutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__deleteExecutionResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__deleteExecutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__deleteExecutionResponse::return_);
	/* transient soap skipped */
}

int api__deleteExecutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__deleteExecutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__deleteExecutionResponse(struct soap *soap, const char *tag, int id, const api__deleteExecutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__deleteExecutionResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__deleteExecutionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__deleteExecutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__deleteExecutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__deleteExecutionResponse * SOAP_FMAC4 soap_in_api__deleteExecutionResponse(struct soap *soap, const char *tag, api__deleteExecutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__deleteExecutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__deleteExecutionResponse, sizeof(api__deleteExecutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__deleteExecutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__deleteExecutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__deleteExecutionResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__deleteExecutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__deleteExecutionResponse, 0, sizeof(api__deleteExecutionResponse), 0, soap_copy_api__deleteExecutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__deleteExecutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__deleteExecutionResponse);
	if (this->soap_out(soap, tag?tag:"api:deleteExecutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__deleteExecutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__deleteExecutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__deleteExecutionResponse * SOAP_FMAC4 soap_get_api__deleteExecutionResponse(struct soap *soap, api__deleteExecutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__deleteExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__deleteExecutionResponse * SOAP_FMAC2 soap_instantiate_api__deleteExecutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__deleteExecutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__deleteExecutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__deleteExecutionResponse);
		if (size)
			*size = sizeof(api__deleteExecutionResponse);
		((api__deleteExecutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__deleteExecutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__deleteExecutionResponse);
		for (int i = 0; i < n; i++)
			((api__deleteExecutionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__deleteExecutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__deleteExecutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__deleteExecutionResponse %p -> %p\n", q, p));
	*(api__deleteExecutionResponse*)p = *(api__deleteExecutionResponse*)q;
}

void api__deleteExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__deleteExecution::executionId);
	soap_default_bool(soap, &this->api__deleteExecution::deleteFiles);
	/* transient soap skipped */
}

void api__deleteExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__deleteExecution::executionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__deleteExecution::executionId);
	soap_embedded(soap, &this->api__deleteExecution::deleteFiles, SOAP_TYPE_bool);
	/* transient soap skipped */
}

int api__deleteExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__deleteExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__deleteExecution(struct soap *soap, const char *tag, int id, const api__deleteExecution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__deleteExecution), type))
		return soap->error;
	if (soap_out_std__string(soap, "executionId", -1, &(a->api__deleteExecution::executionId), ""))
		return soap->error;
	if (soap_out_bool(soap, "deleteFiles", -1, &(a->api__deleteExecution::deleteFiles), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__deleteExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__deleteExecution(soap, tag, this, type);
}

SOAP_FMAC3 api__deleteExecution * SOAP_FMAC4 soap_in_api__deleteExecution(struct soap *soap, const char *tag, api__deleteExecution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__deleteExecution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__deleteExecution, sizeof(api__deleteExecution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__deleteExecution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__deleteExecution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_executionId1 = 1;
	size_t soap_flag_deleteFiles1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executionId", &(a->api__deleteExecution::executionId), "xsd:string"))
				{	soap_flag_executionId1--;
					continue;
				}
			if (soap_flag_deleteFiles1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "deleteFiles", &(a->api__deleteExecution::deleteFiles), "xsd:boolean"))
				{	soap_flag_deleteFiles1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__deleteExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__deleteExecution, 0, sizeof(api__deleteExecution), 0, soap_copy_api__deleteExecution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executionId1 > 0 || soap_flag_deleteFiles1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__deleteExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__deleteExecution);
	if (this->soap_out(soap, tag?tag:"api:deleteExecution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__deleteExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__deleteExecution(soap, this, tag, type);
}

SOAP_FMAC3 api__deleteExecution * SOAP_FMAC4 soap_get_api__deleteExecution(struct soap *soap, api__deleteExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__deleteExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__deleteExecution * SOAP_FMAC2 soap_instantiate_api__deleteExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__deleteExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__deleteExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__deleteExecution);
		if (size)
			*size = sizeof(api__deleteExecution);
		((api__deleteExecution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__deleteExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__deleteExecution);
		for (int i = 0; i < n; i++)
			((api__deleteExecution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__deleteExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__deleteExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__deleteExecution %p -> %p\n", q, p));
	*(api__deleteExecution*)p = *(api__deleteExecution*)q;
}

void api__PipelineKeyBooleanValuePair::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__PipelineKeyBooleanValuePair::name = NULL;
	soap_default_bool(soap, &this->api__PipelineKeyBooleanValuePair::value);
	/* transient soap skipped */
}

void api__PipelineKeyBooleanValuePair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Pipeline(soap, &this->api__PipelineKeyBooleanValuePair::name);
	soap_embedded(soap, &this->api__PipelineKeyBooleanValuePair::value, SOAP_TYPE_bool);
	/* transient soap skipped */
}

int api__PipelineKeyBooleanValuePair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__PipelineKeyBooleanValuePair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, int id, const api__PipelineKeyBooleanValuePair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__PipelineKeyBooleanValuePair), type))
		return soap->error;
	if (soap_out_PointerToapi__Pipeline(soap, "name", -1, &(a->api__PipelineKeyBooleanValuePair::name), ""))
		return soap->error;
	if (soap_out_bool(soap, "value", -1, &(a->api__PipelineKeyBooleanValuePair::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__PipelineKeyBooleanValuePair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__PipelineKeyBooleanValuePair(soap, tag, this, type);
}

SOAP_FMAC3 api__PipelineKeyBooleanValuePair * SOAP_FMAC4 soap_in_api__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, api__PipelineKeyBooleanValuePair *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__PipelineKeyBooleanValuePair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__PipelineKeyBooleanValuePair, sizeof(api__PipelineKeyBooleanValuePair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__PipelineKeyBooleanValuePair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__PipelineKeyBooleanValuePair *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Pipeline(soap, "name", &(a->api__PipelineKeyBooleanValuePair::name), "api:Pipeline"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "value", &(a->api__PipelineKeyBooleanValuePair::value), "xsd:boolean"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__PipelineKeyBooleanValuePair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__PipelineKeyBooleanValuePair, 0, sizeof(api__PipelineKeyBooleanValuePair), 0, soap_copy_api__PipelineKeyBooleanValuePair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__PipelineKeyBooleanValuePair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__PipelineKeyBooleanValuePair);
	if (this->soap_out(soap, tag?tag:"api:PipelineKeyBooleanValuePair", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__PipelineKeyBooleanValuePair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__PipelineKeyBooleanValuePair(soap, this, tag, type);
}

SOAP_FMAC3 api__PipelineKeyBooleanValuePair * SOAP_FMAC4 soap_get_api__PipelineKeyBooleanValuePair(struct soap *soap, api__PipelineKeyBooleanValuePair *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__PipelineKeyBooleanValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__PipelineKeyBooleanValuePair * SOAP_FMAC2 soap_instantiate_api__PipelineKeyBooleanValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__PipelineKeyBooleanValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__PipelineKeyBooleanValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__PipelineKeyBooleanValuePair);
		if (size)
			*size = sizeof(api__PipelineKeyBooleanValuePair);
		((api__PipelineKeyBooleanValuePair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__PipelineKeyBooleanValuePair[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__PipelineKeyBooleanValuePair);
		for (int i = 0; i < n; i++)
			((api__PipelineKeyBooleanValuePair*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__PipelineKeyBooleanValuePair*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__PipelineKeyBooleanValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__PipelineKeyBooleanValuePair %p -> %p\n", q, p));
	*(api__PipelineKeyBooleanValuePair*)p = *(api__PipelineKeyBooleanValuePair*)q;
}

void api__GlobalProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(soap, &this->api__GlobalProperties::APIErrorCodesAndMessages);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->api__GlobalProperties::supportedTransferProtocol);
	soap_default_std__vectorTemplateOfapi__Module(soap, &this->api__GlobalProperties::supportedModule);
	this->api__GlobalProperties::email = NULL;
	this->api__GlobalProperties::platformDescription = NULL;
	this->api__GlobalProperties::minAuthorizedExecutionTimeout = NULL;
	this->api__GlobalProperties::maxAuthorizedExecutionTimeout = NULL;
	this->api__GlobalProperties::defaultExecutionTimeout = NULL;
	soap_default_bool(soap, &this->api__GlobalProperties::isKillExecutionSupported);
	this->api__GlobalProperties::defaultStudy = NULL;
	soap_default_std__string(soap, &this->api__GlobalProperties::supportedAPIVersion);
	/* transient soap skipped */
}

void api__GlobalProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(soap, &this->api__GlobalProperties::APIErrorCodesAndMessages);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->api__GlobalProperties::supportedTransferProtocol);
	soap_serialize_std__vectorTemplateOfapi__Module(soap, &this->api__GlobalProperties::supportedModule);
	soap_serialize_PointerTostd__string(soap, &this->api__GlobalProperties::email);
	soap_serialize_PointerTostd__string(soap, &this->api__GlobalProperties::platformDescription);
	soap_serialize_PointerToint(soap, &this->api__GlobalProperties::minAuthorizedExecutionTimeout);
	soap_serialize_PointerToint(soap, &this->api__GlobalProperties::maxAuthorizedExecutionTimeout);
	soap_serialize_PointerToint(soap, &this->api__GlobalProperties::defaultExecutionTimeout);
	soap_embedded(soap, &this->api__GlobalProperties::isKillExecutionSupported, SOAP_TYPE_bool);
	soap_serialize_PointerTostd__string(soap, &this->api__GlobalProperties::defaultStudy);
	soap_embedded(soap, &this->api__GlobalProperties::supportedAPIVersion, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__GlobalProperties::supportedAPIVersion);
	/* transient soap skipped */
}

int api__GlobalProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__GlobalProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__GlobalProperties(struct soap *soap, const char *tag, int id, const api__GlobalProperties *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__GlobalProperties), "api:GlobalProperties"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(soap, "APIErrorCodesAndMessages", -1, &(a->api__GlobalProperties::APIErrorCodesAndMessages), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "supportedTransferProtocol", -1, &(a->api__GlobalProperties::supportedTransferProtocol), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfapi__Module(soap, "supportedModule", -1, &(a->api__GlobalProperties::supportedModule), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "email", -1, &(a->api__GlobalProperties::email), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "platformDescription", -1, &(a->api__GlobalProperties::platformDescription), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "minAuthorizedExecutionTimeout", -1, &(a->api__GlobalProperties::minAuthorizedExecutionTimeout), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "maxAuthorizedExecutionTimeout", -1, &(a->api__GlobalProperties::maxAuthorizedExecutionTimeout), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "defaultExecutionTimeout", -1, &(a->api__GlobalProperties::defaultExecutionTimeout), ""))
		return soap->error;
	if (soap_out_bool(soap, "isKillExecutionSupported", -1, &(a->api__GlobalProperties::isKillExecutionSupported), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "defaultStudy", -1, &(a->api__GlobalProperties::defaultStudy), ""))
		return soap->error;
	if (soap_out_std__string(soap, "supportedAPIVersion", -1, &(a->api__GlobalProperties::supportedAPIVersion), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *api__GlobalProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__GlobalProperties(soap, tag, this, type);
}

SOAP_FMAC3 api__GlobalProperties * SOAP_FMAC4 soap_in_api__GlobalProperties(struct soap *soap, const char *tag, api__GlobalProperties *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__GlobalProperties *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__GlobalProperties, sizeof(api__GlobalProperties), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__GlobalProperties)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__GlobalProperties *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_email1 = 1;
	size_t soap_flag_platformDescription1 = 1;
	size_t soap_flag_minAuthorizedExecutionTimeout1 = 1;
	size_t soap_flag_maxAuthorizedExecutionTimeout1 = 1;
	size_t soap_flag_defaultExecutionTimeout1 = 1;
	size_t soap_flag_isKillExecutionSupported1 = 1;
	size_t soap_flag_defaultStudy1 = 1;
	size_t soap_flag_supportedAPIVersion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(soap, "APIErrorCodesAndMessages", &(a->api__GlobalProperties::APIErrorCodesAndMessages), "api:IntKeyStringValuePair"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "supportedTransferProtocol", &(a->api__GlobalProperties::supportedTransferProtocol), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfapi__Module(soap, "supportedModule", &(a->api__GlobalProperties::supportedModule), "api:Module"))
					continue;
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "email", &(a->api__GlobalProperties::email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_platformDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "platformDescription", &(a->api__GlobalProperties::platformDescription), "xsd:string"))
				{	soap_flag_platformDescription1--;
					continue;
				}
			if (soap_flag_minAuthorizedExecutionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "minAuthorizedExecutionTimeout", &(a->api__GlobalProperties::minAuthorizedExecutionTimeout), "xsd:int"))
				{	soap_flag_minAuthorizedExecutionTimeout1--;
					continue;
				}
			if (soap_flag_maxAuthorizedExecutionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "maxAuthorizedExecutionTimeout", &(a->api__GlobalProperties::maxAuthorizedExecutionTimeout), "xsd:int"))
				{	soap_flag_maxAuthorizedExecutionTimeout1--;
					continue;
				}
			if (soap_flag_defaultExecutionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "defaultExecutionTimeout", &(a->api__GlobalProperties::defaultExecutionTimeout), "xsd:int"))
				{	soap_flag_defaultExecutionTimeout1--;
					continue;
				}
			if (soap_flag_isKillExecutionSupported1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isKillExecutionSupported", &(a->api__GlobalProperties::isKillExecutionSupported), "xsd:boolean"))
				{	soap_flag_isKillExecutionSupported1--;
					continue;
				}
			if (soap_flag_defaultStudy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "defaultStudy", &(a->api__GlobalProperties::defaultStudy), "xsd:string"))
				{	soap_flag_defaultStudy1--;
					continue;
				}
			if (soap_flag_supportedAPIVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "supportedAPIVersion", &(a->api__GlobalProperties::supportedAPIVersion), "xsd:string"))
				{	soap_flag_supportedAPIVersion1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__GlobalProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__GlobalProperties, 0, sizeof(api__GlobalProperties), 0, soap_copy_api__GlobalProperties);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->api__GlobalProperties::supportedTransferProtocol.size() < 1 || a->api__GlobalProperties::supportedModule.size() < 1 || soap_flag_isKillExecutionSupported1 > 0 || soap_flag_supportedAPIVersion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__GlobalProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__GlobalProperties);
	if (this->soap_out(soap, tag?tag:"api:GlobalProperties", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__GlobalProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__GlobalProperties(soap, this, tag, type);
}

SOAP_FMAC3 api__GlobalProperties * SOAP_FMAC4 soap_get_api__GlobalProperties(struct soap *soap, api__GlobalProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__GlobalProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__GlobalProperties * SOAP_FMAC2 soap_instantiate_api__GlobalProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__GlobalProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__GlobalProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__GlobalProperties);
		if (size)
			*size = sizeof(api__GlobalProperties);
		((api__GlobalProperties*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__GlobalProperties[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__GlobalProperties);
		for (int i = 0; i < n; i++)
			((api__GlobalProperties*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__GlobalProperties*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__GlobalProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__GlobalProperties %p -> %p\n", q, p));
	*(api__GlobalProperties*)p = *(api__GlobalProperties*)q;
}

void api__StringKeyParameterValuePair::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__StringKeyParameterValuePair::name);
	this->api__StringKeyParameterValuePair::value = NULL;
	/* transient soap skipped */
}

void api__StringKeyParameterValuePair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__StringKeyParameterValuePair::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__StringKeyParameterValuePair::name);
	soap_serialize_PointerToapi__ParameterTypedValue(soap, &this->api__StringKeyParameterValuePair::value);
	/* transient soap skipped */
}

int api__StringKeyParameterValuePair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__StringKeyParameterValuePair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__StringKeyParameterValuePair(struct soap *soap, const char *tag, int id, const api__StringKeyParameterValuePair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__StringKeyParameterValuePair), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->api__StringKeyParameterValuePair::name), ""))
		return soap->error;
	if (soap_out_PointerToapi__ParameterTypedValue(soap, "value", -1, &(a->api__StringKeyParameterValuePair::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__StringKeyParameterValuePair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__StringKeyParameterValuePair(soap, tag, this, type);
}

SOAP_FMAC3 api__StringKeyParameterValuePair * SOAP_FMAC4 soap_in_api__StringKeyParameterValuePair(struct soap *soap, const char *tag, api__StringKeyParameterValuePair *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__StringKeyParameterValuePair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__StringKeyParameterValuePair, sizeof(api__StringKeyParameterValuePair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__StringKeyParameterValuePair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__StringKeyParameterValuePair *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->api__StringKeyParameterValuePair::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__ParameterTypedValue(soap, "value", &(a->api__StringKeyParameterValuePair::value), "api:ParameterTypedValue"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__StringKeyParameterValuePair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__StringKeyParameterValuePair, 0, sizeof(api__StringKeyParameterValuePair), 0, soap_copy_api__StringKeyParameterValuePair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__StringKeyParameterValuePair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__StringKeyParameterValuePair);
	if (this->soap_out(soap, tag?tag:"api:StringKeyParameterValuePair", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__StringKeyParameterValuePair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__StringKeyParameterValuePair(soap, this, tag, type);
}

SOAP_FMAC3 api__StringKeyParameterValuePair * SOAP_FMAC4 soap_get_api__StringKeyParameterValuePair(struct soap *soap, api__StringKeyParameterValuePair *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__StringKeyParameterValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__StringKeyParameterValuePair * SOAP_FMAC2 soap_instantiate_api__StringKeyParameterValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__StringKeyParameterValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__StringKeyParameterValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__StringKeyParameterValuePair);
		if (size)
			*size = sizeof(api__StringKeyParameterValuePair);
		((api__StringKeyParameterValuePair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__StringKeyParameterValuePair[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__StringKeyParameterValuePair);
		for (int i = 0; i < n; i++)
			((api__StringKeyParameterValuePair*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__StringKeyParameterValuePair*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__StringKeyParameterValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__StringKeyParameterValuePair %p -> %p\n", q, p));
	*(api__StringKeyParameterValuePair*)p = *(api__StringKeyParameterValuePair*)q;
}

void api__Execution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__Execution::identifier);
	soap_default_std__string(soap, &this->api__Execution::name);
	soap_default_std__string(soap, &this->api__Execution::pipelineIdentifier);
	this->api__Execution::timeout = NULL;
	soap_default_api__ExecutionStatus(soap, &this->api__Execution::status);
	soap_default_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, &this->api__Execution::inputValue);
	soap_default_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, &this->api__Execution::returnedFile);
	this->api__Execution::studyIdentifier = NULL;
	this->api__Execution::errorCode = NULL;
	this->api__Execution::startDate = NULL;
	this->api__Execution::endDate = NULL;
	/* transient soap skipped */
}

void api__Execution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__Execution::identifier, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__Execution::identifier);
	soap_embedded(soap, &this->api__Execution::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__Execution::name);
	soap_embedded(soap, &this->api__Execution::pipelineIdentifier, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__Execution::pipelineIdentifier);
	soap_serialize_PointerToint(soap, &this->api__Execution::timeout);
	soap_embedded(soap, &this->api__Execution::status, SOAP_TYPE_api__ExecutionStatus);
	soap_serialize_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, &this->api__Execution::inputValue);
	soap_serialize_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, &this->api__Execution::returnedFile);
	soap_serialize_PointerTostd__string(soap, &this->api__Execution::studyIdentifier);
	soap_serialize_PointerToint(soap, &this->api__Execution::errorCode);
	soap_serialize_PointerToLONG64(soap, &this->api__Execution::startDate);
	soap_serialize_PointerToLONG64(soap, &this->api__Execution::endDate);
	/* transient soap skipped */
}

int api__Execution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__Execution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__Execution(struct soap *soap, const char *tag, int id, const api__Execution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__Execution), "api:Execution"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "identifier", -1, &(a->api__Execution::identifier), ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->api__Execution::name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "pipelineIdentifier", -1, &(a->api__Execution::pipelineIdentifier), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "timeout", -1, &(a->api__Execution::timeout), ""))
		return soap->error;
	if (soap_out_api__ExecutionStatus(soap, "status", -1, &(a->api__Execution::status), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, "inputValue", -1, &(a->api__Execution::inputValue), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, "returnedFile", -1, &(a->api__Execution::returnedFile), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "studyIdentifier", -1, &(a->api__Execution::studyIdentifier), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "errorCode", -1, &(a->api__Execution::errorCode), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "startDate", -1, &(a->api__Execution::startDate), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "endDate", -1, &(a->api__Execution::endDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *api__Execution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__Execution(soap, tag, this, type);
}

SOAP_FMAC3 api__Execution * SOAP_FMAC4 soap_in_api__Execution(struct soap *soap, const char *tag, api__Execution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__Execution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__Execution, sizeof(api__Execution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__Execution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__Execution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_identifier1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_pipelineIdentifier1 = 1;
	size_t soap_flag_timeout1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_studyIdentifier1 = 1;
	size_t soap_flag_errorCode1 = 1;
	size_t soap_flag_startDate1 = 1;
	size_t soap_flag_endDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "identifier", &(a->api__Execution::identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->api__Execution::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_pipelineIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pipelineIdentifier", &(a->api__Execution::pipelineIdentifier), "xsd:string"))
				{	soap_flag_pipelineIdentifier1--;
					continue;
				}
			if (soap_flag_timeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "timeout", &(a->api__Execution::timeout), "xsd:int"))
				{	soap_flag_timeout1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_api__ExecutionStatus(soap, "status", &(a->api__Execution::status), "api:ExecutionStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, "inputValue", &(a->api__Execution::inputValue), "api:StringKeyParameterValuePair"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, "returnedFile", &(a->api__Execution::returnedFile), "api:StringKeyParameterValuePair"))
					continue;
			if (soap_flag_studyIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "studyIdentifier", &(a->api__Execution::studyIdentifier), "xsd:string"))
				{	soap_flag_studyIdentifier1--;
					continue;
				}
			if (soap_flag_errorCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "errorCode", &(a->api__Execution::errorCode), "xsd:int"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "startDate", &(a->api__Execution::startDate), "xsd:long"))
				{	soap_flag_startDate1--;
					continue;
				}
			if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "endDate", &(a->api__Execution::endDate), "xsd:long"))
				{	soap_flag_endDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__Execution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__Execution, 0, sizeof(api__Execution), 0, soap_copy_api__Execution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_identifier1 > 0 || soap_flag_name1 > 0 || soap_flag_pipelineIdentifier1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__Execution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__Execution);
	if (this->soap_out(soap, tag?tag:"api:Execution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__Execution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__Execution(soap, this, tag, type);
}

SOAP_FMAC3 api__Execution * SOAP_FMAC4 soap_get_api__Execution(struct soap *soap, api__Execution *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__Execution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__Execution * SOAP_FMAC2 soap_instantiate_api__Execution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__Execution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__Execution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__Execution);
		if (size)
			*size = sizeof(api__Execution);
		((api__Execution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__Execution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__Execution);
		for (int i = 0; i < n; i++)
			((api__Execution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__Execution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__Execution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__Execution %p -> %p\n", q, p));
	*(api__Execution*)p = *(api__Execution*)q;
}

void api__IntKeyStringValuePair::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->api__IntKeyStringValuePair::name);
	soap_default_std__string(soap, &this->api__IntKeyStringValuePair::value);
	/* transient soap skipped */
}

void api__IntKeyStringValuePair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__IntKeyStringValuePair::name, SOAP_TYPE_int);
	soap_embedded(soap, &this->api__IntKeyStringValuePair::value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__IntKeyStringValuePair::value);
	/* transient soap skipped */
}

int api__IntKeyStringValuePair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__IntKeyStringValuePair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__IntKeyStringValuePair(struct soap *soap, const char *tag, int id, const api__IntKeyStringValuePair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__IntKeyStringValuePair), type))
		return soap->error;
	if (soap_out_int(soap, "name", -1, &(a->api__IntKeyStringValuePair::name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "value", -1, &(a->api__IntKeyStringValuePair::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__IntKeyStringValuePair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__IntKeyStringValuePair(soap, tag, this, type);
}

SOAP_FMAC3 api__IntKeyStringValuePair * SOAP_FMAC4 soap_in_api__IntKeyStringValuePair(struct soap *soap, const char *tag, api__IntKeyStringValuePair *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__IntKeyStringValuePair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__IntKeyStringValuePair, sizeof(api__IntKeyStringValuePair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__IntKeyStringValuePair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__IntKeyStringValuePair *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "name", &(a->api__IntKeyStringValuePair::name), "xsd:int"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "value", &(a->api__IntKeyStringValuePair::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__IntKeyStringValuePair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__IntKeyStringValuePair, 0, sizeof(api__IntKeyStringValuePair), 0, soap_copy_api__IntKeyStringValuePair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__IntKeyStringValuePair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__IntKeyStringValuePair);
	if (this->soap_out(soap, tag?tag:"api:IntKeyStringValuePair", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__IntKeyStringValuePair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__IntKeyStringValuePair(soap, this, tag, type);
}

SOAP_FMAC3 api__IntKeyStringValuePair * SOAP_FMAC4 soap_get_api__IntKeyStringValuePair(struct soap *soap, api__IntKeyStringValuePair *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__IntKeyStringValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__IntKeyStringValuePair * SOAP_FMAC2 soap_instantiate_api__IntKeyStringValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__IntKeyStringValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__IntKeyStringValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__IntKeyStringValuePair);
		if (size)
			*size = sizeof(api__IntKeyStringValuePair);
		((api__IntKeyStringValuePair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__IntKeyStringValuePair[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__IntKeyStringValuePair);
		for (int i = 0; i < n; i++)
			((api__IntKeyStringValuePair*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__IntKeyStringValuePair*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__IntKeyStringValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__IntKeyStringValuePair %p -> %p\n", q, p));
	*(api__IntKeyStringValuePair*)p = *(api__IntKeyStringValuePair*)q;
}

void api__ParameterTypedValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_api__ParameterType(soap, &this->api__ParameterTypedValue::type);
	this->api__ParameterTypedValue::__union_ParameterTypedValue = 0;
	/* transient soap skipped */
}

void api__ParameterTypedValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__api__union_ParameterTypedValue(soap, this->api__ParameterTypedValue::__union_ParameterTypedValue, &this->api__ParameterTypedValue::union_ParameterTypedValue);
	/* transient soap skipped */
}

int api__ParameterTypedValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__ParameterTypedValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__ParameterTypedValue(struct soap *soap, const char *tag, int id, const api__ParameterTypedValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__ParameterTypedValue), type))
		return soap->error;
	if (soap_out_api__ParameterType(soap, "type", -1, &(a->api__ParameterTypedValue::type), ""))
		return soap->error;
	if (soap_out__api__union_ParameterTypedValue(soap, a->api__ParameterTypedValue::__union_ParameterTypedValue, &a->api__ParameterTypedValue::union_ParameterTypedValue))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__ParameterTypedValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__ParameterTypedValue(soap, tag, this, type);
}

SOAP_FMAC3 api__ParameterTypedValue * SOAP_FMAC4 soap_in_api__ParameterTypedValue(struct soap *soap, const char *tag, api__ParameterTypedValue *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__ParameterTypedValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__ParameterTypedValue, sizeof(api__ParameterTypedValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__ParameterTypedValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__ParameterTypedValue *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	size_t soap_flag_union_ParameterTypedValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_api__ParameterType(soap, "type", &(a->api__ParameterTypedValue::type), "api:ParameterType"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_union_ParameterTypedValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__api__union_ParameterTypedValue(soap, &a->api__ParameterTypedValue::__union_ParameterTypedValue, &a->api__ParameterTypedValue::union_ParameterTypedValue))
				{	soap_flag_union_ParameterTypedValue1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__ParameterTypedValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__ParameterTypedValue, 0, sizeof(api__ParameterTypedValue), 0, soap_copy_api__ParameterTypedValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0 || soap_flag_union_ParameterTypedValue1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__ParameterTypedValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__ParameterTypedValue);
	if (this->soap_out(soap, tag?tag:"api:ParameterTypedValue", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__ParameterTypedValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__ParameterTypedValue(soap, this, tag, type);
}

SOAP_FMAC3 api__ParameterTypedValue * SOAP_FMAC4 soap_get_api__ParameterTypedValue(struct soap *soap, api__ParameterTypedValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__ParameterTypedValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__ParameterTypedValue * SOAP_FMAC2 soap_instantiate_api__ParameterTypedValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__ParameterTypedValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__ParameterTypedValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__ParameterTypedValue);
		if (size)
			*size = sizeof(api__ParameterTypedValue);
		((api__ParameterTypedValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__ParameterTypedValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__ParameterTypedValue);
		for (int i = 0; i < n; i++)
			((api__ParameterTypedValue*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__ParameterTypedValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__ParameterTypedValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__ParameterTypedValue %p -> %p\n", q, p));
	*(api__ParameterTypedValue*)p = *(api__ParameterTypedValue*)q;
}

void api__PipelineParameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__PipelineParameter::name);
	soap_default_api__ParameterType(soap, &this->api__PipelineParameter::type);
	soap_default_bool(soap, &this->api__PipelineParameter::isOptional);
	soap_default_bool(soap, &this->api__PipelineParameter::isReturnedValue);
	this->api__PipelineParameter::defaultValue = NULL;
	this->api__PipelineParameter::description = NULL;
	/* transient soap skipped */
}

void api__PipelineParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__PipelineParameter::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__PipelineParameter::name);
	soap_embedded(soap, &this->api__PipelineParameter::isOptional, SOAP_TYPE_bool);
	soap_embedded(soap, &this->api__PipelineParameter::isReturnedValue, SOAP_TYPE_bool);
	soap_serialize_PointerToapi__ParameterTypedValue(soap, &this->api__PipelineParameter::defaultValue);
	soap_serialize_PointerTostd__string(soap, &this->api__PipelineParameter::description);
	/* transient soap skipped */
}

int api__PipelineParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__PipelineParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__PipelineParameter(struct soap *soap, const char *tag, int id, const api__PipelineParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__PipelineParameter), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->api__PipelineParameter::name), ""))
		return soap->error;
	if (soap_out_api__ParameterType(soap, "type", -1, &(a->api__PipelineParameter::type), ""))
		return soap->error;
	if (soap_out_bool(soap, "isOptional", -1, &(a->api__PipelineParameter::isOptional), ""))
		return soap->error;
	if (soap_out_bool(soap, "isReturnedValue", -1, &(a->api__PipelineParameter::isReturnedValue), ""))
		return soap->error;
	if (soap_out_PointerToapi__ParameterTypedValue(soap, "defaultValue", -1, &(a->api__PipelineParameter::defaultValue), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->api__PipelineParameter::description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__PipelineParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__PipelineParameter(soap, tag, this, type);
}

SOAP_FMAC3 api__PipelineParameter * SOAP_FMAC4 soap_in_api__PipelineParameter(struct soap *soap, const char *tag, api__PipelineParameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__PipelineParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__PipelineParameter, sizeof(api__PipelineParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__PipelineParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__PipelineParameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_isOptional1 = 1;
	size_t soap_flag_isReturnedValue1 = 1;
	size_t soap_flag_defaultValue1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->api__PipelineParameter::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_api__ParameterType(soap, "type", &(a->api__PipelineParameter::type), "api:ParameterType"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_isOptional1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isOptional", &(a->api__PipelineParameter::isOptional), "xsd:boolean"))
				{	soap_flag_isOptional1--;
					continue;
				}
			if (soap_flag_isReturnedValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isReturnedValue", &(a->api__PipelineParameter::isReturnedValue), "xsd:boolean"))
				{	soap_flag_isReturnedValue1--;
					continue;
				}
			if (soap_flag_defaultValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__ParameterTypedValue(soap, "defaultValue", &(a->api__PipelineParameter::defaultValue), "api:ParameterTypedValue"))
				{	soap_flag_defaultValue1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->api__PipelineParameter::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__PipelineParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__PipelineParameter, 0, sizeof(api__PipelineParameter), 0, soap_copy_api__PipelineParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_type1 > 0 || soap_flag_isOptional1 > 0 || soap_flag_isReturnedValue1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__PipelineParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__PipelineParameter);
	if (this->soap_out(soap, tag?tag:"api:PipelineParameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__PipelineParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__PipelineParameter(soap, this, tag, type);
}

SOAP_FMAC3 api__PipelineParameter * SOAP_FMAC4 soap_get_api__PipelineParameter(struct soap *soap, api__PipelineParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__PipelineParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__PipelineParameter * SOAP_FMAC2 soap_instantiate_api__PipelineParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__PipelineParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__PipelineParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__PipelineParameter);
		if (size)
			*size = sizeof(api__PipelineParameter);
		((api__PipelineParameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__PipelineParameter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__PipelineParameter);
		for (int i = 0; i < n; i++)
			((api__PipelineParameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__PipelineParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__PipelineParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__PipelineParameter %p -> %p\n", q, p));
	*(api__PipelineParameter*)p = *(api__PipelineParameter*)q;
}

void api__ArrayOfExecutions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToapi__Execution(soap, &this->api__ArrayOfExecutions::item);
	/* transient soap skipped */
}

void api__ArrayOfExecutions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToapi__Execution(soap, &this->api__ArrayOfExecutions::item);
	/* transient soap skipped */
}

int api__ArrayOfExecutions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__ArrayOfExecutions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__ArrayOfExecutions(struct soap *soap, const char *tag, int id, const api__ArrayOfExecutions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__ArrayOfExecutions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToapi__Execution(soap, "item", -1, &(a->api__ArrayOfExecutions::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__ArrayOfExecutions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__ArrayOfExecutions(soap, tag, this, type);
}

SOAP_FMAC3 api__ArrayOfExecutions * SOAP_FMAC4 soap_in_api__ArrayOfExecutions(struct soap *soap, const char *tag, api__ArrayOfExecutions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__ArrayOfExecutions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__ArrayOfExecutions, sizeof(api__ArrayOfExecutions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__ArrayOfExecutions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__ArrayOfExecutions *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToapi__Execution(soap, "item", &(a->api__ArrayOfExecutions::item), "api:Execution"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__ArrayOfExecutions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__ArrayOfExecutions, 0, sizeof(api__ArrayOfExecutions), 0, soap_copy_api__ArrayOfExecutions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int api__ArrayOfExecutions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__ArrayOfExecutions);
	if (this->soap_out(soap, tag?tag:"api:ArrayOfExecutions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__ArrayOfExecutions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__ArrayOfExecutions(soap, this, tag, type);
}

SOAP_FMAC3 api__ArrayOfExecutions * SOAP_FMAC4 soap_get_api__ArrayOfExecutions(struct soap *soap, api__ArrayOfExecutions *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__ArrayOfExecutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__ArrayOfExecutions * SOAP_FMAC2 soap_instantiate_api__ArrayOfExecutions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__ArrayOfExecutions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__ArrayOfExecutions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__ArrayOfExecutions);
		if (size)
			*size = sizeof(api__ArrayOfExecutions);
		((api__ArrayOfExecutions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__ArrayOfExecutions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__ArrayOfExecutions);
		for (int i = 0; i < n; i++)
			((api__ArrayOfExecutions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__ArrayOfExecutions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__ArrayOfExecutions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__ArrayOfExecutions %p -> %p\n", q, p));
	*(api__ArrayOfExecutions*)p = *(api__ArrayOfExecutions*)q;
}

void api__ArrayOfPipelines::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToapi__Pipeline(soap, &this->api__ArrayOfPipelines::item);
	/* transient soap skipped */
}

void api__ArrayOfPipelines::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToapi__Pipeline(soap, &this->api__ArrayOfPipelines::item);
	/* transient soap skipped */
}

int api__ArrayOfPipelines::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__ArrayOfPipelines(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__ArrayOfPipelines(struct soap *soap, const char *tag, int id, const api__ArrayOfPipelines *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__ArrayOfPipelines), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToapi__Pipeline(soap, "item", -1, &(a->api__ArrayOfPipelines::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__ArrayOfPipelines::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__ArrayOfPipelines(soap, tag, this, type);
}

SOAP_FMAC3 api__ArrayOfPipelines * SOAP_FMAC4 soap_in_api__ArrayOfPipelines(struct soap *soap, const char *tag, api__ArrayOfPipelines *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__ArrayOfPipelines *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__ArrayOfPipelines, sizeof(api__ArrayOfPipelines), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__ArrayOfPipelines)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__ArrayOfPipelines *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToapi__Pipeline(soap, "item", &(a->api__ArrayOfPipelines::item), "api:Pipeline"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__ArrayOfPipelines *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__ArrayOfPipelines, 0, sizeof(api__ArrayOfPipelines), 0, soap_copy_api__ArrayOfPipelines);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int api__ArrayOfPipelines::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__ArrayOfPipelines);
	if (this->soap_out(soap, tag?tag:"api:ArrayOfPipelines", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__ArrayOfPipelines::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__ArrayOfPipelines(soap, this, tag, type);
}

SOAP_FMAC3 api__ArrayOfPipelines * SOAP_FMAC4 soap_get_api__ArrayOfPipelines(struct soap *soap, api__ArrayOfPipelines *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__ArrayOfPipelines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__ArrayOfPipelines * SOAP_FMAC2 soap_instantiate_api__ArrayOfPipelines(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__ArrayOfPipelines(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__ArrayOfPipelines, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__ArrayOfPipelines);
		if (size)
			*size = sizeof(api__ArrayOfPipelines);
		((api__ArrayOfPipelines*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__ArrayOfPipelines[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__ArrayOfPipelines);
		for (int i = 0; i < n; i++)
			((api__ArrayOfPipelines*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__ArrayOfPipelines*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__ArrayOfPipelines(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__ArrayOfPipelines %p -> %p\n", q, p));
	*(api__ArrayOfPipelines*)p = *(api__ArrayOfPipelines*)q;
}

void api__ArrayOfStrings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->api__ArrayOfStrings::item);
	/* transient soap skipped */
}

void api__ArrayOfStrings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->api__ArrayOfStrings::item);
	/* transient soap skipped */
}

int api__ArrayOfStrings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__ArrayOfStrings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__ArrayOfStrings(struct soap *soap, const char *tag, int id, const api__ArrayOfStrings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__ArrayOfStrings), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "item", -1, &(a->api__ArrayOfStrings::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__ArrayOfStrings::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__ArrayOfStrings(soap, tag, this, type);
}

SOAP_FMAC3 api__ArrayOfStrings * SOAP_FMAC4 soap_in_api__ArrayOfStrings(struct soap *soap, const char *tag, api__ArrayOfStrings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__ArrayOfStrings *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__ArrayOfStrings, sizeof(api__ArrayOfStrings), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__ArrayOfStrings)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__ArrayOfStrings *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "item", &(a->api__ArrayOfStrings::item), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__ArrayOfStrings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__ArrayOfStrings, 0, sizeof(api__ArrayOfStrings), 0, soap_copy_api__ArrayOfStrings);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int api__ArrayOfStrings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__ArrayOfStrings);
	if (this->soap_out(soap, tag?tag:"api:ArrayOfStrings", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__ArrayOfStrings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__ArrayOfStrings(soap, this, tag, type);
}

SOAP_FMAC3 api__ArrayOfStrings * SOAP_FMAC4 soap_get_api__ArrayOfStrings(struct soap *soap, api__ArrayOfStrings *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__ArrayOfStrings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__ArrayOfStrings * SOAP_FMAC2 soap_instantiate_api__ArrayOfStrings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__ArrayOfStrings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__ArrayOfStrings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__ArrayOfStrings);
		if (size)
			*size = sizeof(api__ArrayOfStrings);
		((api__ArrayOfStrings*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__ArrayOfStrings[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__ArrayOfStrings);
		for (int i = 0; i < n; i++)
			((api__ArrayOfStrings*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__ArrayOfStrings*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__ArrayOfStrings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__ArrayOfStrings %p -> %p\n", q, p));
	*(api__ArrayOfStrings*)p = *(api__ArrayOfStrings*)q;
}

void api__Object::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void api__Object::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int api__Object::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__Object(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__Object(struct soap *soap, const char *tag, int id, const api__Object *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__Object), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__Object::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__Object(soap, tag, this, type);
}

SOAP_FMAC3 api__Object * SOAP_FMAC4 soap_in_api__Object(struct soap *soap, const char *tag, api__Object *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__Object *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__Object, sizeof(api__Object), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__Object)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__Object *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__Object *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__Object, 0, sizeof(api__Object), 0, soap_copy_api__Object);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int api__Object::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__Object);
	if (this->soap_out(soap, tag?tag:"api:Object", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__Object::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__Object(soap, this, tag, type);
}

SOAP_FMAC3 api__Object * SOAP_FMAC4 soap_get_api__Object(struct soap *soap, api__Object *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__Object * SOAP_FMAC2 soap_instantiate_api__Object(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__Object(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__Object, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "api:Pipeline"))
	{	cp->type = SOAP_TYPE_api__Pipeline;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(api__Pipeline);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(api__Pipeline);
			((api__Pipeline*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(api__Pipeline[n]);
			if (size)
				*size = n * sizeof(api__Pipeline);
			for (int i = 0; i < n; i++)
				((api__Pipeline*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (api__Pipeline*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "api:Execution"))
	{	cp->type = SOAP_TYPE_api__Execution;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(api__Execution);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(api__Execution);
			((api__Execution*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(api__Execution[n]);
			if (size)
				*size = n * sizeof(api__Execution);
			for (int i = 0; i < n; i++)
				((api__Execution*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (api__Execution*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "api:GlobalProperties"))
	{	cp->type = SOAP_TYPE_api__GlobalProperties;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(api__GlobalProperties);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(api__GlobalProperties);
			((api__GlobalProperties*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(api__GlobalProperties[n]);
			if (size)
				*size = n * sizeof(api__GlobalProperties);
			for (int i = 0; i < n; i++)
				((api__GlobalProperties*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (api__GlobalProperties*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__Object);
		if (size)
			*size = sizeof(api__Object);
		((api__Object*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__Object[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__Object);
		for (int i = 0; i < n; i++)
			((api__Object*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__Object*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__Object(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__Object %p -> %p\n", q, p));
	*(api__Object*)p = *(api__Object*)q;
}

void api__Pipeline::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__Pipeline::identifier);
	soap_default_std__string(soap, &this->api__Pipeline::name);
	this->api__Pipeline::description = NULL;
	soap_default_std__string(soap, &this->api__Pipeline::version);
	soap_default_std__vectorTemplateOfPointerToapi__PipelineParameter(soap, &this->api__Pipeline::parameters);
	soap_default_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(soap, &this->api__Pipeline::errorCodesAndMessages);
	this->api__Pipeline::canExecute = NULL;
	/* transient soap skipped */
}

void api__Pipeline::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__Pipeline::identifier, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__Pipeline::identifier);
	soap_embedded(soap, &this->api__Pipeline::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__Pipeline::name);
	soap_serialize_PointerTostd__string(soap, &this->api__Pipeline::description);
	soap_embedded(soap, &this->api__Pipeline::version, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__Pipeline::version);
	soap_serialize_std__vectorTemplateOfPointerToapi__PipelineParameter(soap, &this->api__Pipeline::parameters);
	soap_serialize_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(soap, &this->api__Pipeline::errorCodesAndMessages);
	soap_serialize_PointerTobool(soap, &this->api__Pipeline::canExecute);
	/* transient soap skipped */
}

int api__Pipeline::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__Pipeline(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__Pipeline(struct soap *soap, const char *tag, int id, const api__Pipeline *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__Pipeline), "api:Pipeline"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "identifier", -1, &(a->api__Pipeline::identifier), ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->api__Pipeline::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->api__Pipeline::description), ""))
		return soap->error;
	if (soap_out_std__string(soap, "version", -1, &(a->api__Pipeline::version), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToapi__PipelineParameter(soap, "parameters", -1, &(a->api__Pipeline::parameters), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(soap, "errorCodesAndMessages", -1, &(a->api__Pipeline::errorCodesAndMessages), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "canExecute", -1, &(a->api__Pipeline::canExecute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *api__Pipeline::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__Pipeline(soap, tag, this, type);
}

SOAP_FMAC3 api__Pipeline * SOAP_FMAC4 soap_in_api__Pipeline(struct soap *soap, const char *tag, api__Pipeline *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__Pipeline *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__Pipeline, sizeof(api__Pipeline), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__Pipeline)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__Pipeline *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_identifier1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_canExecute1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "identifier", &(a->api__Pipeline::identifier), "xsd:string"))
				{	soap_flag_identifier1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->api__Pipeline::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->api__Pipeline::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "version", &(a->api__Pipeline::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToapi__PipelineParameter(soap, "parameters", &(a->api__Pipeline::parameters), "api:PipelineParameter"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(soap, "errorCodesAndMessages", &(a->api__Pipeline::errorCodesAndMessages), "api:IntKeyStringValuePair"))
					continue;
			if (soap_flag_canExecute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "canExecute", &(a->api__Pipeline::canExecute), "xsd:boolean"))
				{	soap_flag_canExecute1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__Pipeline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__Pipeline, 0, sizeof(api__Pipeline), 0, soap_copy_api__Pipeline);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_identifier1 > 0 || soap_flag_name1 > 0 || soap_flag_version1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__Pipeline::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__Pipeline);
	if (this->soap_out(soap, tag?tag:"api:Pipeline", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__Pipeline::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__Pipeline(soap, this, tag, type);
}

SOAP_FMAC3 api__Pipeline * SOAP_FMAC4 soap_get_api__Pipeline(struct soap *soap, api__Pipeline *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__Pipeline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__Pipeline * SOAP_FMAC2 soap_instantiate_api__Pipeline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__Pipeline(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__Pipeline, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__Pipeline);
		if (size)
			*size = sizeof(api__Pipeline);
		((api__Pipeline*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__Pipeline[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__Pipeline);
		for (int i = 0; i < n; i++)
			((api__Pipeline*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__Pipeline*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__Pipeline(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__Pipeline %p -> %p\n", q, p));
	*(api__Pipeline*)p = *(api__Pipeline*)q;
}

void api__Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->api__Response::statusCode);
	this->api__Response::errorMessage = NULL;
	this->api__Response::__union_Response = 0;
	/* transient soap skipped */
}

void api__Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__Response::statusCode, SOAP_TYPE_int);
	soap_serialize_PointerTostd__string(soap, &this->api__Response::errorMessage);
	soap_serialize__api__union_Response(soap, this->api__Response::__union_Response, &this->api__Response::union_Response);
	/* transient soap skipped */
}

int api__Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__Response(struct soap *soap, const char *tag, int id, const api__Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__Response), type))
		return soap->error;
	if (soap_out_int(soap, "statusCode", -1, &(a->api__Response::statusCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "errorMessage", -1, &(a->api__Response::errorMessage), ""))
		return soap->error;
	if (soap_out__api__union_Response(soap, a->api__Response::__union_Response, &a->api__Response::union_Response))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__Response(soap, tag, this, type);
}

SOAP_FMAC3 api__Response * SOAP_FMAC4 soap_in_api__Response(struct soap *soap, const char *tag, api__Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__Response, sizeof(api__Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_statusCode1 = 1;
	size_t soap_flag_errorMessage1 = 1;
	size_t soap_flag_union_Response1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "statusCode", &(a->api__Response::statusCode), "xsd:int"))
				{	soap_flag_statusCode1--;
					continue;
				}
			if (soap_flag_errorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "errorMessage", &(a->api__Response::errorMessage), "xsd:string"))
				{	soap_flag_errorMessage1--;
					continue;
				}
			if (soap_flag_union_Response1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__api__union_Response(soap, &a->api__Response::__union_Response, &a->api__Response::union_Response))
				{	soap_flag_union_Response1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__Response, 0, sizeof(api__Response), 0, soap_copy_api__Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_statusCode1 > 0 || soap_flag_union_Response1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__Response);
	if (this->soap_out(soap, tag?tag:"api:Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__Response(soap, this, tag, type);
}

SOAP_FMAC3 api__Response * SOAP_FMAC4 soap_get_api__Response(struct soap *soap, api__Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__Response * SOAP_FMAC2 soap_instantiate_api__Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__Response);
		if (size)
			*size = sizeof(api__Response);
		((api__Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__Response);
		for (int i = 0; i < n; i++)
			((api__Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__Response %p -> %p\n", q, p));
	*(api__Response*)p = *(api__Response*)q;
}

void api__authenticateSessionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->api__authenticateSessionResponse::return_ = NULL;
	/* transient soap skipped */
}

void api__authenticateSessionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__Response(soap, &this->api__authenticateSessionResponse::return_);
	/* transient soap skipped */
}

int api__authenticateSessionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__authenticateSessionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__authenticateSessionResponse(struct soap *soap, const char *tag, int id, const api__authenticateSessionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__authenticateSessionResponse), type))
		return soap->error;
	if (soap_out_PointerToapi__Response(soap, "return", -1, &(a->api__authenticateSessionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__authenticateSessionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__authenticateSessionResponse(soap, tag, this, type);
}

SOAP_FMAC3 api__authenticateSessionResponse * SOAP_FMAC4 soap_in_api__authenticateSessionResponse(struct soap *soap, const char *tag, api__authenticateSessionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__authenticateSessionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__authenticateSessionResponse, sizeof(api__authenticateSessionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__authenticateSessionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__authenticateSessionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__Response(soap, "return", &(a->api__authenticateSessionResponse::return_), "api:Response"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__authenticateSessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__authenticateSessionResponse, 0, sizeof(api__authenticateSessionResponse), 0, soap_copy_api__authenticateSessionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__authenticateSessionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__authenticateSessionResponse);
	if (this->soap_out(soap, tag?tag:"api:authenticateSessionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__authenticateSessionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__authenticateSessionResponse(soap, this, tag, type);
}

SOAP_FMAC3 api__authenticateSessionResponse * SOAP_FMAC4 soap_get_api__authenticateSessionResponse(struct soap *soap, api__authenticateSessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__authenticateSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__authenticateSessionResponse * SOAP_FMAC2 soap_instantiate_api__authenticateSessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__authenticateSessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__authenticateSessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__authenticateSessionResponse);
		if (size)
			*size = sizeof(api__authenticateSessionResponse);
		((api__authenticateSessionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__authenticateSessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__authenticateSessionResponse);
		for (int i = 0; i < n; i++)
			((api__authenticateSessionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__authenticateSessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__authenticateSessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__authenticateSessionResponse %p -> %p\n", q, p));
	*(api__authenticateSessionResponse*)p = *(api__authenticateSessionResponse*)q;
}

void api__authenticateSession::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->api__authenticateSession::userName);
	soap_default_std__string(soap, &this->api__authenticateSession::password);
	/* transient soap skipped */
}

void api__authenticateSession::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->api__authenticateSession::userName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__authenticateSession::userName);
	soap_embedded(soap, &this->api__authenticateSession::password, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->api__authenticateSession::password);
	/* transient soap skipped */
}

int api__authenticateSession::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_api__authenticateSession(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_api__authenticateSession(struct soap *soap, const char *tag, int id, const api__authenticateSession *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_api__authenticateSession), type))
		return soap->error;
	if (soap_out_std__string(soap, "userName", -1, &(a->api__authenticateSession::userName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "password", -1, &(a->api__authenticateSession::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *api__authenticateSession::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_api__authenticateSession(soap, tag, this, type);
}

SOAP_FMAC3 api__authenticateSession * SOAP_FMAC4 soap_in_api__authenticateSession(struct soap *soap, const char *tag, api__authenticateSession *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (api__authenticateSession *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_api__authenticateSession, sizeof(api__authenticateSession), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_api__authenticateSession)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (api__authenticateSession *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userName", &(a->api__authenticateSession::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "password", &(a->api__authenticateSession::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (api__authenticateSession *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_api__authenticateSession, 0, sizeof(api__authenticateSession), 0, soap_copy_api__authenticateSession);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userName1 > 0 || soap_flag_password1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int api__authenticateSession::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_api__authenticateSession);
	if (this->soap_out(soap, tag?tag:"api:authenticateSession", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *api__authenticateSession::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_api__authenticateSession(soap, this, tag, type);
}

SOAP_FMAC3 api__authenticateSession * SOAP_FMAC4 soap_get_api__authenticateSession(struct soap *soap, api__authenticateSession *p, const char *tag, const char *type)
{
	if ((p = soap_in_api__authenticateSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 api__authenticateSession * SOAP_FMAC2 soap_instantiate_api__authenticateSession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_api__authenticateSession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_api__authenticateSession, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(api__authenticateSession);
		if (size)
			*size = sizeof(api__authenticateSession);
		((api__authenticateSession*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(api__authenticateSession[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(api__authenticateSession);
		for (int i = 0; i < n; i++)
			((api__authenticateSession*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (api__authenticateSession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_api__authenticateSession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying api__authenticateSession %p -> %p\n", q, p));
	*(api__authenticateSession*)p = *(api__authenticateSession*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__listExecutions(struct soap *soap, struct __api__listExecutions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__listExecutions_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__listExecutions(struct soap *soap, const struct __api__listExecutions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__listExecutions(soap, &a->api__listExecutions_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__listExecutions(struct soap *soap, const char *tag, int id, const struct __api__listExecutions *a, const char *type)
{
	if (soap_out_PointerToapi__listExecutions(soap, "api:listExecutions", -1, &a->api__listExecutions_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__listExecutions * SOAP_FMAC4 soap_in___api__listExecutions(struct soap *soap, const char *tag, struct __api__listExecutions *a, const char *type)
{
	size_t soap_flag_api__listExecutions_ = 1;
	short soap_flag;
	a = (struct __api__listExecutions *)soap_id_enter(soap, "", a, SOAP_TYPE___api__listExecutions, sizeof(struct __api__listExecutions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__listExecutions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__listExecutions_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__listExecutions(soap, "api:listExecutions", &a->api__listExecutions_, "api:listExecutions"))
				{	soap_flag_api__listExecutions_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__listExecutions(struct soap *soap, const struct __api__listExecutions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__listExecutions(soap, tag?tag:"-api:listExecutions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__listExecutions * SOAP_FMAC4 soap_get___api__listExecutions(struct soap *soap, struct __api__listExecutions *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__listExecutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__listExecutions * SOAP_FMAC2 soap_instantiate___api__listExecutions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__listExecutions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__listExecutions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__listExecutions);
		if (size)
			*size = sizeof(struct __api__listExecutions);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__listExecutions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__listExecutions);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__listExecutions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__listExecutions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__listExecutions %p -> %p\n", q, p));
	*(struct __api__listExecutions*)p = *(struct __api__listExecutions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__listPipelines(struct soap *soap, struct __api__listPipelines *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__listPipelines_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__listPipelines(struct soap *soap, const struct __api__listPipelines *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__listPipelines(soap, &a->api__listPipelines_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__listPipelines(struct soap *soap, const char *tag, int id, const struct __api__listPipelines *a, const char *type)
{
	if (soap_out_PointerToapi__listPipelines(soap, "api:listPipelines", -1, &a->api__listPipelines_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__listPipelines * SOAP_FMAC4 soap_in___api__listPipelines(struct soap *soap, const char *tag, struct __api__listPipelines *a, const char *type)
{
	size_t soap_flag_api__listPipelines_ = 1;
	short soap_flag;
	a = (struct __api__listPipelines *)soap_id_enter(soap, "", a, SOAP_TYPE___api__listPipelines, sizeof(struct __api__listPipelines), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__listPipelines(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__listPipelines_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__listPipelines(soap, "api:listPipelines", &a->api__listPipelines_, "api:listPipelines"))
				{	soap_flag_api__listPipelines_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__listPipelines(struct soap *soap, const struct __api__listPipelines *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__listPipelines(soap, tag?tag:"-api:listPipelines", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__listPipelines * SOAP_FMAC4 soap_get___api__listPipelines(struct soap *soap, struct __api__listPipelines *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__listPipelines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__listPipelines * SOAP_FMAC2 soap_instantiate___api__listPipelines(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__listPipelines(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__listPipelines, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__listPipelines);
		if (size)
			*size = sizeof(struct __api__listPipelines);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__listPipelines[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__listPipelines);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__listPipelines*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__listPipelines(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__listPipelines %p -> %p\n", q, p));
	*(struct __api__listPipelines*)p = *(struct __api__listPipelines*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__playExecution(struct soap *soap, struct __api__playExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__playExecution_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__playExecution(struct soap *soap, const struct __api__playExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__playExecution(soap, &a->api__playExecution_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__playExecution(struct soap *soap, const char *tag, int id, const struct __api__playExecution *a, const char *type)
{
	if (soap_out_PointerToapi__playExecution(soap, "api:playExecution", -1, &a->api__playExecution_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__playExecution * SOAP_FMAC4 soap_in___api__playExecution(struct soap *soap, const char *tag, struct __api__playExecution *a, const char *type)
{
	size_t soap_flag_api__playExecution_ = 1;
	short soap_flag;
	a = (struct __api__playExecution *)soap_id_enter(soap, "", a, SOAP_TYPE___api__playExecution, sizeof(struct __api__playExecution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__playExecution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__playExecution_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__playExecution(soap, "api:playExecution", &a->api__playExecution_, "api:playExecution"))
				{	soap_flag_api__playExecution_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__playExecution(struct soap *soap, const struct __api__playExecution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__playExecution(soap, tag?tag:"-api:playExecution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__playExecution * SOAP_FMAC4 soap_get___api__playExecution(struct soap *soap, struct __api__playExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__playExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__playExecution * SOAP_FMAC2 soap_instantiate___api__playExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__playExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__playExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__playExecution);
		if (size)
			*size = sizeof(struct __api__playExecution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__playExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__playExecution);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__playExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__playExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__playExecution %p -> %p\n", q, p));
	*(struct __api__playExecution*)p = *(struct __api__playExecution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__getExecution(struct soap *soap, struct __api__getExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__getExecution_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__getExecution(struct soap *soap, const struct __api__getExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__getExecution(soap, &a->api__getExecution_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__getExecution(struct soap *soap, const char *tag, int id, const struct __api__getExecution *a, const char *type)
{
	if (soap_out_PointerToapi__getExecution(soap, "api:getExecution", -1, &a->api__getExecution_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__getExecution * SOAP_FMAC4 soap_in___api__getExecution(struct soap *soap, const char *tag, struct __api__getExecution *a, const char *type)
{
	size_t soap_flag_api__getExecution_ = 1;
	short soap_flag;
	a = (struct __api__getExecution *)soap_id_enter(soap, "", a, SOAP_TYPE___api__getExecution, sizeof(struct __api__getExecution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__getExecution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__getExecution_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__getExecution(soap, "api:getExecution", &a->api__getExecution_, "api:getExecution"))
				{	soap_flag_api__getExecution_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__getExecution(struct soap *soap, const struct __api__getExecution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__getExecution(soap, tag?tag:"-api:getExecution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__getExecution * SOAP_FMAC4 soap_get___api__getExecution(struct soap *soap, struct __api__getExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__getExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__getExecution * SOAP_FMAC2 soap_instantiate___api__getExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__getExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__getExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__getExecution);
		if (size)
			*size = sizeof(struct __api__getExecution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__getExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__getExecution);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__getExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__getExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__getExecution %p -> %p\n", q, p));
	*(struct __api__getExecution*)p = *(struct __api__getExecution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__killExecution(struct soap *soap, struct __api__killExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__killExecution_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__killExecution(struct soap *soap, const struct __api__killExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__killExecution(soap, &a->api__killExecution_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__killExecution(struct soap *soap, const char *tag, int id, const struct __api__killExecution *a, const char *type)
{
	if (soap_out_PointerToapi__killExecution(soap, "api:killExecution", -1, &a->api__killExecution_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__killExecution * SOAP_FMAC4 soap_in___api__killExecution(struct soap *soap, const char *tag, struct __api__killExecution *a, const char *type)
{
	size_t soap_flag_api__killExecution_ = 1;
	short soap_flag;
	a = (struct __api__killExecution *)soap_id_enter(soap, "", a, SOAP_TYPE___api__killExecution, sizeof(struct __api__killExecution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__killExecution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__killExecution_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__killExecution(soap, "api:killExecution", &a->api__killExecution_, "api:killExecution"))
				{	soap_flag_api__killExecution_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__killExecution(struct soap *soap, const struct __api__killExecution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__killExecution(soap, tag?tag:"-api:killExecution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__killExecution * SOAP_FMAC4 soap_get___api__killExecution(struct soap *soap, struct __api__killExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__killExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__killExecution * SOAP_FMAC2 soap_instantiate___api__killExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__killExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__killExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__killExecution);
		if (size)
			*size = sizeof(struct __api__killExecution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__killExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__killExecution);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__killExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__killExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__killExecution %p -> %p\n", q, p));
	*(struct __api__killExecution*)p = *(struct __api__killExecution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__getExecutionResults(struct soap *soap, struct __api__getExecutionResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__getExecutionResults_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__getExecutionResults(struct soap *soap, const struct __api__getExecutionResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__getExecutionResults(soap, &a->api__getExecutionResults_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__getExecutionResults(struct soap *soap, const char *tag, int id, const struct __api__getExecutionResults *a, const char *type)
{
	if (soap_out_PointerToapi__getExecutionResults(soap, "api:getExecutionResults", -1, &a->api__getExecutionResults_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__getExecutionResults * SOAP_FMAC4 soap_in___api__getExecutionResults(struct soap *soap, const char *tag, struct __api__getExecutionResults *a, const char *type)
{
	size_t soap_flag_api__getExecutionResults_ = 1;
	short soap_flag;
	a = (struct __api__getExecutionResults *)soap_id_enter(soap, "", a, SOAP_TYPE___api__getExecutionResults, sizeof(struct __api__getExecutionResults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__getExecutionResults(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__getExecutionResults_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__getExecutionResults(soap, "api:getExecutionResults", &a->api__getExecutionResults_, "api:getExecutionResults"))
				{	soap_flag_api__getExecutionResults_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__getExecutionResults(struct soap *soap, const struct __api__getExecutionResults *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__getExecutionResults(soap, tag?tag:"-api:getExecutionResults", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__getExecutionResults * SOAP_FMAC4 soap_get___api__getExecutionResults(struct soap *soap, struct __api__getExecutionResults *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__getExecutionResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__getExecutionResults * SOAP_FMAC2 soap_instantiate___api__getExecutionResults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__getExecutionResults(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__getExecutionResults, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__getExecutionResults);
		if (size)
			*size = sizeof(struct __api__getExecutionResults);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__getExecutionResults[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__getExecutionResults);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__getExecutionResults*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__getExecutionResults(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__getExecutionResults %p -> %p\n", q, p));
	*(struct __api__getExecutionResults*)p = *(struct __api__getExecutionResults*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__getStdErr(struct soap *soap, struct __api__getStdErr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__getStdErr_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__getStdErr(struct soap *soap, const struct __api__getStdErr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__getStdErr(soap, &a->api__getStdErr_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__getStdErr(struct soap *soap, const char *tag, int id, const struct __api__getStdErr *a, const char *type)
{
	if (soap_out_PointerToapi__getStdErr(soap, "api:getStdErr", -1, &a->api__getStdErr_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__getStdErr * SOAP_FMAC4 soap_in___api__getStdErr(struct soap *soap, const char *tag, struct __api__getStdErr *a, const char *type)
{
	size_t soap_flag_api__getStdErr_ = 1;
	short soap_flag;
	a = (struct __api__getStdErr *)soap_id_enter(soap, "", a, SOAP_TYPE___api__getStdErr, sizeof(struct __api__getStdErr), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__getStdErr(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__getStdErr_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__getStdErr(soap, "api:getStdErr", &a->api__getStdErr_, "api:getStdErr"))
				{	soap_flag_api__getStdErr_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__getStdErr(struct soap *soap, const struct __api__getStdErr *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__getStdErr(soap, tag?tag:"-api:getStdErr", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__getStdErr * SOAP_FMAC4 soap_get___api__getStdErr(struct soap *soap, struct __api__getStdErr *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__getStdErr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__getStdErr * SOAP_FMAC2 soap_instantiate___api__getStdErr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__getStdErr(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__getStdErr, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__getStdErr);
		if (size)
			*size = sizeof(struct __api__getStdErr);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__getStdErr[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__getStdErr);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__getStdErr*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__getStdErr(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__getStdErr %p -> %p\n", q, p));
	*(struct __api__getStdErr*)p = *(struct __api__getStdErr*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__getStdOut(struct soap *soap, struct __api__getStdOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__getStdOut_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__getStdOut(struct soap *soap, const struct __api__getStdOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__getStdOut(soap, &a->api__getStdOut_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__getStdOut(struct soap *soap, const char *tag, int id, const struct __api__getStdOut *a, const char *type)
{
	if (soap_out_PointerToapi__getStdOut(soap, "api:getStdOut", -1, &a->api__getStdOut_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__getStdOut * SOAP_FMAC4 soap_in___api__getStdOut(struct soap *soap, const char *tag, struct __api__getStdOut *a, const char *type)
{
	size_t soap_flag_api__getStdOut_ = 1;
	short soap_flag;
	a = (struct __api__getStdOut *)soap_id_enter(soap, "", a, SOAP_TYPE___api__getStdOut, sizeof(struct __api__getStdOut), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__getStdOut(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__getStdOut_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__getStdOut(soap, "api:getStdOut", &a->api__getStdOut_, "api:getStdOut"))
				{	soap_flag_api__getStdOut_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__getStdOut(struct soap *soap, const struct __api__getStdOut *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__getStdOut(soap, tag?tag:"-api:getStdOut", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__getStdOut * SOAP_FMAC4 soap_get___api__getStdOut(struct soap *soap, struct __api__getStdOut *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__getStdOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__getStdOut * SOAP_FMAC2 soap_instantiate___api__getStdOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__getStdOut(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__getStdOut, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__getStdOut);
		if (size)
			*size = sizeof(struct __api__getStdOut);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__getStdOut[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__getStdOut);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__getStdOut*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__getStdOut(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__getStdOut %p -> %p\n", q, p));
	*(struct __api__getStdOut*)p = *(struct __api__getStdOut*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__initExecution(struct soap *soap, struct __api__initExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__initExecution_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__initExecution(struct soap *soap, const struct __api__initExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__initExecution(soap, &a->api__initExecution_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__initExecution(struct soap *soap, const char *tag, int id, const struct __api__initExecution *a, const char *type)
{
	if (soap_out_PointerToapi__initExecution(soap, "api:initExecution", -1, &a->api__initExecution_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__initExecution * SOAP_FMAC4 soap_in___api__initExecution(struct soap *soap, const char *tag, struct __api__initExecution *a, const char *type)
{
	size_t soap_flag_api__initExecution_ = 1;
	short soap_flag;
	a = (struct __api__initExecution *)soap_id_enter(soap, "", a, SOAP_TYPE___api__initExecution, sizeof(struct __api__initExecution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__initExecution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__initExecution_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__initExecution(soap, "api:initExecution", &a->api__initExecution_, "api:initExecution"))
				{	soap_flag_api__initExecution_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__initExecution(struct soap *soap, const struct __api__initExecution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__initExecution(soap, tag?tag:"-api:initExecution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__initExecution * SOAP_FMAC4 soap_get___api__initExecution(struct soap *soap, struct __api__initExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__initExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__initExecution * SOAP_FMAC2 soap_instantiate___api__initExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__initExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__initExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__initExecution);
		if (size)
			*size = sizeof(struct __api__initExecution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__initExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__initExecution);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__initExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__initExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__initExecution %p -> %p\n", q, p));
	*(struct __api__initExecution*)p = *(struct __api__initExecution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__getGlobalProperties(struct soap *soap, struct __api__getGlobalProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__getGlobalProperties_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__getGlobalProperties(struct soap *soap, const struct __api__getGlobalProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__getGlobalProperties(soap, &a->api__getGlobalProperties_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__getGlobalProperties(struct soap *soap, const char *tag, int id, const struct __api__getGlobalProperties *a, const char *type)
{
	if (soap_out_PointerToapi__getGlobalProperties(soap, "api:getGlobalProperties", -1, &a->api__getGlobalProperties_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__getGlobalProperties * SOAP_FMAC4 soap_in___api__getGlobalProperties(struct soap *soap, const char *tag, struct __api__getGlobalProperties *a, const char *type)
{
	size_t soap_flag_api__getGlobalProperties_ = 1;
	short soap_flag;
	a = (struct __api__getGlobalProperties *)soap_id_enter(soap, "", a, SOAP_TYPE___api__getGlobalProperties, sizeof(struct __api__getGlobalProperties), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__getGlobalProperties(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__getGlobalProperties_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__getGlobalProperties(soap, "api:getGlobalProperties", &a->api__getGlobalProperties_, "api:getGlobalProperties"))
				{	soap_flag_api__getGlobalProperties_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__getGlobalProperties(struct soap *soap, const struct __api__getGlobalProperties *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__getGlobalProperties(soap, tag?tag:"-api:getGlobalProperties", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__getGlobalProperties * SOAP_FMAC4 soap_get___api__getGlobalProperties(struct soap *soap, struct __api__getGlobalProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__getGlobalProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__getGlobalProperties * SOAP_FMAC2 soap_instantiate___api__getGlobalProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__getGlobalProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__getGlobalProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__getGlobalProperties);
		if (size)
			*size = sizeof(struct __api__getGlobalProperties);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__getGlobalProperties[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__getGlobalProperties);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__getGlobalProperties*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__getGlobalProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__getGlobalProperties %p -> %p\n", q, p));
	*(struct __api__getGlobalProperties*)p = *(struct __api__getGlobalProperties*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__updateExecution(struct soap *soap, struct __api__updateExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__updateExecution_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__updateExecution(struct soap *soap, const struct __api__updateExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__updateExecution(soap, &a->api__updateExecution_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__updateExecution(struct soap *soap, const char *tag, int id, const struct __api__updateExecution *a, const char *type)
{
	if (soap_out_PointerToapi__updateExecution(soap, "api:updateExecution", -1, &a->api__updateExecution_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__updateExecution * SOAP_FMAC4 soap_in___api__updateExecution(struct soap *soap, const char *tag, struct __api__updateExecution *a, const char *type)
{
	size_t soap_flag_api__updateExecution_ = 1;
	short soap_flag;
	a = (struct __api__updateExecution *)soap_id_enter(soap, "", a, SOAP_TYPE___api__updateExecution, sizeof(struct __api__updateExecution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__updateExecution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__updateExecution_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__updateExecution(soap, "api:updateExecution", &a->api__updateExecution_, "api:updateExecution"))
				{	soap_flag_api__updateExecution_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__updateExecution(struct soap *soap, const struct __api__updateExecution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__updateExecution(soap, tag?tag:"-api:updateExecution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__updateExecution * SOAP_FMAC4 soap_get___api__updateExecution(struct soap *soap, struct __api__updateExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__updateExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__updateExecution * SOAP_FMAC2 soap_instantiate___api__updateExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__updateExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__updateExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__updateExecution);
		if (size)
			*size = sizeof(struct __api__updateExecution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__updateExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__updateExecution);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__updateExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__updateExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__updateExecution %p -> %p\n", q, p));
	*(struct __api__updateExecution*)p = *(struct __api__updateExecution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__logout(struct soap *soap, struct __api__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__logout_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__logout(struct soap *soap, const struct __api__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__logout(soap, &a->api__logout_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__logout(struct soap *soap, const char *tag, int id, const struct __api__logout *a, const char *type)
{
	if (soap_out_PointerToapi__logout(soap, "api:logout", -1, &a->api__logout_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__logout * SOAP_FMAC4 soap_in___api__logout(struct soap *soap, const char *tag, struct __api__logout *a, const char *type)
{
	size_t soap_flag_api__logout_ = 1;
	short soap_flag;
	a = (struct __api__logout *)soap_id_enter(soap, "", a, SOAP_TYPE___api__logout, sizeof(struct __api__logout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__logout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__logout_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__logout(soap, "api:logout", &a->api__logout_, "api:logout"))
				{	soap_flag_api__logout_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__logout(struct soap *soap, const struct __api__logout *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__logout(soap, tag?tag:"-api:logout", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__logout * SOAP_FMAC4 soap_get___api__logout(struct soap *soap, struct __api__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__logout * SOAP_FMAC2 soap_instantiate___api__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__logout);
		if (size)
			*size = sizeof(struct __api__logout);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__logout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__logout);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__logout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__logout %p -> %p\n", q, p));
	*(struct __api__logout*)p = *(struct __api__logout*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__authenticateHTTP(struct soap *soap, struct __api__authenticateHTTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__authenticateHTTP_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__authenticateHTTP(struct soap *soap, const struct __api__authenticateHTTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__authenticateHTTP(soap, &a->api__authenticateHTTP_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__authenticateHTTP(struct soap *soap, const char *tag, int id, const struct __api__authenticateHTTP *a, const char *type)
{
	if (soap_out_PointerToapi__authenticateHTTP(soap, "api:authenticateHTTP", -1, &a->api__authenticateHTTP_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__authenticateHTTP * SOAP_FMAC4 soap_in___api__authenticateHTTP(struct soap *soap, const char *tag, struct __api__authenticateHTTP *a, const char *type)
{
	size_t soap_flag_api__authenticateHTTP_ = 1;
	short soap_flag;
	a = (struct __api__authenticateHTTP *)soap_id_enter(soap, "", a, SOAP_TYPE___api__authenticateHTTP, sizeof(struct __api__authenticateHTTP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__authenticateHTTP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__authenticateHTTP_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__authenticateHTTP(soap, "api:authenticateHTTP", &a->api__authenticateHTTP_, "api:authenticateHTTP"))
				{	soap_flag_api__authenticateHTTP_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__authenticateHTTP(struct soap *soap, const struct __api__authenticateHTTP *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__authenticateHTTP(soap, tag?tag:"-api:authenticateHTTP", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__authenticateHTTP * SOAP_FMAC4 soap_get___api__authenticateHTTP(struct soap *soap, struct __api__authenticateHTTP *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__authenticateHTTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__authenticateHTTP * SOAP_FMAC2 soap_instantiate___api__authenticateHTTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__authenticateHTTP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__authenticateHTTP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__authenticateHTTP);
		if (size)
			*size = sizeof(struct __api__authenticateHTTP);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__authenticateHTTP[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__authenticateHTTP);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__authenticateHTTP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__authenticateHTTP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__authenticateHTTP %p -> %p\n", q, p));
	*(struct __api__authenticateHTTP*)p = *(struct __api__authenticateHTTP*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__getPipeline(struct soap *soap, struct __api__getPipeline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__getPipeline_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__getPipeline(struct soap *soap, const struct __api__getPipeline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__getPipeline(soap, &a->api__getPipeline_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__getPipeline(struct soap *soap, const char *tag, int id, const struct __api__getPipeline *a, const char *type)
{
	if (soap_out_PointerToapi__getPipeline(soap, "api:getPipeline", -1, &a->api__getPipeline_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__getPipeline * SOAP_FMAC4 soap_in___api__getPipeline(struct soap *soap, const char *tag, struct __api__getPipeline *a, const char *type)
{
	size_t soap_flag_api__getPipeline_ = 1;
	short soap_flag;
	a = (struct __api__getPipeline *)soap_id_enter(soap, "", a, SOAP_TYPE___api__getPipeline, sizeof(struct __api__getPipeline), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__getPipeline(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__getPipeline_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__getPipeline(soap, "api:getPipeline", &a->api__getPipeline_, "api:getPipeline"))
				{	soap_flag_api__getPipeline_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__getPipeline(struct soap *soap, const struct __api__getPipeline *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__getPipeline(soap, tag?tag:"-api:getPipeline", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__getPipeline * SOAP_FMAC4 soap_get___api__getPipeline(struct soap *soap, struct __api__getPipeline *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__getPipeline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__getPipeline * SOAP_FMAC2 soap_instantiate___api__getPipeline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__getPipeline(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__getPipeline, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__getPipeline);
		if (size)
			*size = sizeof(struct __api__getPipeline);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__getPipeline[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__getPipeline);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__getPipeline*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__getPipeline(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__getPipeline %p -> %p\n", q, p));
	*(struct __api__getPipeline*)p = *(struct __api__getPipeline*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__deleteExecution(struct soap *soap, struct __api__deleteExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__deleteExecution_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__deleteExecution(struct soap *soap, const struct __api__deleteExecution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__deleteExecution(soap, &a->api__deleteExecution_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__deleteExecution(struct soap *soap, const char *tag, int id, const struct __api__deleteExecution *a, const char *type)
{
	if (soap_out_PointerToapi__deleteExecution(soap, "api:deleteExecution", -1, &a->api__deleteExecution_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__deleteExecution * SOAP_FMAC4 soap_in___api__deleteExecution(struct soap *soap, const char *tag, struct __api__deleteExecution *a, const char *type)
{
	size_t soap_flag_api__deleteExecution_ = 1;
	short soap_flag;
	a = (struct __api__deleteExecution *)soap_id_enter(soap, "", a, SOAP_TYPE___api__deleteExecution, sizeof(struct __api__deleteExecution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__deleteExecution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__deleteExecution_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__deleteExecution(soap, "api:deleteExecution", &a->api__deleteExecution_, "api:deleteExecution"))
				{	soap_flag_api__deleteExecution_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__deleteExecution(struct soap *soap, const struct __api__deleteExecution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__deleteExecution(soap, tag?tag:"-api:deleteExecution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__deleteExecution * SOAP_FMAC4 soap_get___api__deleteExecution(struct soap *soap, struct __api__deleteExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__deleteExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__deleteExecution * SOAP_FMAC2 soap_instantiate___api__deleteExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__deleteExecution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__deleteExecution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__deleteExecution);
		if (size)
			*size = sizeof(struct __api__deleteExecution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__deleteExecution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__deleteExecution);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__deleteExecution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__deleteExecution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__deleteExecution %p -> %p\n", q, p));
	*(struct __api__deleteExecution*)p = *(struct __api__deleteExecution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___api__authenticateSession(struct soap *soap, struct __api__authenticateSession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->api__authenticateSession_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___api__authenticateSession(struct soap *soap, const struct __api__authenticateSession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapi__authenticateSession(soap, &a->api__authenticateSession_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___api__authenticateSession(struct soap *soap, const char *tag, int id, const struct __api__authenticateSession *a, const char *type)
{
	if (soap_out_PointerToapi__authenticateSession(soap, "api:authenticateSession", -1, &a->api__authenticateSession_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__authenticateSession * SOAP_FMAC4 soap_in___api__authenticateSession(struct soap *soap, const char *tag, struct __api__authenticateSession *a, const char *type)
{
	size_t soap_flag_api__authenticateSession_ = 1;
	short soap_flag;
	a = (struct __api__authenticateSession *)soap_id_enter(soap, "", a, SOAP_TYPE___api__authenticateSession, sizeof(struct __api__authenticateSession), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___api__authenticateSession(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_api__authenticateSession_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapi__authenticateSession(soap, "api:authenticateSession", &a->api__authenticateSession_, "api:authenticateSession"))
				{	soap_flag_api__authenticateSession_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___api__authenticateSession(struct soap *soap, const struct __api__authenticateSession *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___api__authenticateSession(soap, tag?tag:"-api:authenticateSession", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __api__authenticateSession * SOAP_FMAC4 soap_get___api__authenticateSession(struct soap *soap, struct __api__authenticateSession *p, const char *tag, const char *type)
{
	if ((p = soap_in___api__authenticateSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __api__authenticateSession * SOAP_FMAC2 soap_instantiate___api__authenticateSession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___api__authenticateSession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___api__authenticateSession, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __api__authenticateSession);
		if (size)
			*size = sizeof(struct __api__authenticateSession);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __api__authenticateSession[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __api__authenticateSession);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __api__authenticateSession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___api__authenticateSession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __api__authenticateSession %p -> %p\n", q, p));
	*(struct __api__authenticateSession*)p = *(struct __api__authenticateSession*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__api__union_StringKeyValuePair(struct soap *soap, int choice, const union _api__union_StringKeyValuePair *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__api__union_StringKeyValuePair_valueStr:
		soap_serialize_PointerTostd__string(soap, &a->valueStr);
		break;
	case SOAP_UNION__api__union_StringKeyValuePair_valueInt:
		soap_embedded(soap, &a->valueInt, SOAP_TYPE_int);
		break;
	case SOAP_UNION__api__union_StringKeyValuePair_valueStatus:
		soap_embedded(soap, &a->valueStatus, SOAP_TYPE_api__ExecutionStatus);
		break;
	case SOAP_UNION__api__union_StringKeyValuePair_valueParamType:
		soap_serialize_PointerToapi__ParameterTypedValue(soap, &a->valueParamType);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__api__union_StringKeyValuePair(struct soap *soap, int choice, const union _api__union_StringKeyValuePair *a)
{
	switch (choice)
	{
	case SOAP_UNION__api__union_StringKeyValuePair_valueStr:
		return soap_out_PointerTostd__string(soap, "valueStr", -1, &a->valueStr, "");
	case SOAP_UNION__api__union_StringKeyValuePair_valueInt:
		return soap_out_int(soap, "valueInt", -1, &a->valueInt, "");
	case SOAP_UNION__api__union_StringKeyValuePair_valueStatus:
		return soap_out_api__ExecutionStatus(soap, "valueStatus", -1, &a->valueStatus, "");
	case SOAP_UNION__api__union_StringKeyValuePair_valueParamType:
		return soap_out_PointerToapi__ParameterTypedValue(soap, "valueParamType", -1, &a->valueParamType, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _api__union_StringKeyValuePair * SOAP_FMAC4 soap_in__api__union_StringKeyValuePair(struct soap *soap, int *choice, union _api__union_StringKeyValuePair *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->valueStr = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__string(soap, "valueStr", &a->valueStr, "xsd:string"))
	{	*choice = SOAP_UNION__api__union_StringKeyValuePair_valueStr;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_int(soap, "valueInt", &a->valueInt, "xsd:int"))
	{	*choice = SOAP_UNION__api__union_StringKeyValuePair_valueInt;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_api__ExecutionStatus(soap, "valueStatus", &a->valueStatus, "api:ExecutionStatus"))
	{	*choice = SOAP_UNION__api__union_StringKeyValuePair_valueStatus;
		return a;
	}
	a->valueParamType = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToapi__ParameterTypedValue(soap, "valueParamType", &a->valueParamType, "api:ParameterTypedValue"))
	{	*choice = SOAP_UNION__api__union_StringKeyValuePair_valueParamType;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__api__union_ParameterTypedValue(struct soap *soap, int choice, const union _api__union_ParameterTypedValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__api__union_ParameterTypedValue_valueStr:
		soap_serialize_PointerTostd__string(soap, &a->valueStr);
		break;
	case SOAP_UNION__api__union_ParameterTypedValue_valueBool:
		soap_embedded(soap, &a->valueBool, SOAP_TYPE_bool);
		break;
	case SOAP_UNION__api__union_ParameterTypedValue_valueInt:
		soap_embedded(soap, &a->valueInt, SOAP_TYPE_int);
		break;
	case SOAP_UNION__api__union_ParameterTypedValue_valueDouble:
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__api__union_ParameterTypedValue(struct soap *soap, int choice, const union _api__union_ParameterTypedValue *a)
{
	switch (choice)
	{
	case SOAP_UNION__api__union_ParameterTypedValue_valueStr:
		return soap_out_PointerTostd__string(soap, "valueStr", -1, &a->valueStr, "");
	case SOAP_UNION__api__union_ParameterTypedValue_valueBool:
		return soap_out_bool(soap, "valueBool", -1, &a->valueBool, "");
	case SOAP_UNION__api__union_ParameterTypedValue_valueInt:
		return soap_out_int(soap, "valueInt", -1, &a->valueInt, "");
	case SOAP_UNION__api__union_ParameterTypedValue_valueDouble:
		return soap_out_double(soap, "valueDouble", -1, &a->valueDouble, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _api__union_ParameterTypedValue * SOAP_FMAC4 soap_in__api__union_ParameterTypedValue(struct soap *soap, int *choice, union _api__union_ParameterTypedValue *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->valueStr = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__string(soap, "valueStr", &a->valueStr, "xsd:string"))
	{	*choice = SOAP_UNION__api__union_ParameterTypedValue_valueStr;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_bool(soap, "valueBool", &a->valueBool, "xsd:boolean"))
	{	*choice = SOAP_UNION__api__union_ParameterTypedValue_valueBool;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_int(soap, "valueInt", &a->valueInt, "xsd:int"))
	{	*choice = SOAP_UNION__api__union_ParameterTypedValue_valueInt;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_double(soap, "valueDouble", &a->valueDouble, "xsd:double"))
	{	*choice = SOAP_UNION__api__union_ParameterTypedValue_valueDouble;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__api__union_Response(struct soap *soap, int choice, const union _api__union_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__api__union_Response_returnedValuePipeline:
		soap_serialize_PointerTostd__vectorTemplateOfPointerToapi__Pipeline(soap, &a->returnedValuePipeline);
		break;
	case SOAP_UNION__api__union_Response_returnedValueExecution:
		soap_serialize_PointerToapi__Execution(soap, &a->returnedValueExecution);
		break;
	case SOAP_UNION__api__union_Response_returnedValueGlobalProp:
		soap_serialize_PointerToapi__GlobalProperties(soap, &a->returnedValueGlobalProp);
		break;
	case SOAP_UNION__api__union_Response_returnedValueStr:
		soap_serialize_PointerTostd__vectorTemplateOfstd__string(soap, &a->returnedValueStr);
		break;
	case SOAP_UNION__api__union_Response_returnedValueListStrings:
		soap_serialize_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfStrings(soap, &a->returnedValueListStrings);
		break;
	case SOAP_UNION__api__union_Response_returnedValueListExecutions:
		soap_serialize_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfExecutions(soap, &a->returnedValueListExecutions);
		break;
	case SOAP_UNION__api__union_Response_returnedValueListPipelines:
		soap_serialize_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfPipelines(soap, &a->returnedValueListPipelines);
		break;
	case SOAP_UNION__api__union_Response_returnedValueStatus:
		soap_serialize_PointerToapi__ExecutionStatus(soap, &a->returnedValueStatus);
		break;
	case SOAP_UNION__api__union_Response_returnedValuePairKey:
		soap_serialize_PointerTostd__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(soap, &a->returnedValuePairKey);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__api__union_Response(struct soap *soap, int choice, const union _api__union_Response *a)
{
	switch (choice)
	{
	case SOAP_UNION__api__union_Response_returnedValuePipeline:
		return soap_out_PointerTostd__vectorTemplateOfPointerToapi__Pipeline(soap, "returnedValuePipeline", -1, &a->returnedValuePipeline, "");
	case SOAP_UNION__api__union_Response_returnedValueExecution:
		return soap_out_PointerToapi__Execution(soap, "returnedValueExecution", -1, &a->returnedValueExecution, "");
	case SOAP_UNION__api__union_Response_returnedValueGlobalProp:
		return soap_out_PointerToapi__GlobalProperties(soap, "returnedValueGlobalProp", -1, &a->returnedValueGlobalProp, "");
	case SOAP_UNION__api__union_Response_returnedValueStr:
		return soap_out_PointerTostd__vectorTemplateOfstd__string(soap, "returnedValueStr", -1, &a->returnedValueStr, "");
	case SOAP_UNION__api__union_Response_returnedValueListStrings:
		return soap_out_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfStrings(soap, "returnedValueListStrings", -1, &a->returnedValueListStrings, "");
	case SOAP_UNION__api__union_Response_returnedValueListExecutions:
		return soap_out_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfExecutions(soap, "returnedValueListExecutions", -1, &a->returnedValueListExecutions, "");
	case SOAP_UNION__api__union_Response_returnedValueListPipelines:
		return soap_out_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfPipelines(soap, "returnedValueListPipelines", -1, &a->returnedValueListPipelines, "");
	case SOAP_UNION__api__union_Response_returnedValueStatus:
		return soap_out_PointerToapi__ExecutionStatus(soap, "returnedValueStatus", -1, &a->returnedValueStatus, "");
	case SOAP_UNION__api__union_Response_returnedValuePairKey:
		return soap_out_PointerTostd__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(soap, "returnedValuePairKey", -1, &a->returnedValuePairKey, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _api__union_Response * SOAP_FMAC4 soap_in__api__union_Response(struct soap *soap, int *choice, union _api__union_Response *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->returnedValuePipeline = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerToapi__Pipeline(soap, "returnedValuePipeline", &a->returnedValuePipeline, "api:Pipeline"))
	{	*choice = SOAP_UNION__api__union_Response_returnedValuePipeline;
		return a;
	}
	a->returnedValueExecution = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToapi__Execution(soap, "returnedValueExecution", &a->returnedValueExecution, "api:Execution"))
	{	*choice = SOAP_UNION__api__union_Response_returnedValueExecution;
		return a;
	}
	a->returnedValueGlobalProp = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToapi__GlobalProperties(soap, "returnedValueGlobalProp", &a->returnedValueGlobalProp, "api:GlobalProperties"))
	{	*choice = SOAP_UNION__api__union_Response_returnedValueGlobalProp;
		return a;
	}
	a->returnedValueStr = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfstd__string(soap, "returnedValueStr", &a->returnedValueStr, "xsd:string"))
	{	*choice = SOAP_UNION__api__union_Response_returnedValueStr;
		return a;
	}
	a->returnedValueListStrings = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfStrings(soap, "returnedValueListStrings", &a->returnedValueListStrings, "api:ArrayOfStrings"))
	{	*choice = SOAP_UNION__api__union_Response_returnedValueListStrings;
		return a;
	}
	a->returnedValueListExecutions = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfExecutions(soap, "returnedValueListExecutions", &a->returnedValueListExecutions, "api:ArrayOfExecutions"))
	{	*choice = SOAP_UNION__api__union_Response_returnedValueListExecutions;
		return a;
	}
	a->returnedValueListPipelines = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfPipelines(soap, "returnedValueListPipelines", &a->returnedValueListPipelines, "api:ArrayOfPipelines"))
	{	*choice = SOAP_UNION__api__union_Response_returnedValueListPipelines;
		return a;
	}
	a->returnedValueStatus = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToapi__ExecutionStatus(soap, "returnedValueStatus", &a->returnedValueStatus, "api:ExecutionStatus"))
	{	*choice = SOAP_UNION__api__union_Response_returnedValueStatus;
		return a;
	}
	a->returnedValuePairKey = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(soap, "returnedValuePairKey", &a->returnedValuePairKey, "api:PipelineKeyBooleanValuePair"))
	{	*choice = SOAP_UNION__api__union_Response_returnedValuePairKey;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__listExecutionsResponse(struct soap *soap, api__listExecutionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__listExecutionsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__listExecutionsResponse(struct soap *soap, const char *tag, int id, api__listExecutionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__listExecutionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__listExecutionsResponse ** SOAP_FMAC4 soap_in_PointerToapi__listExecutionsResponse(struct soap *soap, const char *tag, api__listExecutionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__listExecutionsResponse **)soap_malloc(soap, sizeof(api__listExecutionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__listExecutionsResponse *)soap_instantiate_api__listExecutionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__listExecutionsResponse ** p = (api__listExecutionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__listExecutionsResponse, sizeof(api__listExecutionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__listExecutionsResponse(struct soap *soap, api__listExecutionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__listExecutionsResponse);
	if (soap_out_PointerToapi__listExecutionsResponse(soap, tag?tag:"api:listExecutionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__listExecutionsResponse ** SOAP_FMAC4 soap_get_PointerToapi__listExecutionsResponse(struct soap *soap, api__listExecutionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__listExecutionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__listExecutions(struct soap *soap, api__listExecutions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__listExecutions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__listExecutions(struct soap *soap, const char *tag, int id, api__listExecutions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__listExecutions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__listExecutions ** SOAP_FMAC4 soap_in_PointerToapi__listExecutions(struct soap *soap, const char *tag, api__listExecutions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__listExecutions **)soap_malloc(soap, sizeof(api__listExecutions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__listExecutions *)soap_instantiate_api__listExecutions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__listExecutions ** p = (api__listExecutions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__listExecutions, sizeof(api__listExecutions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__listExecutions(struct soap *soap, api__listExecutions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__listExecutions);
	if (soap_out_PointerToapi__listExecutions(soap, tag?tag:"api:listExecutions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__listExecutions ** SOAP_FMAC4 soap_get_PointerToapi__listExecutions(struct soap *soap, api__listExecutions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__listExecutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__listPipelinesResponse(struct soap *soap, api__listPipelinesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__listPipelinesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__listPipelinesResponse(struct soap *soap, const char *tag, int id, api__listPipelinesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__listPipelinesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__listPipelinesResponse ** SOAP_FMAC4 soap_in_PointerToapi__listPipelinesResponse(struct soap *soap, const char *tag, api__listPipelinesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__listPipelinesResponse **)soap_malloc(soap, sizeof(api__listPipelinesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__listPipelinesResponse *)soap_instantiate_api__listPipelinesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__listPipelinesResponse ** p = (api__listPipelinesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__listPipelinesResponse, sizeof(api__listPipelinesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__listPipelinesResponse(struct soap *soap, api__listPipelinesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__listPipelinesResponse);
	if (soap_out_PointerToapi__listPipelinesResponse(soap, tag?tag:"api:listPipelinesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__listPipelinesResponse ** SOAP_FMAC4 soap_get_PointerToapi__listPipelinesResponse(struct soap *soap, api__listPipelinesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__listPipelinesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__listPipelines(struct soap *soap, api__listPipelines *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__listPipelines))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__listPipelines(struct soap *soap, const char *tag, int id, api__listPipelines *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__listPipelines);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__listPipelines ** SOAP_FMAC4 soap_in_PointerToapi__listPipelines(struct soap *soap, const char *tag, api__listPipelines **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__listPipelines **)soap_malloc(soap, sizeof(api__listPipelines *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__listPipelines *)soap_instantiate_api__listPipelines(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__listPipelines ** p = (api__listPipelines **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__listPipelines, sizeof(api__listPipelines), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__listPipelines(struct soap *soap, api__listPipelines *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__listPipelines);
	if (soap_out_PointerToapi__listPipelines(soap, tag?tag:"api:listPipelines", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__listPipelines ** SOAP_FMAC4 soap_get_PointerToapi__listPipelines(struct soap *soap, api__listPipelines **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__listPipelines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__playExecutionResponse(struct soap *soap, api__playExecutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__playExecutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__playExecutionResponse(struct soap *soap, const char *tag, int id, api__playExecutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__playExecutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__playExecutionResponse ** SOAP_FMAC4 soap_in_PointerToapi__playExecutionResponse(struct soap *soap, const char *tag, api__playExecutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__playExecutionResponse **)soap_malloc(soap, sizeof(api__playExecutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__playExecutionResponse *)soap_instantiate_api__playExecutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__playExecutionResponse ** p = (api__playExecutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__playExecutionResponse, sizeof(api__playExecutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__playExecutionResponse(struct soap *soap, api__playExecutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__playExecutionResponse);
	if (soap_out_PointerToapi__playExecutionResponse(soap, tag?tag:"api:playExecutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__playExecutionResponse ** SOAP_FMAC4 soap_get_PointerToapi__playExecutionResponse(struct soap *soap, api__playExecutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__playExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__playExecution(struct soap *soap, api__playExecution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__playExecution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__playExecution(struct soap *soap, const char *tag, int id, api__playExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__playExecution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__playExecution ** SOAP_FMAC4 soap_in_PointerToapi__playExecution(struct soap *soap, const char *tag, api__playExecution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__playExecution **)soap_malloc(soap, sizeof(api__playExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__playExecution *)soap_instantiate_api__playExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__playExecution ** p = (api__playExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__playExecution, sizeof(api__playExecution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__playExecution(struct soap *soap, api__playExecution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__playExecution);
	if (soap_out_PointerToapi__playExecution(soap, tag?tag:"api:playExecution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__playExecution ** SOAP_FMAC4 soap_get_PointerToapi__playExecution(struct soap *soap, api__playExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__playExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__getExecutionResponse(struct soap *soap, api__getExecutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__getExecutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__getExecutionResponse(struct soap *soap, const char *tag, int id, api__getExecutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__getExecutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__getExecutionResponse ** SOAP_FMAC4 soap_in_PointerToapi__getExecutionResponse(struct soap *soap, const char *tag, api__getExecutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__getExecutionResponse **)soap_malloc(soap, sizeof(api__getExecutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__getExecutionResponse *)soap_instantiate_api__getExecutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__getExecutionResponse ** p = (api__getExecutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__getExecutionResponse, sizeof(api__getExecutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__getExecutionResponse(struct soap *soap, api__getExecutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__getExecutionResponse);
	if (soap_out_PointerToapi__getExecutionResponse(soap, tag?tag:"api:getExecutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__getExecutionResponse ** SOAP_FMAC4 soap_get_PointerToapi__getExecutionResponse(struct soap *soap, api__getExecutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__getExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__getExecution(struct soap *soap, api__getExecution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__getExecution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__getExecution(struct soap *soap, const char *tag, int id, api__getExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__getExecution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__getExecution ** SOAP_FMAC4 soap_in_PointerToapi__getExecution(struct soap *soap, const char *tag, api__getExecution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__getExecution **)soap_malloc(soap, sizeof(api__getExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__getExecution *)soap_instantiate_api__getExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__getExecution ** p = (api__getExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__getExecution, sizeof(api__getExecution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__getExecution(struct soap *soap, api__getExecution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__getExecution);
	if (soap_out_PointerToapi__getExecution(soap, tag?tag:"api:getExecution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__getExecution ** SOAP_FMAC4 soap_get_PointerToapi__getExecution(struct soap *soap, api__getExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__getExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__killExecutionResponse(struct soap *soap, api__killExecutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__killExecutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__killExecutionResponse(struct soap *soap, const char *tag, int id, api__killExecutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__killExecutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__killExecutionResponse ** SOAP_FMAC4 soap_in_PointerToapi__killExecutionResponse(struct soap *soap, const char *tag, api__killExecutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__killExecutionResponse **)soap_malloc(soap, sizeof(api__killExecutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__killExecutionResponse *)soap_instantiate_api__killExecutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__killExecutionResponse ** p = (api__killExecutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__killExecutionResponse, sizeof(api__killExecutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__killExecutionResponse(struct soap *soap, api__killExecutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__killExecutionResponse);
	if (soap_out_PointerToapi__killExecutionResponse(soap, tag?tag:"api:killExecutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__killExecutionResponse ** SOAP_FMAC4 soap_get_PointerToapi__killExecutionResponse(struct soap *soap, api__killExecutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__killExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__killExecution(struct soap *soap, api__killExecution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__killExecution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__killExecution(struct soap *soap, const char *tag, int id, api__killExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__killExecution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__killExecution ** SOAP_FMAC4 soap_in_PointerToapi__killExecution(struct soap *soap, const char *tag, api__killExecution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__killExecution **)soap_malloc(soap, sizeof(api__killExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__killExecution *)soap_instantiate_api__killExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__killExecution ** p = (api__killExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__killExecution, sizeof(api__killExecution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__killExecution(struct soap *soap, api__killExecution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__killExecution);
	if (soap_out_PointerToapi__killExecution(soap, tag?tag:"api:killExecution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__killExecution ** SOAP_FMAC4 soap_get_PointerToapi__killExecution(struct soap *soap, api__killExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__killExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__getExecutionResultsResponse(struct soap *soap, api__getExecutionResultsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__getExecutionResultsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__getExecutionResultsResponse(struct soap *soap, const char *tag, int id, api__getExecutionResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__getExecutionResultsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__getExecutionResultsResponse ** SOAP_FMAC4 soap_in_PointerToapi__getExecutionResultsResponse(struct soap *soap, const char *tag, api__getExecutionResultsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__getExecutionResultsResponse **)soap_malloc(soap, sizeof(api__getExecutionResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__getExecutionResultsResponse *)soap_instantiate_api__getExecutionResultsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__getExecutionResultsResponse ** p = (api__getExecutionResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__getExecutionResultsResponse, sizeof(api__getExecutionResultsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__getExecutionResultsResponse(struct soap *soap, api__getExecutionResultsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__getExecutionResultsResponse);
	if (soap_out_PointerToapi__getExecutionResultsResponse(soap, tag?tag:"api:getExecutionResultsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__getExecutionResultsResponse ** SOAP_FMAC4 soap_get_PointerToapi__getExecutionResultsResponse(struct soap *soap, api__getExecutionResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__getExecutionResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__getExecutionResults(struct soap *soap, api__getExecutionResults *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__getExecutionResults))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__getExecutionResults(struct soap *soap, const char *tag, int id, api__getExecutionResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__getExecutionResults);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__getExecutionResults ** SOAP_FMAC4 soap_in_PointerToapi__getExecutionResults(struct soap *soap, const char *tag, api__getExecutionResults **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__getExecutionResults **)soap_malloc(soap, sizeof(api__getExecutionResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__getExecutionResults *)soap_instantiate_api__getExecutionResults(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__getExecutionResults ** p = (api__getExecutionResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__getExecutionResults, sizeof(api__getExecutionResults), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__getExecutionResults(struct soap *soap, api__getExecutionResults *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__getExecutionResults);
	if (soap_out_PointerToapi__getExecutionResults(soap, tag?tag:"api:getExecutionResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__getExecutionResults ** SOAP_FMAC4 soap_get_PointerToapi__getExecutionResults(struct soap *soap, api__getExecutionResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__getExecutionResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__getStdErrResponse(struct soap *soap, api__getStdErrResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__getStdErrResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__getStdErrResponse(struct soap *soap, const char *tag, int id, api__getStdErrResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__getStdErrResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__getStdErrResponse ** SOAP_FMAC4 soap_in_PointerToapi__getStdErrResponse(struct soap *soap, const char *tag, api__getStdErrResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__getStdErrResponse **)soap_malloc(soap, sizeof(api__getStdErrResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__getStdErrResponse *)soap_instantiate_api__getStdErrResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__getStdErrResponse ** p = (api__getStdErrResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__getStdErrResponse, sizeof(api__getStdErrResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__getStdErrResponse(struct soap *soap, api__getStdErrResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__getStdErrResponse);
	if (soap_out_PointerToapi__getStdErrResponse(soap, tag?tag:"api:getStdErrResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__getStdErrResponse ** SOAP_FMAC4 soap_get_PointerToapi__getStdErrResponse(struct soap *soap, api__getStdErrResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__getStdErrResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__getStdErr(struct soap *soap, api__getStdErr *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__getStdErr))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__getStdErr(struct soap *soap, const char *tag, int id, api__getStdErr *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__getStdErr);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__getStdErr ** SOAP_FMAC4 soap_in_PointerToapi__getStdErr(struct soap *soap, const char *tag, api__getStdErr **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__getStdErr **)soap_malloc(soap, sizeof(api__getStdErr *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__getStdErr *)soap_instantiate_api__getStdErr(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__getStdErr ** p = (api__getStdErr **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__getStdErr, sizeof(api__getStdErr), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__getStdErr(struct soap *soap, api__getStdErr *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__getStdErr);
	if (soap_out_PointerToapi__getStdErr(soap, tag?tag:"api:getStdErr", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__getStdErr ** SOAP_FMAC4 soap_get_PointerToapi__getStdErr(struct soap *soap, api__getStdErr **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__getStdErr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__getStdOutResponse(struct soap *soap, api__getStdOutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__getStdOutResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__getStdOutResponse(struct soap *soap, const char *tag, int id, api__getStdOutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__getStdOutResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__getStdOutResponse ** SOAP_FMAC4 soap_in_PointerToapi__getStdOutResponse(struct soap *soap, const char *tag, api__getStdOutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__getStdOutResponse **)soap_malloc(soap, sizeof(api__getStdOutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__getStdOutResponse *)soap_instantiate_api__getStdOutResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__getStdOutResponse ** p = (api__getStdOutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__getStdOutResponse, sizeof(api__getStdOutResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__getStdOutResponse(struct soap *soap, api__getStdOutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__getStdOutResponse);
	if (soap_out_PointerToapi__getStdOutResponse(soap, tag?tag:"api:getStdOutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__getStdOutResponse ** SOAP_FMAC4 soap_get_PointerToapi__getStdOutResponse(struct soap *soap, api__getStdOutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__getStdOutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__getStdOut(struct soap *soap, api__getStdOut *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__getStdOut))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__getStdOut(struct soap *soap, const char *tag, int id, api__getStdOut *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__getStdOut);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__getStdOut ** SOAP_FMAC4 soap_in_PointerToapi__getStdOut(struct soap *soap, const char *tag, api__getStdOut **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__getStdOut **)soap_malloc(soap, sizeof(api__getStdOut *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__getStdOut *)soap_instantiate_api__getStdOut(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__getStdOut ** p = (api__getStdOut **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__getStdOut, sizeof(api__getStdOut), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__getStdOut(struct soap *soap, api__getStdOut *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__getStdOut);
	if (soap_out_PointerToapi__getStdOut(soap, tag?tag:"api:getStdOut", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__getStdOut ** SOAP_FMAC4 soap_get_PointerToapi__getStdOut(struct soap *soap, api__getStdOut **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__getStdOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__initExecutionResponse(struct soap *soap, api__initExecutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__initExecutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__initExecutionResponse(struct soap *soap, const char *tag, int id, api__initExecutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__initExecutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__initExecutionResponse ** SOAP_FMAC4 soap_in_PointerToapi__initExecutionResponse(struct soap *soap, const char *tag, api__initExecutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__initExecutionResponse **)soap_malloc(soap, sizeof(api__initExecutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__initExecutionResponse *)soap_instantiate_api__initExecutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__initExecutionResponse ** p = (api__initExecutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__initExecutionResponse, sizeof(api__initExecutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__initExecutionResponse(struct soap *soap, api__initExecutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__initExecutionResponse);
	if (soap_out_PointerToapi__initExecutionResponse(soap, tag?tag:"api:initExecutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__initExecutionResponse ** SOAP_FMAC4 soap_get_PointerToapi__initExecutionResponse(struct soap *soap, api__initExecutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__initExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__initExecution(struct soap *soap, api__initExecution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__initExecution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__initExecution(struct soap *soap, const char *tag, int id, api__initExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__initExecution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__initExecution ** SOAP_FMAC4 soap_in_PointerToapi__initExecution(struct soap *soap, const char *tag, api__initExecution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__initExecution **)soap_malloc(soap, sizeof(api__initExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__initExecution *)soap_instantiate_api__initExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__initExecution ** p = (api__initExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__initExecution, sizeof(api__initExecution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__initExecution(struct soap *soap, api__initExecution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__initExecution);
	if (soap_out_PointerToapi__initExecution(soap, tag?tag:"api:initExecution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__initExecution ** SOAP_FMAC4 soap_get_PointerToapi__initExecution(struct soap *soap, api__initExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__initExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__getGlobalPropertiesResponse(struct soap *soap, api__getGlobalPropertiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__getGlobalPropertiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__getGlobalPropertiesResponse(struct soap *soap, const char *tag, int id, api__getGlobalPropertiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__getGlobalPropertiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__getGlobalPropertiesResponse ** SOAP_FMAC4 soap_in_PointerToapi__getGlobalPropertiesResponse(struct soap *soap, const char *tag, api__getGlobalPropertiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__getGlobalPropertiesResponse **)soap_malloc(soap, sizeof(api__getGlobalPropertiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__getGlobalPropertiesResponse *)soap_instantiate_api__getGlobalPropertiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__getGlobalPropertiesResponse ** p = (api__getGlobalPropertiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__getGlobalPropertiesResponse, sizeof(api__getGlobalPropertiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__getGlobalPropertiesResponse(struct soap *soap, api__getGlobalPropertiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__getGlobalPropertiesResponse);
	if (soap_out_PointerToapi__getGlobalPropertiesResponse(soap, tag?tag:"api:getGlobalPropertiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__getGlobalPropertiesResponse ** SOAP_FMAC4 soap_get_PointerToapi__getGlobalPropertiesResponse(struct soap *soap, api__getGlobalPropertiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__getGlobalPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__getGlobalProperties(struct soap *soap, api__getGlobalProperties *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__getGlobalProperties))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__getGlobalProperties(struct soap *soap, const char *tag, int id, api__getGlobalProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__getGlobalProperties);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__getGlobalProperties ** SOAP_FMAC4 soap_in_PointerToapi__getGlobalProperties(struct soap *soap, const char *tag, api__getGlobalProperties **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__getGlobalProperties **)soap_malloc(soap, sizeof(api__getGlobalProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__getGlobalProperties *)soap_instantiate_api__getGlobalProperties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__getGlobalProperties ** p = (api__getGlobalProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__getGlobalProperties, sizeof(api__getGlobalProperties), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__getGlobalProperties(struct soap *soap, api__getGlobalProperties *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__getGlobalProperties);
	if (soap_out_PointerToapi__getGlobalProperties(soap, tag?tag:"api:getGlobalProperties", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__getGlobalProperties ** SOAP_FMAC4 soap_get_PointerToapi__getGlobalProperties(struct soap *soap, api__getGlobalProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__getGlobalProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__updateExecutionResponse(struct soap *soap, api__updateExecutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__updateExecutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__updateExecutionResponse(struct soap *soap, const char *tag, int id, api__updateExecutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__updateExecutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__updateExecutionResponse ** SOAP_FMAC4 soap_in_PointerToapi__updateExecutionResponse(struct soap *soap, const char *tag, api__updateExecutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__updateExecutionResponse **)soap_malloc(soap, sizeof(api__updateExecutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__updateExecutionResponse *)soap_instantiate_api__updateExecutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__updateExecutionResponse ** p = (api__updateExecutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__updateExecutionResponse, sizeof(api__updateExecutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__updateExecutionResponse(struct soap *soap, api__updateExecutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__updateExecutionResponse);
	if (soap_out_PointerToapi__updateExecutionResponse(soap, tag?tag:"api:updateExecutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__updateExecutionResponse ** SOAP_FMAC4 soap_get_PointerToapi__updateExecutionResponse(struct soap *soap, api__updateExecutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__updateExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__updateExecution(struct soap *soap, api__updateExecution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__updateExecution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__updateExecution(struct soap *soap, const char *tag, int id, api__updateExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__updateExecution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__updateExecution ** SOAP_FMAC4 soap_in_PointerToapi__updateExecution(struct soap *soap, const char *tag, api__updateExecution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__updateExecution **)soap_malloc(soap, sizeof(api__updateExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__updateExecution *)soap_instantiate_api__updateExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__updateExecution ** p = (api__updateExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__updateExecution, sizeof(api__updateExecution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__updateExecution(struct soap *soap, api__updateExecution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__updateExecution);
	if (soap_out_PointerToapi__updateExecution(soap, tag?tag:"api:updateExecution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__updateExecution ** SOAP_FMAC4 soap_get_PointerToapi__updateExecution(struct soap *soap, api__updateExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__updateExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__logoutResponse(struct soap *soap, api__logoutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__logoutResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__logoutResponse(struct soap *soap, const char *tag, int id, api__logoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__logoutResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__logoutResponse ** SOAP_FMAC4 soap_in_PointerToapi__logoutResponse(struct soap *soap, const char *tag, api__logoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__logoutResponse **)soap_malloc(soap, sizeof(api__logoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__logoutResponse *)soap_instantiate_api__logoutResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__logoutResponse ** p = (api__logoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__logoutResponse, sizeof(api__logoutResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__logoutResponse(struct soap *soap, api__logoutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__logoutResponse);
	if (soap_out_PointerToapi__logoutResponse(soap, tag?tag:"api:logoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__logoutResponse ** SOAP_FMAC4 soap_get_PointerToapi__logoutResponse(struct soap *soap, api__logoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__logout(struct soap *soap, api__logout *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__logout))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__logout(struct soap *soap, const char *tag, int id, api__logout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__logout);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__logout ** SOAP_FMAC4 soap_in_PointerToapi__logout(struct soap *soap, const char *tag, api__logout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__logout **)soap_malloc(soap, sizeof(api__logout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__logout *)soap_instantiate_api__logout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__logout ** p = (api__logout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__logout, sizeof(api__logout), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__logout(struct soap *soap, api__logout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__logout);
	if (soap_out_PointerToapi__logout(soap, tag?tag:"api:logout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__logout ** SOAP_FMAC4 soap_get_PointerToapi__logout(struct soap *soap, api__logout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__authenticateHTTPResponse(struct soap *soap, api__authenticateHTTPResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__authenticateHTTPResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__authenticateHTTPResponse(struct soap *soap, const char *tag, int id, api__authenticateHTTPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__authenticateHTTPResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__authenticateHTTPResponse ** SOAP_FMAC4 soap_in_PointerToapi__authenticateHTTPResponse(struct soap *soap, const char *tag, api__authenticateHTTPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__authenticateHTTPResponse **)soap_malloc(soap, sizeof(api__authenticateHTTPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__authenticateHTTPResponse *)soap_instantiate_api__authenticateHTTPResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__authenticateHTTPResponse ** p = (api__authenticateHTTPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__authenticateHTTPResponse, sizeof(api__authenticateHTTPResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__authenticateHTTPResponse(struct soap *soap, api__authenticateHTTPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__authenticateHTTPResponse);
	if (soap_out_PointerToapi__authenticateHTTPResponse(soap, tag?tag:"api:authenticateHTTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__authenticateHTTPResponse ** SOAP_FMAC4 soap_get_PointerToapi__authenticateHTTPResponse(struct soap *soap, api__authenticateHTTPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__authenticateHTTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__authenticateHTTP(struct soap *soap, api__authenticateHTTP *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__authenticateHTTP))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__authenticateHTTP(struct soap *soap, const char *tag, int id, api__authenticateHTTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__authenticateHTTP);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__authenticateHTTP ** SOAP_FMAC4 soap_in_PointerToapi__authenticateHTTP(struct soap *soap, const char *tag, api__authenticateHTTP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__authenticateHTTP **)soap_malloc(soap, sizeof(api__authenticateHTTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__authenticateHTTP *)soap_instantiate_api__authenticateHTTP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__authenticateHTTP ** p = (api__authenticateHTTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__authenticateHTTP, sizeof(api__authenticateHTTP), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__authenticateHTTP(struct soap *soap, api__authenticateHTTP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__authenticateHTTP);
	if (soap_out_PointerToapi__authenticateHTTP(soap, tag?tag:"api:authenticateHTTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__authenticateHTTP ** SOAP_FMAC4 soap_get_PointerToapi__authenticateHTTP(struct soap *soap, api__authenticateHTTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__authenticateHTTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__getPipelineResponse(struct soap *soap, api__getPipelineResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__getPipelineResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__getPipelineResponse(struct soap *soap, const char *tag, int id, api__getPipelineResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__getPipelineResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__getPipelineResponse ** SOAP_FMAC4 soap_in_PointerToapi__getPipelineResponse(struct soap *soap, const char *tag, api__getPipelineResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__getPipelineResponse **)soap_malloc(soap, sizeof(api__getPipelineResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__getPipelineResponse *)soap_instantiate_api__getPipelineResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__getPipelineResponse ** p = (api__getPipelineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__getPipelineResponse, sizeof(api__getPipelineResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__getPipelineResponse(struct soap *soap, api__getPipelineResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__getPipelineResponse);
	if (soap_out_PointerToapi__getPipelineResponse(soap, tag?tag:"api:getPipelineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__getPipelineResponse ** SOAP_FMAC4 soap_get_PointerToapi__getPipelineResponse(struct soap *soap, api__getPipelineResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__getPipelineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__getPipeline(struct soap *soap, api__getPipeline *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__getPipeline))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__getPipeline(struct soap *soap, const char *tag, int id, api__getPipeline *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__getPipeline);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__getPipeline ** SOAP_FMAC4 soap_in_PointerToapi__getPipeline(struct soap *soap, const char *tag, api__getPipeline **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__getPipeline **)soap_malloc(soap, sizeof(api__getPipeline *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__getPipeline *)soap_instantiate_api__getPipeline(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__getPipeline ** p = (api__getPipeline **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__getPipeline, sizeof(api__getPipeline), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__getPipeline(struct soap *soap, api__getPipeline *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__getPipeline);
	if (soap_out_PointerToapi__getPipeline(soap, tag?tag:"api:getPipeline", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__getPipeline ** SOAP_FMAC4 soap_get_PointerToapi__getPipeline(struct soap *soap, api__getPipeline **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__getPipeline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__deleteExecutionResponse(struct soap *soap, api__deleteExecutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__deleteExecutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__deleteExecutionResponse(struct soap *soap, const char *tag, int id, api__deleteExecutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__deleteExecutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__deleteExecutionResponse ** SOAP_FMAC4 soap_in_PointerToapi__deleteExecutionResponse(struct soap *soap, const char *tag, api__deleteExecutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__deleteExecutionResponse **)soap_malloc(soap, sizeof(api__deleteExecutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__deleteExecutionResponse *)soap_instantiate_api__deleteExecutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__deleteExecutionResponse ** p = (api__deleteExecutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__deleteExecutionResponse, sizeof(api__deleteExecutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__deleteExecutionResponse(struct soap *soap, api__deleteExecutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__deleteExecutionResponse);
	if (soap_out_PointerToapi__deleteExecutionResponse(soap, tag?tag:"api:deleteExecutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__deleteExecutionResponse ** SOAP_FMAC4 soap_get_PointerToapi__deleteExecutionResponse(struct soap *soap, api__deleteExecutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__deleteExecutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__deleteExecution(struct soap *soap, api__deleteExecution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__deleteExecution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__deleteExecution(struct soap *soap, const char *tag, int id, api__deleteExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__deleteExecution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__deleteExecution ** SOAP_FMAC4 soap_in_PointerToapi__deleteExecution(struct soap *soap, const char *tag, api__deleteExecution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__deleteExecution **)soap_malloc(soap, sizeof(api__deleteExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__deleteExecution *)soap_instantiate_api__deleteExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__deleteExecution ** p = (api__deleteExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__deleteExecution, sizeof(api__deleteExecution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__deleteExecution(struct soap *soap, api__deleteExecution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__deleteExecution);
	if (soap_out_PointerToapi__deleteExecution(soap, tag?tag:"api:deleteExecution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__deleteExecution ** SOAP_FMAC4 soap_get_PointerToapi__deleteExecution(struct soap *soap, api__deleteExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__deleteExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__authenticateSessionResponse(struct soap *soap, api__authenticateSessionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__authenticateSessionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__authenticateSessionResponse(struct soap *soap, const char *tag, int id, api__authenticateSessionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__authenticateSessionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__authenticateSessionResponse ** SOAP_FMAC4 soap_in_PointerToapi__authenticateSessionResponse(struct soap *soap, const char *tag, api__authenticateSessionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__authenticateSessionResponse **)soap_malloc(soap, sizeof(api__authenticateSessionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__authenticateSessionResponse *)soap_instantiate_api__authenticateSessionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__authenticateSessionResponse ** p = (api__authenticateSessionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__authenticateSessionResponse, sizeof(api__authenticateSessionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__authenticateSessionResponse(struct soap *soap, api__authenticateSessionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__authenticateSessionResponse);
	if (soap_out_PointerToapi__authenticateSessionResponse(soap, tag?tag:"api:authenticateSessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__authenticateSessionResponse ** SOAP_FMAC4 soap_get_PointerToapi__authenticateSessionResponse(struct soap *soap, api__authenticateSessionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__authenticateSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__authenticateSession(struct soap *soap, api__authenticateSession *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__authenticateSession))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__authenticateSession(struct soap *soap, const char *tag, int id, api__authenticateSession *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__authenticateSession);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__authenticateSession ** SOAP_FMAC4 soap_in_PointerToapi__authenticateSession(struct soap *soap, const char *tag, api__authenticateSession **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__authenticateSession **)soap_malloc(soap, sizeof(api__authenticateSession *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__authenticateSession *)soap_instantiate_api__authenticateSession(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__authenticateSession ** p = (api__authenticateSession **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__authenticateSession, sizeof(api__authenticateSession), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__authenticateSession(struct soap *soap, api__authenticateSession *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__authenticateSession);
	if (soap_out_PointerToapi__authenticateSession(soap, tag?tag:"api:authenticateSession", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__authenticateSession ** SOAP_FMAC4 soap_get_PointerToapi__authenticateSession(struct soap *soap, api__authenticateSession **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__authenticateSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__IntKeyStringValuePair(struct soap *soap, api__IntKeyStringValuePair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__IntKeyStringValuePair))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__IntKeyStringValuePair(struct soap *soap, const char *tag, int id, api__IntKeyStringValuePair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__IntKeyStringValuePair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__IntKeyStringValuePair ** SOAP_FMAC4 soap_in_PointerToapi__IntKeyStringValuePair(struct soap *soap, const char *tag, api__IntKeyStringValuePair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__IntKeyStringValuePair **)soap_malloc(soap, sizeof(api__IntKeyStringValuePair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__IntKeyStringValuePair *)soap_instantiate_api__IntKeyStringValuePair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__IntKeyStringValuePair ** p = (api__IntKeyStringValuePair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__IntKeyStringValuePair, sizeof(api__IntKeyStringValuePair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__IntKeyStringValuePair(struct soap *soap, api__IntKeyStringValuePair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__IntKeyStringValuePair);
	if (soap_out_PointerToapi__IntKeyStringValuePair(soap, tag?tag:"api:IntKeyStringValuePair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__IntKeyStringValuePair ** SOAP_FMAC4 soap_get_PointerToapi__IntKeyStringValuePair(struct soap *soap, api__IntKeyStringValuePair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__IntKeyStringValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__PipelineParameter(struct soap *soap, api__PipelineParameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__PipelineParameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__PipelineParameter(struct soap *soap, const char *tag, int id, api__PipelineParameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__PipelineParameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__PipelineParameter ** SOAP_FMAC4 soap_in_PointerToapi__PipelineParameter(struct soap *soap, const char *tag, api__PipelineParameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__PipelineParameter **)soap_malloc(soap, sizeof(api__PipelineParameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__PipelineParameter *)soap_instantiate_api__PipelineParameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__PipelineParameter ** p = (api__PipelineParameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__PipelineParameter, sizeof(api__PipelineParameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__PipelineParameter(struct soap *soap, api__PipelineParameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__PipelineParameter);
	if (soap_out_PointerToapi__PipelineParameter(soap, tag?tag:"api:PipelineParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__PipelineParameter ** SOAP_FMAC4 soap_get_PointerToapi__PipelineParameter(struct soap *soap, api__PipelineParameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__PipelineParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__StringKeyParameterValuePair(struct soap *soap, api__StringKeyParameterValuePair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__StringKeyParameterValuePair))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__StringKeyParameterValuePair(struct soap *soap, const char *tag, int id, api__StringKeyParameterValuePair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__StringKeyParameterValuePair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__StringKeyParameterValuePair ** SOAP_FMAC4 soap_in_PointerToapi__StringKeyParameterValuePair(struct soap *soap, const char *tag, api__StringKeyParameterValuePair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__StringKeyParameterValuePair **)soap_malloc(soap, sizeof(api__StringKeyParameterValuePair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__StringKeyParameterValuePair *)soap_instantiate_api__StringKeyParameterValuePair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__StringKeyParameterValuePair ** p = (api__StringKeyParameterValuePair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__StringKeyParameterValuePair, sizeof(api__StringKeyParameterValuePair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__StringKeyParameterValuePair(struct soap *soap, api__StringKeyParameterValuePair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__StringKeyParameterValuePair);
	if (soap_out_PointerToapi__StringKeyParameterValuePair(soap, tag?tag:"api:StringKeyParameterValuePair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__StringKeyParameterValuePair ** SOAP_FMAC4 soap_get_PointerToapi__StringKeyParameterValuePair(struct soap *soap, api__StringKeyParameterValuePair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__StringKeyParameterValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__StringKeyValuePair(struct soap *soap, api__StringKeyValuePair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__StringKeyValuePair))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__StringKeyValuePair(struct soap *soap, const char *tag, int id, api__StringKeyValuePair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__StringKeyValuePair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__StringKeyValuePair ** SOAP_FMAC4 soap_in_PointerToapi__StringKeyValuePair(struct soap *soap, const char *tag, api__StringKeyValuePair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__StringKeyValuePair **)soap_malloc(soap, sizeof(api__StringKeyValuePair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__StringKeyValuePair *)soap_instantiate_api__StringKeyValuePair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__StringKeyValuePair ** p = (api__StringKeyValuePair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__StringKeyValuePair, sizeof(api__StringKeyValuePair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__StringKeyValuePair(struct soap *soap, api__StringKeyValuePair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__StringKeyValuePair);
	if (soap_out_PointerToapi__StringKeyValuePair(soap, tag?tag:"api:StringKeyValuePair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__StringKeyValuePair ** SOAP_FMAC4 soap_get_PointerToapi__StringKeyValuePair(struct soap *soap, api__StringKeyValuePair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__StringKeyValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__ParameterTypedValue(struct soap *soap, api__ParameterTypedValue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__ParameterTypedValue))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__ParameterTypedValue(struct soap *soap, const char *tag, int id, api__ParameterTypedValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__ParameterTypedValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__ParameterTypedValue ** SOAP_FMAC4 soap_in_PointerToapi__ParameterTypedValue(struct soap *soap, const char *tag, api__ParameterTypedValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__ParameterTypedValue **)soap_malloc(soap, sizeof(api__ParameterTypedValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__ParameterTypedValue *)soap_instantiate_api__ParameterTypedValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__ParameterTypedValue ** p = (api__ParameterTypedValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__ParameterTypedValue, sizeof(api__ParameterTypedValue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__ParameterTypedValue(struct soap *soap, api__ParameterTypedValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__ParameterTypedValue);
	if (soap_out_PointerToapi__ParameterTypedValue(soap, tag?tag:"api:ParameterTypedValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__ParameterTypedValue ** SOAP_FMAC4 soap_get_PointerToapi__ParameterTypedValue(struct soap *soap, api__ParameterTypedValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__ParameterTypedValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, std::vector<api__PipelineKeyBooleanValuePair * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair))
		soap_serialize_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, int id, std::vector<api__PipelineKeyBooleanValuePair * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<api__PipelineKeyBooleanValuePair * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, std::vector<api__PipelineKeyBooleanValuePair * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<api__PipelineKeyBooleanValuePair * >**)soap_malloc(soap, sizeof(std::vector<api__PipelineKeyBooleanValuePair * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, std::vector<api__PipelineKeyBooleanValuePair * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair);
	if (soap_out_PointerTostd__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<api__PipelineKeyBooleanValuePair * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, std::vector<api__PipelineKeyBooleanValuePair * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, api__PipelineKeyBooleanValuePair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__PipelineKeyBooleanValuePair))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, int id, api__PipelineKeyBooleanValuePair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__PipelineKeyBooleanValuePair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__PipelineKeyBooleanValuePair ** SOAP_FMAC4 soap_in_PointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, api__PipelineKeyBooleanValuePair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__PipelineKeyBooleanValuePair **)soap_malloc(soap, sizeof(api__PipelineKeyBooleanValuePair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__PipelineKeyBooleanValuePair *)soap_instantiate_api__PipelineKeyBooleanValuePair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__PipelineKeyBooleanValuePair ** p = (api__PipelineKeyBooleanValuePair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__PipelineKeyBooleanValuePair, sizeof(api__PipelineKeyBooleanValuePair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, api__PipelineKeyBooleanValuePair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__PipelineKeyBooleanValuePair);
	if (soap_out_PointerToapi__PipelineKeyBooleanValuePair(soap, tag?tag:"api:PipelineKeyBooleanValuePair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__PipelineKeyBooleanValuePair ** SOAP_FMAC4 soap_get_PointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, api__PipelineKeyBooleanValuePair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__PipelineKeyBooleanValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__ExecutionStatus(struct soap *soap, enum api__ExecutionStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_api__ExecutionStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__ExecutionStatus(struct soap *soap, const char *tag, int id, enum api__ExecutionStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__ExecutionStatus);
	if (id < 0)
		return soap->error;
	return soap_out_api__ExecutionStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum api__ExecutionStatus ** SOAP_FMAC4 soap_in_PointerToapi__ExecutionStatus(struct soap *soap, const char *tag, enum api__ExecutionStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum api__ExecutionStatus **)soap_malloc(soap, sizeof(enum api__ExecutionStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_api__ExecutionStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum api__ExecutionStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__ExecutionStatus, sizeof(enum api__ExecutionStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__ExecutionStatus(struct soap *soap, enum api__ExecutionStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__ExecutionStatus);
	if (soap_out_PointerToapi__ExecutionStatus(soap, tag?tag:"api:ExecutionStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum api__ExecutionStatus ** SOAP_FMAC4 soap_get_PointerToapi__ExecutionStatus(struct soap *soap, enum api__ExecutionStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__ExecutionStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfPipelines(struct soap *soap, std::vector<api__ArrayOfPipelines * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfPipelines))
		soap_serialize_std__vectorTemplateOfPointerToapi__ArrayOfPipelines(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfPipelines(struct soap *soap, const char *tag, int id, std::vector<api__ArrayOfPipelines * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerToapi__ArrayOfPipelines(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<api__ArrayOfPipelines * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfPipelines(struct soap *soap, const char *tag, std::vector<api__ArrayOfPipelines * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<api__ArrayOfPipelines * >**)soap_malloc(soap, sizeof(std::vector<api__ArrayOfPipelines * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerToapi__ArrayOfPipelines(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfPipelines(struct soap *soap, std::vector<api__ArrayOfPipelines * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfPipelines);
	if (soap_out_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfPipelines(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<api__ArrayOfPipelines * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfPipelines(struct soap *soap, std::vector<api__ArrayOfPipelines * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfPipelines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__ArrayOfPipelines(struct soap *soap, api__ArrayOfPipelines *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__ArrayOfPipelines))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__ArrayOfPipelines(struct soap *soap, const char *tag, int id, api__ArrayOfPipelines *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__ArrayOfPipelines);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__ArrayOfPipelines ** SOAP_FMAC4 soap_in_PointerToapi__ArrayOfPipelines(struct soap *soap, const char *tag, api__ArrayOfPipelines **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__ArrayOfPipelines **)soap_malloc(soap, sizeof(api__ArrayOfPipelines *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__ArrayOfPipelines *)soap_instantiate_api__ArrayOfPipelines(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__ArrayOfPipelines ** p = (api__ArrayOfPipelines **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__ArrayOfPipelines, sizeof(api__ArrayOfPipelines), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__ArrayOfPipelines(struct soap *soap, api__ArrayOfPipelines *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__ArrayOfPipelines);
	if (soap_out_PointerToapi__ArrayOfPipelines(soap, tag?tag:"api:ArrayOfPipelines", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__ArrayOfPipelines ** SOAP_FMAC4 soap_get_PointerToapi__ArrayOfPipelines(struct soap *soap, api__ArrayOfPipelines **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__ArrayOfPipelines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfExecutions(struct soap *soap, std::vector<api__ArrayOfExecutions * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfExecutions))
		soap_serialize_std__vectorTemplateOfPointerToapi__ArrayOfExecutions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfExecutions(struct soap *soap, const char *tag, int id, std::vector<api__ArrayOfExecutions * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerToapi__ArrayOfExecutions(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<api__ArrayOfExecutions * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfExecutions(struct soap *soap, const char *tag, std::vector<api__ArrayOfExecutions * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<api__ArrayOfExecutions * >**)soap_malloc(soap, sizeof(std::vector<api__ArrayOfExecutions * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerToapi__ArrayOfExecutions(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfExecutions(struct soap *soap, std::vector<api__ArrayOfExecutions * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfExecutions);
	if (soap_out_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfExecutions(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<api__ArrayOfExecutions * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfExecutions(struct soap *soap, std::vector<api__ArrayOfExecutions * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfExecutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__ArrayOfExecutions(struct soap *soap, api__ArrayOfExecutions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__ArrayOfExecutions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__ArrayOfExecutions(struct soap *soap, const char *tag, int id, api__ArrayOfExecutions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__ArrayOfExecutions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__ArrayOfExecutions ** SOAP_FMAC4 soap_in_PointerToapi__ArrayOfExecutions(struct soap *soap, const char *tag, api__ArrayOfExecutions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__ArrayOfExecutions **)soap_malloc(soap, sizeof(api__ArrayOfExecutions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__ArrayOfExecutions *)soap_instantiate_api__ArrayOfExecutions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__ArrayOfExecutions ** p = (api__ArrayOfExecutions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__ArrayOfExecutions, sizeof(api__ArrayOfExecutions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__ArrayOfExecutions(struct soap *soap, api__ArrayOfExecutions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__ArrayOfExecutions);
	if (soap_out_PointerToapi__ArrayOfExecutions(soap, tag?tag:"api:ArrayOfExecutions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__ArrayOfExecutions ** SOAP_FMAC4 soap_get_PointerToapi__ArrayOfExecutions(struct soap *soap, api__ArrayOfExecutions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__ArrayOfExecutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfStrings(struct soap *soap, std::vector<api__ArrayOfStrings * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfStrings))
		soap_serialize_std__vectorTemplateOfPointerToapi__ArrayOfStrings(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfStrings(struct soap *soap, const char *tag, int id, std::vector<api__ArrayOfStrings * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerToapi__ArrayOfStrings(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<api__ArrayOfStrings * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfStrings(struct soap *soap, const char *tag, std::vector<api__ArrayOfStrings * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<api__ArrayOfStrings * >**)soap_malloc(soap, sizeof(std::vector<api__ArrayOfStrings * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerToapi__ArrayOfStrings(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfStrings(struct soap *soap, std::vector<api__ArrayOfStrings * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfStrings);
	if (soap_out_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfStrings(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<api__ArrayOfStrings * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfStrings(struct soap *soap, std::vector<api__ArrayOfStrings * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerToapi__ArrayOfStrings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__ArrayOfStrings(struct soap *soap, api__ArrayOfStrings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__ArrayOfStrings))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__ArrayOfStrings(struct soap *soap, const char *tag, int id, api__ArrayOfStrings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__ArrayOfStrings);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__ArrayOfStrings ** SOAP_FMAC4 soap_in_PointerToapi__ArrayOfStrings(struct soap *soap, const char *tag, api__ArrayOfStrings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__ArrayOfStrings **)soap_malloc(soap, sizeof(api__ArrayOfStrings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__ArrayOfStrings *)soap_instantiate_api__ArrayOfStrings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__ArrayOfStrings ** p = (api__ArrayOfStrings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__ArrayOfStrings, sizeof(api__ArrayOfStrings), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__ArrayOfStrings(struct soap *soap, api__ArrayOfStrings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__ArrayOfStrings);
	if (soap_out_PointerToapi__ArrayOfStrings(soap, tag?tag:"api:ArrayOfStrings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__ArrayOfStrings ** SOAP_FMAC4 soap_get_PointerToapi__ArrayOfStrings(struct soap *soap, api__ArrayOfStrings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__ArrayOfStrings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfstd__string))
		soap_serialize_std__vectorTemplateOfstd__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, std::vector<std::string >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfstd__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<std::string >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<std::string >**)soap_malloc(soap, sizeof(std::vector<std::string >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfstd__string(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfstd__string);
	if (soap_out_PointerTostd__vectorTemplateOfstd__string(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<std::string >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfstd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__GlobalProperties(struct soap *soap, api__GlobalProperties *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__GlobalProperties))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__GlobalProperties(struct soap *soap, const char *tag, int id, api__GlobalProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__GlobalProperties);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__GlobalProperties ** SOAP_FMAC4 soap_in_PointerToapi__GlobalProperties(struct soap *soap, const char *tag, api__GlobalProperties **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__GlobalProperties **)soap_malloc(soap, sizeof(api__GlobalProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__GlobalProperties *)soap_instantiate_api__GlobalProperties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__GlobalProperties ** p = (api__GlobalProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__GlobalProperties, sizeof(api__GlobalProperties), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__GlobalProperties(struct soap *soap, api__GlobalProperties *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__GlobalProperties);
	if (soap_out_PointerToapi__GlobalProperties(soap, tag?tag:"api:GlobalProperties", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__GlobalProperties ** SOAP_FMAC4 soap_get_PointerToapi__GlobalProperties(struct soap *soap, api__GlobalProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__GlobalProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__Execution(struct soap *soap, api__Execution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__Execution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__Execution(struct soap *soap, const char *tag, int id, api__Execution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__Execution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__Execution ** SOAP_FMAC4 soap_in_PointerToapi__Execution(struct soap *soap, const char *tag, api__Execution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__Execution **)soap_malloc(soap, sizeof(api__Execution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__Execution *)soap_instantiate_api__Execution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__Execution ** p = (api__Execution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__Execution, sizeof(api__Execution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__Execution(struct soap *soap, api__Execution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__Execution);
	if (soap_out_PointerToapi__Execution(soap, tag?tag:"api:Execution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__Execution ** SOAP_FMAC4 soap_get_PointerToapi__Execution(struct soap *soap, api__Execution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__Execution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerToapi__Pipeline(struct soap *soap, std::vector<api__Pipeline * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerToapi__Pipeline))
		soap_serialize_std__vectorTemplateOfPointerToapi__Pipeline(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerToapi__Pipeline(struct soap *soap, const char *tag, int id, std::vector<api__Pipeline * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerToapi__Pipeline(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<api__Pipeline * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerToapi__Pipeline(struct soap *soap, const char *tag, std::vector<api__Pipeline * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<api__Pipeline * >**)soap_malloc(soap, sizeof(std::vector<api__Pipeline * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerToapi__Pipeline(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerToapi__Pipeline(struct soap *soap, std::vector<api__Pipeline * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToapi__Pipeline);
	if (soap_out_PointerTostd__vectorTemplateOfPointerToapi__Pipeline(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<api__Pipeline * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerToapi__Pipeline(struct soap *soap, std::vector<api__Pipeline * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerToapi__Pipeline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__Pipeline(struct soap *soap, api__Pipeline *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__Pipeline))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__Pipeline(struct soap *soap, const char *tag, int id, api__Pipeline *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__Pipeline);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__Pipeline ** SOAP_FMAC4 soap_in_PointerToapi__Pipeline(struct soap *soap, const char *tag, api__Pipeline **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__Pipeline **)soap_malloc(soap, sizeof(api__Pipeline *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__Pipeline *)soap_instantiate_api__Pipeline(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__Pipeline ** p = (api__Pipeline **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__Pipeline, sizeof(api__Pipeline), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__Pipeline(struct soap *soap, api__Pipeline *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__Pipeline);
	if (soap_out_PointerToapi__Pipeline(soap, tag?tag:"api:Pipeline", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__Pipeline ** SOAP_FMAC4 soap_get_PointerToapi__Pipeline(struct soap *soap, api__Pipeline **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__Pipeline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapi__Response(struct soap *soap, api__Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_api__Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapi__Response(struct soap *soap, const char *tag, int id, api__Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_api__Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 api__Response ** SOAP_FMAC4 soap_in_PointerToapi__Response(struct soap *soap, const char *tag, api__Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (api__Response **)soap_malloc(soap, sizeof(api__Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (api__Response *)soap_instantiate_api__Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	api__Response ** p = (api__Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_api__Response, sizeof(api__Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapi__Response(struct soap *soap, api__Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapi__Response);
	if (soap_out_PointerToapi__Response(soap, tag?tag:"api:Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 api__Response ** SOAP_FMAC4 soap_get_PointerToapi__Response(struct soap *soap, api__Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapi__Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfapi__Module(struct soap *soap, std::vector<enum api__Module >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfapi__Module(struct soap *soap, const std::vector<enum api__Module >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfapi__Module(struct soap *soap, const char *tag, int id, const std::vector<enum api__Module >*a, const char *type)
{
	for (std::vector<enum api__Module >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_api__Module(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum api__Module >* SOAP_FMAC4 soap_in_std__vectorTemplateOfapi__Module(struct soap *soap, const char *tag, std::vector<enum api__Module >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfapi__Module(soap, -1)))
		return NULL;
	enum api__Module n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_api__Module(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_api__Module, SOAP_TYPE_std__vectorTemplateOfapi__Module, sizeof(enum api__Module), 0))
				break;
			if (!soap_in_api__Module(soap, tag, NULL, "api:Module"))
				break;
		}
		else
		{
			if (!soap_in_api__Module(soap, tag, &n, "api:Module"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum api__Module > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfapi__Module(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfapi__Module(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfapi__Module, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum api__Module >);
		if (size)
			*size = sizeof(std::vector<enum api__Module >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum api__Module >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum api__Module >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum api__Module >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfapi__Module(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum api__Module > %p -> %p\n", q, p));
	*(std::vector<enum api__Module >*)p = *(std::vector<enum api__Module >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(struct soap *soap, std::vector<api__IntKeyStringValuePair * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(struct soap *soap, const std::vector<api__IntKeyStringValuePair * >*a)
{
	for (std::vector<api__IntKeyStringValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToapi__IntKeyStringValuePair(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(struct soap *soap, const char *tag, int id, const std::vector<api__IntKeyStringValuePair * >*a, const char *type)
{
	for (std::vector<api__IntKeyStringValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToapi__IntKeyStringValuePair(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<api__IntKeyStringValuePair * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(struct soap *soap, const char *tag, std::vector<api__IntKeyStringValuePair * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(soap, -1)))
		return NULL;
	api__IntKeyStringValuePair *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_api__IntKeyStringValuePair, SOAP_TYPE_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair, sizeof(api__IntKeyStringValuePair), 1))
				break;
			if (!soap_in_PointerToapi__IntKeyStringValuePair(soap, tag, NULL, "api:IntKeyStringValuePair"))
				break;
		}
		else
		{
			if (!soap_in_PointerToapi__IntKeyStringValuePair(soap, tag, &n, "api:IntKeyStringValuePair"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<api__IntKeyStringValuePair * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__IntKeyStringValuePair * >);
		if (size)
			*size = sizeof(std::vector<api__IntKeyStringValuePair * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__IntKeyStringValuePair * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<api__IntKeyStringValuePair * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<api__IntKeyStringValuePair * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToapi__IntKeyStringValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<api__IntKeyStringValuePair * > %p -> %p\n", q, p));
	*(std::vector<api__IntKeyStringValuePair * >*)p = *(std::vector<api__IntKeyStringValuePair * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToapi__PipelineParameter(struct soap *soap, std::vector<api__PipelineParameter * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToapi__PipelineParameter(struct soap *soap, const std::vector<api__PipelineParameter * >*a)
{
	for (std::vector<api__PipelineParameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToapi__PipelineParameter(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToapi__PipelineParameter(struct soap *soap, const char *tag, int id, const std::vector<api__PipelineParameter * >*a, const char *type)
{
	for (std::vector<api__PipelineParameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToapi__PipelineParameter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<api__PipelineParameter * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToapi__PipelineParameter(struct soap *soap, const char *tag, std::vector<api__PipelineParameter * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToapi__PipelineParameter(soap, -1)))
		return NULL;
	api__PipelineParameter *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_api__PipelineParameter, SOAP_TYPE_std__vectorTemplateOfPointerToapi__PipelineParameter, sizeof(api__PipelineParameter), 1))
				break;
			if (!soap_in_PointerToapi__PipelineParameter(soap, tag, NULL, "api:PipelineParameter"))
				break;
		}
		else
		{
			if (!soap_in_PointerToapi__PipelineParameter(soap, tag, &n, "api:PipelineParameter"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<api__PipelineParameter * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToapi__PipelineParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToapi__PipelineParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToapi__PipelineParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__PipelineParameter * >);
		if (size)
			*size = sizeof(std::vector<api__PipelineParameter * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__PipelineParameter * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<api__PipelineParameter * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<api__PipelineParameter * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToapi__PipelineParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<api__PipelineParameter * > %p -> %p\n", q, p));
	*(std::vector<api__PipelineParameter * >*)p = *(std::vector<api__PipelineParameter * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(struct soap *soap, std::vector<api__StringKeyParameterValuePair * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(struct soap *soap, const std::vector<api__StringKeyParameterValuePair * >*a)
{
	for (std::vector<api__StringKeyParameterValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToapi__StringKeyParameterValuePair(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(struct soap *soap, const char *tag, int id, const std::vector<api__StringKeyParameterValuePair * >*a, const char *type)
{
	for (std::vector<api__StringKeyParameterValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToapi__StringKeyParameterValuePair(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<api__StringKeyParameterValuePair * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(struct soap *soap, const char *tag, std::vector<api__StringKeyParameterValuePair * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(soap, -1)))
		return NULL;
	api__StringKeyParameterValuePair *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_api__StringKeyParameterValuePair, SOAP_TYPE_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair, sizeof(api__StringKeyParameterValuePair), 1))
				break;
			if (!soap_in_PointerToapi__StringKeyParameterValuePair(soap, tag, NULL, "api:StringKeyParameterValuePair"))
				break;
		}
		else
		{
			if (!soap_in_PointerToapi__StringKeyParameterValuePair(soap, tag, &n, "api:StringKeyParameterValuePair"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<api__StringKeyParameterValuePair * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__StringKeyParameterValuePair * >);
		if (size)
			*size = sizeof(std::vector<api__StringKeyParameterValuePair * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__StringKeyParameterValuePair * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<api__StringKeyParameterValuePair * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<api__StringKeyParameterValuePair * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToapi__StringKeyParameterValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<api__StringKeyParameterValuePair * > %p -> %p\n", q, p));
	*(std::vector<api__StringKeyParameterValuePair * >*)p = *(std::vector<api__StringKeyParameterValuePair * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToapi__StringKeyValuePair(struct soap *soap, std::vector<api__StringKeyValuePair * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToapi__StringKeyValuePair(struct soap *soap, const std::vector<api__StringKeyValuePair * >*a)
{
	for (std::vector<api__StringKeyValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToapi__StringKeyValuePair(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToapi__StringKeyValuePair(struct soap *soap, const char *tag, int id, const std::vector<api__StringKeyValuePair * >*a, const char *type)
{
	for (std::vector<api__StringKeyValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToapi__StringKeyValuePair(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<api__StringKeyValuePair * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToapi__StringKeyValuePair(struct soap *soap, const char *tag, std::vector<api__StringKeyValuePair * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToapi__StringKeyValuePair(soap, -1)))
		return NULL;
	api__StringKeyValuePair *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_api__StringKeyValuePair, SOAP_TYPE_std__vectorTemplateOfPointerToapi__StringKeyValuePair, sizeof(api__StringKeyValuePair), 1))
				break;
			if (!soap_in_PointerToapi__StringKeyValuePair(soap, tag, NULL, "api:StringKeyValuePair"))
				break;
		}
		else
		{
			if (!soap_in_PointerToapi__StringKeyValuePair(soap, tag, &n, "api:StringKeyValuePair"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<api__StringKeyValuePair * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToapi__StringKeyValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToapi__StringKeyValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToapi__StringKeyValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__StringKeyValuePair * >);
		if (size)
			*size = sizeof(std::vector<api__StringKeyValuePair * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__StringKeyValuePair * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<api__StringKeyValuePair * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<api__StringKeyValuePair * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToapi__StringKeyValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<api__StringKeyValuePair * > %p -> %p\n", q, p));
	*(std::vector<api__StringKeyValuePair * >*)p = *(std::vector<api__StringKeyValuePair * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToapi__Execution(struct soap *soap, std::vector<api__Execution * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToapi__Execution(struct soap *soap, const std::vector<api__Execution * >*a)
{
	for (std::vector<api__Execution * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToapi__Execution(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToapi__Execution(struct soap *soap, const char *tag, int id, const std::vector<api__Execution * >*a, const char *type)
{
	for (std::vector<api__Execution * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToapi__Execution(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<api__Execution * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToapi__Execution(struct soap *soap, const char *tag, std::vector<api__Execution * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToapi__Execution(soap, -1)))
		return NULL;
	api__Execution *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_api__Execution, SOAP_TYPE_std__vectorTemplateOfPointerToapi__Execution, sizeof(api__Execution), 1))
				break;
			if (!soap_in_PointerToapi__Execution(soap, tag, NULL, "api:Execution"))
				break;
		}
		else
		{
			if (!soap_in_PointerToapi__Execution(soap, tag, &n, "api:Execution"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<api__Execution * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToapi__Execution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToapi__Execution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToapi__Execution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__Execution * >);
		if (size)
			*size = sizeof(std::vector<api__Execution * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__Execution * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<api__Execution * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<api__Execution * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToapi__Execution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<api__Execution * > %p -> %p\n", q, p));
	*(std::vector<api__Execution * >*)p = *(std::vector<api__Execution * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, std::vector<api__PipelineKeyBooleanValuePair * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, const std::vector<api__PipelineKeyBooleanValuePair * >*a)
{
	for (std::vector<api__PipelineKeyBooleanValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToapi__PipelineKeyBooleanValuePair(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, int id, const std::vector<api__PipelineKeyBooleanValuePair * >*a, const char *type)
{
	for (std::vector<api__PipelineKeyBooleanValuePair * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToapi__PipelineKeyBooleanValuePair(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<api__PipelineKeyBooleanValuePair * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, const char *tag, std::vector<api__PipelineKeyBooleanValuePair * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(soap, -1)))
		return NULL;
	api__PipelineKeyBooleanValuePair *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_api__PipelineKeyBooleanValuePair, SOAP_TYPE_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair, sizeof(api__PipelineKeyBooleanValuePair), 1))
				break;
			if (!soap_in_PointerToapi__PipelineKeyBooleanValuePair(soap, tag, NULL, "api:PipelineKeyBooleanValuePair"))
				break;
		}
		else
		{
			if (!soap_in_PointerToapi__PipelineKeyBooleanValuePair(soap, tag, &n, "api:PipelineKeyBooleanValuePair"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<api__PipelineKeyBooleanValuePair * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__PipelineKeyBooleanValuePair * >);
		if (size)
			*size = sizeof(std::vector<api__PipelineKeyBooleanValuePair * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__PipelineKeyBooleanValuePair * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<api__PipelineKeyBooleanValuePair * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<api__PipelineKeyBooleanValuePair * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToapi__PipelineKeyBooleanValuePair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<api__PipelineKeyBooleanValuePair * > %p -> %p\n", q, p));
	*(std::vector<api__PipelineKeyBooleanValuePair * >*)p = *(std::vector<api__PipelineKeyBooleanValuePair * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToapi__ArrayOfPipelines(struct soap *soap, std::vector<api__ArrayOfPipelines * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToapi__ArrayOfPipelines(struct soap *soap, const std::vector<api__ArrayOfPipelines * >*a)
{
	for (std::vector<api__ArrayOfPipelines * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToapi__ArrayOfPipelines(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToapi__ArrayOfPipelines(struct soap *soap, const char *tag, int id, const std::vector<api__ArrayOfPipelines * >*a, const char *type)
{
	for (std::vector<api__ArrayOfPipelines * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToapi__ArrayOfPipelines(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<api__ArrayOfPipelines * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToapi__ArrayOfPipelines(struct soap *soap, const char *tag, std::vector<api__ArrayOfPipelines * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToapi__ArrayOfPipelines(soap, -1)))
		return NULL;
	api__ArrayOfPipelines *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_api__ArrayOfPipelines, SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfPipelines, sizeof(api__ArrayOfPipelines), 1))
				break;
			if (!soap_in_PointerToapi__ArrayOfPipelines(soap, tag, NULL, "api:ArrayOfPipelines"))
				break;
		}
		else
		{
			if (!soap_in_PointerToapi__ArrayOfPipelines(soap, tag, &n, "api:ArrayOfPipelines"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<api__ArrayOfPipelines * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToapi__ArrayOfPipelines(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToapi__ArrayOfPipelines(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfPipelines, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__ArrayOfPipelines * >);
		if (size)
			*size = sizeof(std::vector<api__ArrayOfPipelines * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__ArrayOfPipelines * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<api__ArrayOfPipelines * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<api__ArrayOfPipelines * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToapi__ArrayOfPipelines(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<api__ArrayOfPipelines * > %p -> %p\n", q, p));
	*(std::vector<api__ArrayOfPipelines * >*)p = *(std::vector<api__ArrayOfPipelines * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToapi__ArrayOfExecutions(struct soap *soap, std::vector<api__ArrayOfExecutions * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToapi__ArrayOfExecutions(struct soap *soap, const std::vector<api__ArrayOfExecutions * >*a)
{
	for (std::vector<api__ArrayOfExecutions * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToapi__ArrayOfExecutions(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToapi__ArrayOfExecutions(struct soap *soap, const char *tag, int id, const std::vector<api__ArrayOfExecutions * >*a, const char *type)
{
	for (std::vector<api__ArrayOfExecutions * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToapi__ArrayOfExecutions(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<api__ArrayOfExecutions * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToapi__ArrayOfExecutions(struct soap *soap, const char *tag, std::vector<api__ArrayOfExecutions * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToapi__ArrayOfExecutions(soap, -1)))
		return NULL;
	api__ArrayOfExecutions *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_api__ArrayOfExecutions, SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfExecutions, sizeof(api__ArrayOfExecutions), 1))
				break;
			if (!soap_in_PointerToapi__ArrayOfExecutions(soap, tag, NULL, "api:ArrayOfExecutions"))
				break;
		}
		else
		{
			if (!soap_in_PointerToapi__ArrayOfExecutions(soap, tag, &n, "api:ArrayOfExecutions"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<api__ArrayOfExecutions * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToapi__ArrayOfExecutions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToapi__ArrayOfExecutions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfExecutions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__ArrayOfExecutions * >);
		if (size)
			*size = sizeof(std::vector<api__ArrayOfExecutions * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__ArrayOfExecutions * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<api__ArrayOfExecutions * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<api__ArrayOfExecutions * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToapi__ArrayOfExecutions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<api__ArrayOfExecutions * > %p -> %p\n", q, p));
	*(std::vector<api__ArrayOfExecutions * >*)p = *(std::vector<api__ArrayOfExecutions * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToapi__ArrayOfStrings(struct soap *soap, std::vector<api__ArrayOfStrings * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToapi__ArrayOfStrings(struct soap *soap, const std::vector<api__ArrayOfStrings * >*a)
{
	for (std::vector<api__ArrayOfStrings * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToapi__ArrayOfStrings(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToapi__ArrayOfStrings(struct soap *soap, const char *tag, int id, const std::vector<api__ArrayOfStrings * >*a, const char *type)
{
	for (std::vector<api__ArrayOfStrings * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToapi__ArrayOfStrings(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<api__ArrayOfStrings * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToapi__ArrayOfStrings(struct soap *soap, const char *tag, std::vector<api__ArrayOfStrings * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToapi__ArrayOfStrings(soap, -1)))
		return NULL;
	api__ArrayOfStrings *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_api__ArrayOfStrings, SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfStrings, sizeof(api__ArrayOfStrings), 1))
				break;
			if (!soap_in_PointerToapi__ArrayOfStrings(soap, tag, NULL, "api:ArrayOfStrings"))
				break;
		}
		else
		{
			if (!soap_in_PointerToapi__ArrayOfStrings(soap, tag, &n, "api:ArrayOfStrings"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<api__ArrayOfStrings * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToapi__ArrayOfStrings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToapi__ArrayOfStrings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToapi__ArrayOfStrings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__ArrayOfStrings * >);
		if (size)
			*size = sizeof(std::vector<api__ArrayOfStrings * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__ArrayOfStrings * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<api__ArrayOfStrings * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<api__ArrayOfStrings * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToapi__ArrayOfStrings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<api__ArrayOfStrings * > %p -> %p\n", q, p));
	*(std::vector<api__ArrayOfStrings * >*)p = *(std::vector<api__ArrayOfStrings * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToapi__Pipeline(struct soap *soap, std::vector<api__Pipeline * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToapi__Pipeline(struct soap *soap, const std::vector<api__Pipeline * >*a)
{
	for (std::vector<api__Pipeline * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToapi__Pipeline(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToapi__Pipeline(struct soap *soap, const char *tag, int id, const std::vector<api__Pipeline * >*a, const char *type)
{
	for (std::vector<api__Pipeline * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToapi__Pipeline(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<api__Pipeline * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToapi__Pipeline(struct soap *soap, const char *tag, std::vector<api__Pipeline * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToapi__Pipeline(soap, -1)))
		return NULL;
	api__Pipeline *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_api__Pipeline, SOAP_TYPE_std__vectorTemplateOfPointerToapi__Pipeline, sizeof(api__Pipeline), 1))
				break;
			if (!soap_in_PointerToapi__Pipeline(soap, tag, NULL, "api:Pipeline"))
				break;
		}
		else
		{
			if (!soap_in_PointerToapi__Pipeline(soap, tag, &n, "api:Pipeline"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<api__Pipeline * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToapi__Pipeline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToapi__Pipeline(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToapi__Pipeline, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__Pipeline * >);
		if (size)
			*size = sizeof(std::vector<api__Pipeline * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<api__Pipeline * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<api__Pipeline * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<api__Pipeline * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToapi__Pipeline(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<api__Pipeline * > %p -> %p\n", q, p));
	*(std::vector<api__Pipeline * >*)p = *(std::vector<api__Pipeline * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
